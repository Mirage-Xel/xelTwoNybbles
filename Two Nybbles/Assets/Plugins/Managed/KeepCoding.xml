<?xml version="1.0"?>
<doc>
    <assembly>
        <name>KeepCoding</name>
    </assembly>
    <members>
        <member name="T:KeepCoding.Internal.RoutineBase">
            <summary>
            Provides the base <see langword="class"/> for the multiple routine types.
            </summary>
            <remarks>
            <see cref="T:KeepCoding.Internal.RoutineBase"/> provides the general functionality that different types of routines share in common with. As each different type of routine gives different amounts of generics, this base <see langword="class"/> is therefore non-generic and provides every method that doesn't require it. This can therefore be used as a way of passing in an ambiguous type of routine.
            </remarks>
            <example>
            The following example illustrates a method for returning a <see cref="T:KeepCoding.Tuple`2"/> of the first and last coroutines, using <see cref="M:KeepCoding.TypeHelper.ToTuple``2(``0,``1)"/> as shorthand for constructing the tuple. This method needs a <see cref="T:KeepCoding.Internal.RoutineBase"/> with at least 1 coroutine, so an exception is raised if <see cref="P:KeepCoding.Internal.RoutineBase.Count"/> is 0.
            <code>using KeepCoding;
            using KeepCoding.Internal;
            using UnityEngine;
            
            public static class CoroutineHelper
            {
                public static Tuple&lt;Coroutine, Coroutine&gt; FirstAndLast(RoutineBase routine)
                {
                    if (routine.Count == 0)
                        throw new EmptyIteratorException("routine");
                        
                    return routine[0].ToTuple(routine[routine.Count - 1]);
                }
            }
            </code>
            This can be called with anything that inherits from this type to get the coroutines. This example will use the types <see cref="T:KeepCoding.Routine"/> and <see cref="T:KeepCoding.Routine`1"/>.
            <code>using System.Collections;
            using KeepCoding;
            using UnityEngine;
            
            public sealed class FooModule : ModuleScript
            {
                private void Start()
                {
                    Routine routine = new Routine(() => NoParameters(), this);
                    Routine otherRoutine = new Routine(i => OneParameter(i), this);
                    
                    // We need to create coroutines before passing them into the method.
                    for (int i = 0; i &lt; 5; i++)
                    {
                        routine.Start();
                        
                        // This line ends up logging the numbers [ 1, 2, 3, 4, 5 ] due to OneParameter() calling Log()
                        otherRoutine.Start(i);
                    }
                    
                    Tuple&lt;Coroutine, Coroutine&gt; coroutineTuple = CoroutineHelper.FirstAndLast(routine)
                    
                    // Stops the first coroutine.
                    StopCoroutine(coroutineTuple.Item1);
                    
                    coroutineTuple = CoroutineHelper.FirstAndLast(otherRoutine);
                    
                    // Stops the last coroutine.
                    StopCoroutine(coroutineTuple.Item2);
                    
                    // This empties the list of coroutines it has internally.
                    routine.StopAll();
                    
                    // Uncomment this line below to see an EmptyIteratorException being thrown due to the above line clearing the list.
                    // coroutineTuple = CoroutineHelper.FirstAndLast(routine);
                }
                
                private IEnumerator NoParameters()
                {
                    yield return null;
                }
                
                private IEnumerator OneParameter(int i)
                {
                    Log(i);
                    yield return null;
                }
            }
            </code>
            </example>
            <seealso cref="P:KeepCoding.Internal.RoutineBase.Count"/>
            <seealso cref="T:KeepCoding.Routine"/>
            <seealso cref="T:KeepCoding.Tuple`2"/>
            <seealso cref="M:KeepCoding.TypeHelper.ToTuple``2(``0,``1)"/>
        </member>
        <member name="P:KeepCoding.Internal.RoutineBase.Item(System.Int32)">
            <summary>
            Indexes into <see cref="P:KeepCoding.Internal.RoutineBase.Coroutines"/>.
            </summary>
            <value>
            A coroutine from <see cref="P:KeepCoding.Internal.RoutineBase.Coroutines"/> based on the index that was passed in.
            </value>
            <remarks>
            Given that <see cref="T:KeepCoding.Internal.RoutineBase"/> acts as a wrapper for handling mulitple coroutines, all of which stored in a <see cref="T:System.Collections.Generic.List`1"/>, this acts as shorthand for accessing a specific index from <see cref="P:KeepCoding.Internal.RoutineBase.Coroutines"/>.
            </remarks>
            <example>
            The following example illustrates using one of the implementations of <see cref="T:KeepCoding.Internal.RoutineBase"/>, in this case <see cref="T:KeepCoding.Routine"/> to index into <see cref="P:KeepCoding.Internal.RoutineBase.Coroutines"/>, to show that using the indexer is the same as using <see cref="P:KeepCoding.Internal.RoutineBase.Coroutines"/>. This is because <see cref="T:KeepCoding.Internal.RoutineBase"/> by itself does not allow you to append any coroutines.
            <code>using System.Collections;
            using KeepCoding;
            using UnityEngine;
            
            public sealed class FooModule : ModuleScript
            {
                private void Start()
                {
                    Routine routine = new Routine(Example(), this);
                    
                    // This creates a coroutine inside of this variable. There is now 1 coroutine which can be indexed.
                    routine.Start();
                    
                    // Because they are the same instance, this expression returns true.
                    Log(routine[0] == routine.Coroutines[0]);
                }
                
                private IEnumerator Example()
                {
                    yield return null;
                }
            }
            </code>
            This is the output from the console.
            <code>[Foo #1] True
            </code>
            It is important to note that this is a getter-only property. This means that the following statement cannot be done. Use <see cref="M:KeepCoding.Internal.RoutineBase.Stop"/>, <see cref="M:KeepCoding.Internal.RoutineBase.StopAll"/>, or other methods by implemented classes to mutate <see cref="P:KeepCoding.Internal.RoutineBase.Coroutines"/>.
            <code>// Invalid. There is no setter for this indexer.
            routine[1] = routine[0];
            </code>
            </example>
            <seealso cref="P:KeepCoding.Internal.RoutineBase.Coroutines"/>
            <seealso cref="T:KeepCoding.Routine"/>
            <seealso cref="M:KeepCoding.Internal.RoutineBase.Stop"/>
            <seealso cref="M:KeepCoding.Internal.RoutineBase.StopAll"/>
            <param name="index">The index to index into <see cref="P:KeepCoding.Internal.RoutineBase.Coroutines"/>.</param>
            <exception cref="T:System.IndexOutOfRangeException">The parameter <paramref name="index"/> is out of range from <see cref="P:KeepCoding.Internal.RoutineBase.Coroutines"/>.</exception>
            <returns>The coroutine from <see cref="P:KeepCoding.Internal.RoutineBase.Coroutines"/>.</returns>
        </member>
        <member name="P:KeepCoding.Internal.RoutineBase.IsRunning">
            <summary>
            Determines whether it is currently running any coroutines.
            </summary>
            <value>
            A <see cref="T:System.Boolean"/> representing the state in which any coroutines are running.
            </value>
            <remarks>
            Typically when coroutines are running they act as a black box with no way to access whether they have finished or not. This property allows you to determine if the containing variable is handling any coroutines. Multiple coroutines running at the same time will still return <see langword="true"/>, and there is no way to determine the amount of coroutines running at once.
            </remarks>
            <example>
            The following example illustrates using an <see cref="T:KeepCoding.Routine"/> and an <see cref="T:System.Collections.IEnumerator"/> to run separately despite being called at the same time.
            <code>using System.Collections;
            using KeepCoding;
            using UnityEngine;
            
            public sealed class FooModule : ModuleScript
            {
                private void Start()
                {
                    Routine routine = new Routine(First(), this);
                    
                    routine.Start();
                    
                    StartCoroutine(Second(routine));
                }
                
                private IEnumerator First()
                {
                    foreach (string log in new[] { "First1", "First2", "First3" }
                    {
                        Log(log);
                        yield return new WaitForSeconds(1);
                    }
                }
                
                private IEnumerator Second(Routine routine)
                {
                    yield return new WaitWhile(() => routine.IsRunning);
                    Log("Second");
                }
            }
            </code>
            This is the output from the console.
            <code>[Foo #1] First1
            [Foo #1] First2
            [Foo #1] First3
            [Foo #1] Second</code>
            </example>
            <seealso cref="T:KeepCoding.Routine"/>
        </member>
        <member name="P:KeepCoding.Internal.RoutineBase.Count">
            <summary>
            The amount of coroutines stored.
            </summary>
            <value>
            The <see cref="T:System.Int32"/> representing the length of <see cref="P:KeepCoding.Internal.RoutineBase.Coroutines"/>.
            </value>
            <remarks>
            Given that <see cref="T:KeepCoding.Internal.RoutineBase"/> acts as a wrapper for handling mulitple coroutines, all of which stored in a <see cref="T:System.Collections.Generic.List`1"/>, this acts as shorthand for accessing the <see cref="P:System.Collections.Generic.List`1.Count"/> from <see cref="P:KeepCoding.Internal.RoutineBase.Coroutines"/>. <see cref="P:KeepCoding.Internal.RoutineBase.Coroutines"/> will never be <see langword="null"/> which means <see cref="P:KeepCoding.Internal.RoutineBase.Count"/> never throws an exception. Note that this does not store the amount of coroutines running, as finished coroutines will still be kept inside the <see cref="T:System.Collections.Generic.List`1"/> <see cref="P:KeepCoding.Internal.RoutineBase.Coroutines"/>. When <see cref="M:KeepCoding.Internal.RoutineBase.Stop"/> or <see cref="M:KeepCoding.Internal.RoutineBase.StopAll"/> is called however, the coroutines to get removed from the <see cref="P:KeepCoding.Internal.RoutineBase.Coroutines"/> which will change the count and therefore this getter.
            </remarks>
            <example>
            The following example illustrates a method that uses <see cref="M:KeepCoding.Internal.RoutineBase.Stop"/> to remove one entry from <see cref="P:KeepCoding.Internal.RoutineBase.Coroutines"/> and returns the size of the collection using <see cref="P:KeepCoding.Internal.RoutineBase.Count"/>.
            <code>using KeepCoding.Internal;
            
            public static class CoroutineHelper
            {
                public static int StopAndCount(RoutineBase routine)
                {
                    routine.Stop();
                    
                    return routine.Count;
                }
            }
            </code>
            This will now be called using <see cref="T:KeepCoding.Routine"/>.
            <code>using KeepCoding;
            using System.Collections;
            using UnityEngine;
            
            public sealed class FooModule : ModuleScript
            {
                private void Start()
                {
                    Routine routine = new Routine(Example(), this);
                    
                    // This increases the count to 1 because a coroutine gets appended.
                    routine.Start();
                    
                    Log(routine.Count);
                    
                    // This will stop which removes 1 and return the new length which is 0.
                    Log(CoroutineHelper.StopAndCount(routine));
                }
                
                private IEnumerator Example()
                {
                    yield return null;
                }
            }
            </code>
            This is the output from the console.
            <code>[Foo #1] 1
            [Foo #1] 0
            </code>
            </example>
            <seealso cref="P:KeepCoding.Internal.RoutineBase.Coroutines"/>
            <seealso cref="T:KeepCoding.Routine"/>
            <seealso cref="M:KeepCoding.Internal.RoutineBase.Stop"/>
            <seealso cref="M:KeepCoding.Internal.RoutineBase.StopAll"/>
        </member>
        <member name="P:KeepCoding.Internal.RoutineBase.Coroutines">
            <summary>
            The collection of all coroutines.
            </summary>
            <value>
            The <see cref="T:System.Collections.Generic.List`1"/> which contains all of the stored coroutines.
            </value>
            <remarks>
            <see cref="T:KeepCoding.Internal.RoutineBase"/> can store multiple coroutines in order to be able to handle multiple coroutines. This <see cref="T:System.Collections.Generic.List`1"/> starts out empty and will never be <see langword="null"/>.
            </remarks>
            <example>
            The following example illustrates how <see cref="P:KeepCoding.Internal.RoutineBase.Coroutines"/> starts out as empty. A helper method will be first created to check for an empty list.
            <code>using System.Collections;
            using KeepCoding.Internal;
            
            public static class Helper
            {
                public static bool IsEmpty(this T list) where T : IList
                {
                    if (list == null)
                        throw new NullIteratorException("list");
                        
                    return list.Count == 0;
                }
            }
            </code>
            Now a <see langword="class"/> which implements <see cref="T:KeepCoding.Internal.RoutineBase"/> such as <see cref="T:KeepCoding.Routine"/> can demonstrate this effect.
            <code>using System.Collections;
            using KeepCoding;
            using UnityEngine;
            
            public sealed class FooModule : ModuleScript
            {
                private void Start()
                {
                    // This grabs the list of coroutines right after the constructor is finished, and abanndons the rest of the routine type.
                    List&lt;Coroutine&gt; coroutines = new Routine(Example(), this).Coroutines;
            
                    // Due to the fact that nothing was done with the routine, this would return true.
                    Log(coroutines.IsEmpty());
                }
                
                private IEnumerator Example()
                {
                    yield return null;
                }
            }
            </code>
            This is the output from the console.
            <code>[Foo #1] True
            </code>
            </example>
            <seealso cref="T:KeepCoding.Routine"/>
        </member>
        <member name="M:KeepCoding.Internal.RoutineBase.Stop">
            <summary>
            Stops the first coroutine that was called, and removes it from <see cref="P:KeepCoding.Internal.RoutineBase.Coroutines"/>.
            </summary>
            <remarks>
            Every time a coroutine gets added, it does so at the end of the <see cref="T:System.Collections.Generic.List`1"/>. When <see cref="M:KeepCoding.Internal.RoutineBase.Stop"/> is called, the first and therefore oldest coroutine gets removed from this list in a similar vein to <see cref="T:System.Collections.Queue"/>. Note that when the coroutines are finished, they do not get removed from the list. If <see cref="M:KeepCoding.Internal.RoutineBase.Stop"/> is called on a coroutine which has already stopped, the first coroutine will still be attempted to be stopped, which will in that case do nothing, and be removed from the list.
            </remarks>
            <example>
            The following example illustrates running <see cref="M:KeepCoding.Internal.RoutineBase.Stop"/> three times despite only having two coroutines using the <see langword="class"/> <see cref="T:KeepCoding.Routine"/> which inherits from <see cref="T:KeepCoding.Internal.RoutineBase"/>. As <see cref="M:KeepCoding.Internal.RoutineBase.Stop"/> expects at least 1 coroutine, the code will cause an <see cref="T:KeepCoding.Internal.EmptyIteratorException"/>.
            <code>using System.Collections;
            using KeepCoding;
            using UnityEngine;
            
            public sealed class FooModule : ModuleScript
            {
                private void Start()
                {
                    Routine routine = new Routine(Example(), this);
                    
                    // This creates the first coroutine.
                    routine.Start();
                    
                    // This creates the second coroutine.
                    routine.Start();
                    
                    // This stops the first coroutine.
                    routine.Stop();
                    
                    // This stops the second coroutine.
                    routine.Stop();
                    
                    // Uncomment the line below to cause an error because there are no coroutines to remove.
                    // routine.Stop();
                }
                
                private IEnumerator Example()
                {
                    yield return null;
                }
            }
            </code>
            </example>
            <exception cref="T:KeepCoding.Internal.EmptyIteratorException"><see cref="P:KeepCoding.Internal.RoutineBase.Coroutines"/> is empty.</exception>
            <seealso cref="P:KeepCoding.Internal.RoutineBase.Coroutines"/>
            <seealso cref="T:KeepCoding.Routine"/>
        </member>
        <member name="M:KeepCoding.Internal.RoutineBase.StopAll">
            <summary>
            Stops all coroutines that were called, and makes <see cref="P:KeepCoding.Internal.RoutineBase.Coroutines"/> empty.
            </summary>
            <remarks>
            <see cref="M:KeepCoding.Internal.RoutineBase.StopAll"/> stops and removes all coroutines from <see cref="P:KeepCoding.Internal.RoutineBase.Coroutines"/>, as such, it cannot be called twice in a row without throwing an exception or adding a coroutine in-between. Note that when the coroutines are finished, they do not get removed from the list. If <see cref="M:KeepCoding.Internal.RoutineBase.StopAll"/> is called on coroutines which have already stopped, those coroutines will still be attempted to be stopped, which will in that case do nothing, and be removed from the list.
            </remarks>
            <example>
            The following example illustrates running <see cref="M:KeepCoding.Internal.RoutineBase.StopAll"/> twice to demonstrate the error using the <see langword="class"/> <see cref="T:KeepCoding.Routine"/> which inherits from <see cref="T:KeepCoding.Internal.RoutineBase"/>. As <see cref="M:KeepCoding.Internal.RoutineBase.StopAll"/> expects at least 1 coroutine, the code will cause an <see cref="T:KeepCoding.Internal.EmptyIteratorException"/>.
            <code>using System.Collections;
            using KeepCoding;
            using UnityEngine;
            
            public sealed class FooModule : ModuleScript
            {
                private void Start()
                {
                    Routine routine = new Routine(Example(), this);
                    
                    // This creates the first coroutine.
                    routine.Start();
                    
                    // This creates the second coroutine.
                    routine.Start();
                    
                    // This stops the first and second coroutine.
                    routine.StopAll();
                    
                    // Uncomment the line below to cause an error because there are no coroutines to remove.
                    // routine.StopAll();
                }
                
                private IEnumerator Example()
                {
                    yield return null;
                }
            }
            </code>
            </example>
            <exception cref="T:KeepCoding.Internal.EmptyIteratorException"><see cref="P:KeepCoding.Internal.RoutineBase.Coroutines"/> is empty.</exception>
            <seealso cref="P:KeepCoding.Internal.RoutineBase.Coroutines"/>
            <seealso cref="T:KeepCoding.Routine"/>
        </member>
        <member name="M:KeepCoding.Internal.RoutineBase.GetEnumerator">
            <summary>
            Gets the <see cref="T:System.Collections.IEnumerator"/> of the <see cref="T:KeepCoding.Routine"/> from <see cref="P:KeepCoding.Internal.RoutineBase.Coroutines"/>.
            </summary>
            <remarks>
            This retrieves the <see cref="P:KeepCoding.Internal.RoutineBase.Coroutines"/> as an <see cref="T:System.Collections.IEnumerator"/>. Note that <see cref="P:KeepCoding.Internal.RoutineBase.Coroutines"/> is never <see langword="null"/> but is empty by default.
            </remarks>
            <example>
            The following example illustrates how <see cref="P:KeepCoding.Internal.RoutineBase.Coroutines"/> is empty by default by using <see cref="M:KeepCoding.Internal.RoutineBase.GetEnumerator"/> with <see cref="T:KeepCoding.Routine"/> which derives from <see cref="T:KeepCoding.Internal.RoutineBase"/>.
            <code>using System.Collections;
            using KeepCoding;
            using UnityEngine;
            
            public sealed class FooModule : ModuleScript
            {
                private void Start()
                {
                    IEnumerator ienumerator = new Routine(Example(), this).GetEnumerator();
                    
                    while (ienumerator.MoveNext())
                        throw new Exception("This will not happen.");
                        
                    Log("Done!");
                }
                
                private IEnumerator Example()
                {
                    yield return null;
                }
            }
            </code>
            This is the output from the console.
            <code>[Foo #1] Done!
            </code>
            </example>
            <seealso cref="P:KeepCoding.Internal.RoutineBase.Coroutines"/>
            <seealso cref="T:KeepCoding.Routine"/>
            <returns><see cref="P:KeepCoding.Internal.RoutineBase.Coroutines"/> as <see cref="T:System.Collections.IEnumerable"/> using <see cref="M:System.Collections.Generic.List`1.GetEnumerator"/>.</returns>
        </member>
        <member name="T:KeepCoding.Internal.TupleBase">
            <summary>
            Provides the base <see langword="class"/> for the multiple tuple types.
            </summary>
            <remarks>
            <see cref="T:KeepCoding.Internal.TupleBase"/> provides the general functionality that different types of tuples share in common with. As each different type of tuple gives different amounts of generics, this base <see langword="class"/> is therefore non-generic and provides every method that doesn't require it. This can therefore be used as a way of passing in an ambiguous type of tuple.
            </remarks>
            <example>
            The following example illustrates a method for returning the last item of any tuple that uses <see cref="T:KeepCoding.Internal.TupleBase"/>.
            <code>using KeepCoding.Internal;
            
            public static class Extensions
            {
                public static object Last(TupleBase tuple)
                {
                    return tuple[tuple.UpperBound];
                }
            }
            </code>
            This can then used on any kind of tuple. A constructor can be used, but in this example the extension method <see cref="M:KeepCoding.TypeHelper.ToTuple``2(``0,``1)"/> is used instead.
            <code>using KeepCoding;
            
            public sealed class FooModule : ModuleScript
            {
                private void Start()
                {
                    Tuple&lt;int, string&gt; tuple = 0.ToTuple("bar");
                    
                    object o = Extensions.Last(tuple);
                    
                    Log(o);
                }
            }
            </code>
            This is the output from the console.
            <code>[Foo #1] bar
            </code>
            </example>
            <seealso cref="M:KeepCoding.TypeHelper.ToTuple``2(``0,``1)"/>
        </member>
        <member name="P:KeepCoding.Internal.TupleBase.Item(System.Byte)">
            <summary>
            Passes an index into the tuple, where items are considered ordered and part of an array.
            </summary>
            <value>
            <see cref="P:KeepCoding.Internal.TupleBase.ToArray"/> with the index specified.
            </value>
            <remarks>
            A <see cref="T:KeepCoding.Internal.TupleBase"/> will always throw an <see cref="T:System.IndexOutOfRangeException"/> regardless if the getter or setter is called as it contains no items to index into. The purpose of this indexer is to provide all derived classes the same <see cref="T:System.IndexOutOfRangeException"/> message. As there is type ambiguity between multiple generics, the <see langword="return"/> type has to be <see cref="T:System.Object"/> as any value is passed into each item.
            </remarks>
            <example>
            The following example illustrates how an <see cref="T:System.IndexOutOfRangeException"/> will always be thrown no matter what index is passed in.
            <code>using KeepCoding;
            using KeepCoding.Internal;
            
            public sealed class FooModule : ModuleScript
            {
                private void Start()
                {
                    TupleBase tuple = new TupleBase();
                    
                    // This uses the getter.
                    Try(b => Log(tuple[b]);
                    
                    // This uses the setter.
                    Try(b => tuple[b] = 0);
                }
                
                private void Try(Action&lt;byte&gt; act)
                {
                    for (byte b = byte.MinValue; i &lt; byte.MaxValue; i++)
                    {
                        try
                        {
                            act(b);
                            
                            throw new ArgumentException("This exception will never be thrown because the above operation will always fail!");
                        }
                        catch (IndexOutOfRangeException)
                        {
                            continue;
                        }
                    }
                }
            }
            </code>
            </example>
            <seealso cref="P:KeepCoding.Internal.TupleBase.ToArray"/>
            <param name="index">The index to pass into <see cref="P:KeepCoding.Internal.TupleBase.ToArray"/>.</param>
            <exception cref="T:System.IndexOutOfRangeException">The parameter <paramref name="index"/> is out of range because there are no items in this tuple type.</exception>
            <returns><see cref="T:System.IndexOutOfRangeException"/>, ignoring <paramref name="index"/>.</returns>
        </member>
        <member name="P:KeepCoding.Internal.TupleBase.Length">
            <summary>
            Determines the amount of items in the tuple type.
            </summary>
            <value>
            The number of generics in the current type.
            </value>
            <remarks>
            The length is the amount of items in the tuple, which can be used to index <see cref="P:KeepCoding.Internal.TupleBase.ToArray"/> or the indexer <see cref="P:KeepCoding.Internal.TupleBase.Item(System.Byte)"/>.
            </remarks>
            <example>
            The following example illustrates how a method can use the <see cref="P:KeepCoding.Internal.TupleBase.Length"/> parameter as a way of determining the tuple item count being odd. <see cref="M:KeepCoding.ArrayHelper.ConvertAll``2(``0[],System.Converter{``0,``1})"/> is used to convert all tuples to <see cref="T:System.Boolean"/>.
            <code>using KeepCoding;
            using KeepCoding.Internal;
            
            public static class Extensions
            {
                public static bool[] IsOdds(params[] TupleBase tuples)
                {
                    return tuples.ConvertAll(t => t.Length % 2 == 1);
                }
            }
            </code>
            Next is five variables of all different lengths are now being tested.
            <code>using KeepCoding;
            
            public sealed class FooModule : ModuleScript
            {
                private void Start()
                {
                    Log(Extensions.IsOdds(0.ToTuple(), // 1 item
                        0.ToTuple(0), // 2 items
                        0.ToTuple(0, 0), // 3 items
                        0.ToTuple(0, 0, 0))); // 4 items
                }
            }
            </code>
            This is the output from the console.
            <code>[Foo #1] False, True, False, True, False
            </code>
            </example>
            <seealso cref="P:KeepCoding.Internal.TupleBase.Item(System.Byte)"/>
            <seealso cref="P:KeepCoding.Internal.TupleBase.ToArray"/>
            <seealso cref="M:KeepCoding.ArrayHelper.ConvertAll``2(``0[],System.Converter{``0,``1})"/>
        </member>
        <member name="P:KeepCoding.Internal.TupleBase.UpperBound">
            <summary>
            Determines the upperbound of the amount of the length.
            </summary>
            <value>
            <see cref="P:KeepCoding.Internal.TupleBase.Length"/> - 1.
            </value>
            <remarks>
            This can be used for indexing <see cref="P:KeepCoding.Internal.TupleBase.ToArray"/> or the indexer <see cref="P:KeepCoding.Internal.TupleBase.Item(System.Byte)"/>, getting the last item of the tuple. Calling <see cref="P:KeepCoding.Internal.TupleBase.UpperBound"/> assumes that there is at least 1 generic in this type.
            </remarks>
            <example>
            The following example illusrates a method that retrieves the last item of the tuple.
            <code>using KeepCoding.Internal;
            
            public static class Extensions
            {
                public static object Last(TupleBase tuple)
                {
                    return tuple[tuple.UpperBound];
                }
            }
            </code>
            Now the method will be tested.
            <code>using KeepCoding;
            
            public sealed class FooModule : ModuleScript
            {
                private void Start()
                {
                    Log(Extensions.Last(0.ToTuple()));
                    Log(Extensions.Last(1.ToTuple(2)));
                    Log(Extensions.Last(3.ToTuple(4, 5)));
                    Log(Extensions.Last(6.ToTuple(7, 8, 9)));
                }
            }
            </code>
            This is the output from the console.
            <code>[Foo #1] 0
            [Foo #1] 2
            [Foo #1] 5
            [Foo #1] 9
            </code>
            </example>
            <exception cref="T:System.InvalidOperationException">The length is 0, and therefore the upper bound doesn't exist.</exception>
            <seealso cref="P:KeepCoding.Internal.TupleBase.Item(System.Byte)"/>
            <seealso cref="P:KeepCoding.Internal.TupleBase.Length"/>
            <seealso cref="P:KeepCoding.Internal.TupleBase.ToArray"/>
        </member>
        <member name="P:KeepCoding.Internal.TupleBase.ToArray">
            <summary>
            Converts all items to an array.
            </summary>
            <value>
            All items.
            </value>
            <remarks>
            As the types are not determined, they have to be boxed in <see cref="T:System.Object"/>.
            </remarks>
            <example>
            The following example illustrates how an entire tuple can be printed using <see cref="P:KeepCoding.Internal.TupleBase.ToArray"/>, since <see cref="M:KeepCoding.Logger.Log``1(``0,System.Object[])"/> can print arrays.
            <code>using KeepCoding;
            
            public sealed class FooModule : ModuleScript
            {
                private void Start()
                {
                    Log(4.ToTuple(3, 2, 1).ToArray);
                }
            }
            </code>
            This is the output from the console.
            <code>[Foo #1] 4, 3, 2, 1
            </code>
            </example>
            <seealso cref="M:KeepCoding.Logger.Log``1(``0,System.Object[])"/>
        </member>
        <member name="M:KeepCoding.Internal.TupleBase.op_Equality(KeepCoding.Internal.TupleBase,KeepCoding.Internal.TupleBase)">
            <summary>
            Overrides comparison by checking for individual item equality rather than itself.
            </summary>
            <remarks>
            For more details about comparison, look at <see cref="M:KeepCoding.Internal.TupleBase.Equals(KeepCoding.Internal.TupleBase)"/>.
            </remarks>
            <param name="left">The left-hand side <see cref="T:KeepCoding.Internal.TupleBase"/> comparison to compare to.</param>
            <param name="right">The right-hand side <see cref="T:KeepCoding.Internal.TupleBase"/> comparison to compare to.</param>
            <returns><see langword="true"/> if all items in the tuple equal the other items of the same index.</returns>
        </member>
        <member name="M:KeepCoding.Internal.TupleBase.op_Inequality(KeepCoding.Internal.TupleBase,KeepCoding.Internal.TupleBase)">
            <summary>
            Overrides comparison by checking for individual item equality rather than itself.
            </summary>
            <remarks>
            For more details about comparison, look at <see cref="M:KeepCoding.Internal.TupleBase.Equals(KeepCoding.Internal.TupleBase)"/>.
            </remarks>
            <param name="left">The left-hand side <see cref="T:KeepCoding.Internal.TupleBase"/> comparison to compare to.</param>
            <param name="right">The right-hand side <see cref="T:KeepCoding.Internal.TupleBase"/> comparison to compare to.</param>
            <returns><see langword="true"/> if any item in the tuple does not equal the other item of the same index.</returns>
        </member>
        <member name="M:KeepCoding.Internal.TupleBase.Equals(System.Object)">
            <summary>
            Compares itself and another object attempted to casted as <see cref="T:KeepCoding.Internal.TupleBase"/> to determine if they contain the same values.
            </summary>
            <remarks>
            For more details about comparison, look at <see cref="M:KeepCoding.Internal.TupleBase.Equals(KeepCoding.Internal.TupleBase)"/>.
            </remarks>
            <param name="obj">The <see cref="T:System.Object"/> to compare to.</param>
            <returns><see langword="true"/> if all items in the tuple equal the other items of the same index.</returns>
        </member>
        <member name="M:KeepCoding.Internal.TupleBase.Equals(KeepCoding.Internal.TupleBase)">
            <summary>
            Compares itself and another <see cref="T:KeepCoding.Internal.TupleBase"/> to determine if they contain the same values.
            </summary>
            <remarks>
            The comparison is done by taking both of their <see cref="P:KeepCoding.Internal.TupleBase.ToArray"/> values and comparing them with <see cref="M:System.Linq.Enumerable.SequenceEqual``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})"/>. Note that if the tuples are different sizes, this will automatically return <see langword="true"/>. For more information, <see cref="M:System.Object.Equals(System.Object)"/>.
            </remarks>
            <example>
            The following example illustrates the different ways this method can return true or false.
            <code>using KeepCoding;
            
            public sealed class FooModule : ModuleScript
            {
                private void Start()
                {
                    Tuple&lt;int&gt; first = 2.ToTuple(),
                        second = first,
                        third = 2.ToTuple(),
                        fourth = 4.ToTuple();
                        
                    Tuple&lt;int, int&gt; fifth = 2.ToTuple(2);
                    
                    Log(first.Equals(second));
                    Log(first.Equals(third));
                    Log(first.Equals(fourth));
                    Log(first.Equals(fifth));
                }
            }
            </code>
            This is the output from the console.
            <code>[Foo #1] True
            [Foo #1] True
            [Foo #1] False
            [Foo #1] False
            </code>
            </example>
            <param name="other">The <see cref="T:KeepCoding.Internal.TupleBase"/> to compare itself to.</param>
            <returns><see langword="true"/> if both of them have the same items, or are both <see langword="null"/>.</returns>
        </member>
        <member name="M:KeepCoding.Internal.TupleBase.GetHashCode">
            <summary>
            Gets the hash code of <see cref="P:KeepCoding.Internal.TupleBase.ToArray"/>.
            </summary>
            <remarks>
            Hash codes are a way of quickly asserting equality. It converts all of the given relevant variables into hash codes and combines into a number that makes it unlikely for two different types to have the same hash code. That being said, it is still possible for the hash codes to be identical but not for the same values to have different hash codes, which is why it only should be used as the first step in determining equality and confirming by making the final comparisons to those with equal hash codes. For more information, see <see cref="M:System.Object.GetHashCode"/>.
            </remarks>
            <example>
            The following example illustrates how two of the same values will result in the same hash code.
            <code>using KeepCoding;
            
            public sealed class FooModule : ModuleScript
            {
                private void Start()
                {
                    Tuple&lt;int&gt; first = 2.ToTuple(),
                        second = 2.ToTuple();
                        
                    Log(first.GetHashCode() == second.GetHashCode());
                }
            }
            </code>
            This is the output from the console.
            <code>[Foo #1] True
            </code>
            </example>
            <seealso cref="P:KeepCoding.Internal.TupleBase.ToArray"/>
            <returns>The hash code of this instance.</returns>
        </member>
        <member name="M:KeepCoding.Internal.TupleBase.ToString">
             <summary>
             Joins <see cref="P:KeepCoding.Internal.TupleBase.ToArray"/> to a string, with a space as a delimiter.
             </summary>
             <remarks>
             Each element of <see cref="P:KeepCoding.Internal.TupleBase.ToArray"/> is passed into <see cref="M:KeepCoding.Helper.UnwrapToString``1(``0,System.Boolean,System.String)"/> to unpack iterators and allow each element to be seen. For more details about stringification, refer to <see cref="M:System.Object.ToString"/>.
             </remarks>
             <example>
             The following example illustrates how a tuple gets converted to a <see cref="T:System.String"/>.
             <code>using KeepCoding;
            
             public sealed class FooModule : ModuleScript
             {
                 private void Start()
                 {
                     Tuple&lt;int, string[], bool&gt; tuple = 0.ToTuple(new[] { "test1", "test2", "test3" }, false);
                         
                     Log(first.ToString());
                 }
             }
             </code>
             This is the output from the console.
             <code>[Foo #1] 0, test1, test2, test3, False
             </code>
             </example>
             <seealso cref="P:KeepCoding.Internal.TupleBase.ToArray"/>
             <seealso cref="M:KeepCoding.Helper.UnwrapToString``1(``0,System.Boolean,System.String)"/>
             <returns><see cref="P:KeepCoding.Internal.TupleBase.ToArray"/> from <see cref="M:KeepCoding.Helper.UnwrapToString``1(``0,System.Boolean,System.String)"/>.</returns>
        </member>
        <member name="M:KeepCoding.Internal.TupleBase.GetEnumerator">
             <summary>
             Gets the <see cref="T:System.Collections.IEnumerator"/> of <see cref="P:KeepCoding.Internal.TupleBase.ToArray"/>.
             </summary>
             <remarks>
             This method is needed to implement <see cref="T:System.Collections.IEnumerator"/> interface. It takes <see cref="P:KeepCoding.Internal.TupleBase.ToArray"/> and performs <see cref="M:System.Array.GetEnumerator"/>.
             </remarks>
             <example>
             The following example illustrates how items in <see cref="P:KeepCoding.Internal.TupleBase.ToArray"/> get converted into an <see cref="T:System.Collections.IEnumerator"/>, and using that <see cref="T:System.Collections.IEnumerator"/> to print every value.
             <code>using System.Collections;
             using KeepCoding;
            
             public sealed class FooModule : ModuleScript
             {
                 private void Start()
                 {
                     Tuple&lt;int, string[], bool&gt; tuple = 0.ToTuple(new[] { "test1", "test2", "test3" }, false);
                         
                     IEnumerator ienumerator = tuple.GetEnumerator();
            
                     while (ienumerator.MoveNext())
                         Log(ienumerator.Current);
                 }
             }
             </code>
             This is the output from the console.
             <code>[Foo #1] 0
             [Foo #1] test1
             [Foo #1] test2
             [Foo #1] test3
             [Foo #1] False
             </code>
             </example>
        </member>
        <member name="T:KeepCoding.Internal.WorkBase">
            <summary>
            Abstract class for the <see cref="T:KeepCoding.Work"/> datatype, since the different overloads are similar to each other.
            </summary>
        </member>
        <member name="P:KeepCoding.Internal.WorkBase.IsRunning">
            <summary>
            Determines whether any thread in this class is running.
            </summary>
        </member>
        <member name="P:KeepCoding.Internal.WorkBase.AllowSimultaneousActive">
            <summary>
            Determines whether it should skip on starting a thread if it doesn't allow multiple.
            </summary>
        </member>
        <member name="P:KeepCoding.Internal.WorkBase.ThreadsActive">
            <summary>
            Counts the number of threads currently active within this class, and all of its overloads.
            </summary>
        </member>
        <member name="P:KeepCoding.Internal.WorkBase.Thread">
            <summary>
            The thread of the class.
            </summary>
        </member>
        <member name="M:KeepCoding.Internal.WorkBase.Stop">
            <summary>
            Interrupts the thread.
            </summary>
        </member>
        <member name="M:KeepCoding.Internal.WorkBase.WaitForOtherThreads">
            <summary>
            Waits until it is allowed to run a thread.
            </summary>
            <returns><see cref="T:UnityEngine.WaitWhile"/> until <see cref="P:KeepCoding.Internal.WorkBase.ThreadsActive"/> is strictly less than <see cref="F:KeepCoding.Internal.WorkBase._maximumThreadsActive"/>.</returns>
        </member>
        <member name="M:KeepCoding.Internal.WorkBase.WaitForOwnThread">
            <summary>
            Waits until its own thread is no longer running..
            </summary>
            <returns><see cref="T:UnityEngine.WaitWhile"/> until <see cref="P:KeepCoding.Internal.WorkBase.IsRunning"/> is no longer true.</returns>
        </member>
        <member name="T:KeepCoding.Internal.ModuleScriptEditor">
            <summary>
            Custom inspector for <see cref="T:KeepCoding.ModuleScript"/>. 
            </summary>
        </member>
        <member name="M:KeepCoding.Internal.ModuleScriptEditor.OnInspectorGUI">
            <summary>
            Creates the colorblind button.
            </summary>
        </member>
        <member name="T:KeepCoding.Internal.TPScriptEditor">
            <summary>
            Custom inspector for <see cref="T:KeepCoding.TPScript`1"/>. 
            </summary>
        </member>
        <member name="M:KeepCoding.Internal.TPScriptEditor.OnInspectorGUI">
            <summary>
            Creates the force solve buttons.
            </summary>
        </member>
        <member name="T:KeepCoding.Internal.ConstructorArgumentException">
            <summary>
            An exception thrown when the constructor throws an exception due to a bad argument.
            </summary>
        </member>
        <member name="M:KeepCoding.Internal.ConstructorArgumentException.#ctor">
            <summary>
            An exception thrown when the constructor throws an exception due to a bad argument.
            </summary>
        </member>
        <member name="M:KeepCoding.Internal.ConstructorArgumentException.#ctor(System.String)">
            <summary>
            An exception thrown when the constructor throws an exception due to a bad argument.
            </summary>
            <param name="message">The message of the exception.</param>
        </member>
        <member name="M:KeepCoding.Internal.ConstructorArgumentException.#ctor(System.String,System.Exception)">
            <summary>
            An exception thrown when the constructor throws an exception due to a bad argument.
            </summary>
            <param name="message">The message of the exception.</param>
            <param name="innerException">An <see cref="T:System.Exception"/> within this exception.</param>
        </member>
        <member name="T:KeepCoding.Internal.EmptyIteratorException">
            <summary>
            An exception thrown when the iterator is empty.
            </summary>
        </member>
        <member name="M:KeepCoding.Internal.EmptyIteratorException.#ctor">
            <summary>
            An exception thrown when the iterator is empty.
            </summary>
        </member>
        <member name="M:KeepCoding.Internal.EmptyIteratorException.#ctor(System.String)">
            <summary>
            An exception thrown when the iterator is empty.
            </summary>
            <param name="message">The message of the exception.</param>
        </member>
        <member name="M:KeepCoding.Internal.EmptyIteratorException.#ctor(System.String,System.Exception)">
            <summary>
            An exception thrown when the iterator is empty.
            </summary>
            <param name="message">The message of the exception.</param>
            <param name="innerException">An <see cref="T:System.Exception"/> within this exception.</param>
        </member>
        <member name="T:KeepCoding.Internal.NegativeNumberException">
            <summary>
            An exception thrown when the number is unexpectedly negative.
            </summary>
        </member>
        <member name="M:KeepCoding.Internal.NegativeNumberException.#ctor">
            <summary>
            An exception thrown when the number is unexpectedly negative.
            </summary>
        </member>
        <member name="M:KeepCoding.Internal.NegativeNumberException.#ctor(System.String)">
            <summary>
            An exception thrown when the number is unexpectedly negative.
            </summary>
            <param name="message">The message of the exception.</param>
        </member>
        <member name="M:KeepCoding.Internal.NegativeNumberException.#ctor(System.String,System.Exception)">
            <summary>
            An exception thrown when the number is unexpectedly negative.
            </summary>
            <param name="message">The message of the exception.</param>
            <param name="innerException">An <see cref="T:System.Exception"/> within this exception.</param>
        </member>
        <member name="T:KeepCoding.Internal.NullIteratorException">
            <summary>
            An exception thrown when the iterator is null.
            </summary>
        </member>
        <member name="M:KeepCoding.Internal.NullIteratorException.#ctor">
            <summary>
            An exception thrown when the iterator is null.
            </summary>
        </member>
        <member name="M:KeepCoding.Internal.NullIteratorException.#ctor(System.String)">
            <summary>
            An exception thrown when the iterator is null.
            </summary>
            <param name="message">The message of the exception.</param>
        </member>
        <member name="M:KeepCoding.Internal.NullIteratorException.#ctor(System.String,System.Exception)">
            <summary>
            An exception thrown when the iterator is null.
            </summary>
            <param name="message">The message of the exception.</param>
            <param name="innerException">An <see cref="T:System.Exception"/> within this exception.</param>
        </member>
        <member name="T:KeepCoding.Internal.UnrecognizedTypeException">
            <summary>
            An exception thrown for when the type isn't handled.
            </summary>
        </member>
        <member name="M:KeepCoding.Internal.UnrecognizedTypeException.#ctor">
            <summary>
            An exception thrown for when the type isn't handled.
            </summary>
        </member>
        <member name="M:KeepCoding.Internal.UnrecognizedTypeException.#ctor(System.String)">
            <summary>
            An exception thrown for when the type isn't handled.
            </summary>
            <param name="message">The message of the exception.</param>
        </member>
        <member name="M:KeepCoding.Internal.UnrecognizedTypeException.#ctor(System.String,System.Exception)">
            <summary>
            An exception thrown for when the type isn't handled.
            </summary>
            <param name="message">The message of the exception.</param>
            <param name="innerException">An <see cref="T:System.Exception"/> within this exception.</param>
        </member>
        <member name="T:KeepCoding.Internal.UnrecognizedValueException">
            <summary>
            An exception thrown for when the value isn't handled.
            </summary>
        </member>
        <member name="M:KeepCoding.Internal.UnrecognizedValueException.#ctor">
            <summary>
            An exception thrown for when the type isn't handled.
            </summary>
        </member>
        <member name="M:KeepCoding.Internal.UnrecognizedValueException.#ctor(System.String)">
            <summary>
            An exception thrown for when the value isn't handled.
            </summary>
            <param name="message">The message of the exception.</param>
        </member>
        <member name="M:KeepCoding.Internal.UnrecognizedValueException.#ctor(System.String,System.Exception)">
            <summary>
            An exception thrown for when the value isn't handled.
            </summary>
            <param name="message">The message of the exception.</param>
            <param name="innerException">An <see cref="T:System.Exception"/> within this exception.</param>
        </member>
        <member name="T:KeepCoding.Internal.ReflectionScript">
            <summary>
            Editor-only behaviour that gets values from <see cref="T:UnityEngine.Component"/>s in real-time.
            </summary>
        </member>
        <member name="M:KeepCoding.Internal.ReflectionScript.Log``1(``0,UnityEngine.LogType)">
            <summary>
            Logs message, but formats it to be compliant with the Logfile Analyzer.
            </summary>
            <exception cref="T:KeepCoding.Internal.UnrecognizedValueException"></exception>
            <param name="message">The message to log.</param>
            <param name="logType">The type of logging. Different logging types have different icons within the editor.</param>
        </member>
        <member name="M:KeepCoding.Internal.ReflectionScript.Log``1(``0,System.Object[])">
            <summary>
            Logs multiple entries, but formats it to be compliant with the Logfile Analyzer.
            </summary>
            <exception cref="T:KeepCoding.Internal.UnrecognizedValueException"></exception>
            <param name="message">The message to log.</param>
            <param name="args">All of the arguments to embed into <paramref name="message"/>.</param>
        </member>
        <member name="M:KeepCoding.Internal.ReflectionScript.LogMultiple(System.String[])">
            <summary>
            Logs multiple entries to the console.
            </summary>
            <param name="logs">The array of logs to individual output into the console.</param>
        </member>
        <member name="T:KeepCoding.ArrayHelper">
            <summary>
            Extension methods surrounding <see cref="T:System.Array"/> static methods to make code a bit shorter.
            </summary>
        </member>
        <member name="M:KeepCoding.ArrayHelper.AsReadOnly``1(``0[])">
            <summary>
            Returns a read-only wrapper for the specified array.
            </summary>
            <remarks><seealso href="https://docs.microsoft.com/en-us/dotnet/api/system.array.asreadonly?view=net-5.0"/></remarks>
            <exception cref="T:System.ArgumentNullException"></exception>
            <typeparam name="T">The type of the elements of the array.</typeparam>
            <param name="array">The one-dimensional, zero-based array to wrap in a read-only <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1"/> wrapper.</param>
            <returns>A read-only <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1"/> wrapper for the specified array.</returns>
        </member>
        <member name="M:KeepCoding.ArrayHelper.BinarySearch(System.Array,System.Object)">
            <summary>
            Searches an entire one-dimensional sorted array for a specific element, using the <see cref="T:System.IComparable"/> interface implemented by each element of the array and by the specified object.
            </summary>
            <remarks><seealso href="https://docs.microsoft.com/en-us/dotnet/api/system.array.binarysearch?view=net-5.0#System_Array_BinarySearch_System_Array_System_Object_"/></remarks>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:System.RankException"></exception>
            <exception cref="T:System.ArgumentException"></exception>
            <exception cref="T:System.InvalidOperationException"></exception>
            <param name="array">The sorted one-dimensional Array to search.</param>
            <param name="value">The object to search for.</param>
            <returns>The index of the specified <paramref name="value"/> in the specified <paramref name="array"/>, if <paramref name="value"/> is found; otherwise, a negative number. If <paramref name="value"/> is not found and <paramref name="value"/> is less than one or more elements in <paramref name="array"/>, the negative number returned is the bitwise complement of the index of the first element that is larger than <paramref name="value"/>. If <paramref name="value"/> is not found and <paramref name="value"/> is greater than all elements in <paramref name="array"/>, the negative number returned is the bitwise complement of (the index of the last element plus 1). If this method is called with a non-sorted <paramref name="array"/>, the return <paramref name="value"/> can be incorrect and a negative number could be returned, even if <paramref name="value"/> is present in <paramref name="array"/>.</returns>
        </member>
        <member name="M:KeepCoding.ArrayHelper.BinarySearch(System.Array,System.Object,System.Collections.IComparer)">
            <summary>
            Searches an entire one-dimensional sorted array for a value using the specified <see cref="T:System.Collections.IComparer"/> interface.
            </summary>
            <remarks><seealso href="https://docs.microsoft.com/en-us/dotnet/api/system.array.binarysearch?view=net-5.0#System_Array_BinarySearch_System_Array_System_Object_System_Collections_IComparer_"/></remarks>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:System.RankException"></exception>
            <exception cref="T:System.ArgumentException"></exception>
            <exception cref="T:System.InvalidOperationException"></exception>
            <param name="array">The sorted one-dimensional <see cref="T:System.Array"/> to search.</param>
            <param name="value">The object to search for.</param>
            <param name="comparer">The <see cref="T:System.Collections.IComparer"/> implementation to use when comparing elements.</param>
            <returns>The index of the specified <paramref name="value"/> in the specified <paramref name="array"/>, if <paramref name="value"/> is found; otherwise, a negative number. If <paramref name="value"/> is not found and <paramref name="value"/> is less than one or more elements in <paramref name="array"/>, the negative number returned is the bitwise complement of the index of the first element that is larger than <paramref name="value"/>. If <paramref name="value"/> is not found and <paramref name="value"/> is greater than all elements in <paramref name="array"/>, the negative number returned is the bitwise complement of (the index of the last element plus 1). If this method is called with a non-sorted <paramref name="array"/>, the return <paramref name="value"/> can be incorrect and a negative number could be returned, even if <paramref name="value"/> is present in <paramref name="array"/>.</returns>
        </member>
        <member name="M:KeepCoding.ArrayHelper.BinarySearch(System.Array,System.Int32,System.Int32,System.Object)">
            <summary>
            Searches a range of elements in a one-dimensional sorted array for a value, using the <see cref="T:System.IComparable"/> interface implemented by each element of the array and by the specified value.
            </summary>
            <remarks><seealso href="https://docs.microsoft.com/en-us/dotnet/api/system.array.binarysearch?view=net-5.0#System_Array_BinarySearch_System_Array_System_Int32_System_Int32_System_Object_"/></remarks>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:System.RankException"></exception>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
            <exception cref="T:System.ArgumentException"></exception>
            <exception cref="T:System.InvalidOperationException"></exception>
            <param name="array">The sorted one-dimensional <see cref="T:System.Array"/> to search.</param>
            <param name="index">The starting index of the range to search.</param>
            <param name="length">The length of the range to search.</param>
            <param name="value">The object to search for.</param>
            <returns>The index of the specified <paramref name="value"/> in the specified <paramref name="array"/>, if <paramref name="value"/> is found; otherwise, a negative number. If <paramref name="value"/> is not found and <paramref name="value"/> is less than one or more elements in <paramref name="array"/>, the negative number returned is the bitwise complement of the index of the first element that is larger than <paramref name="value"/>. If <paramref name="value"/> is not found and <paramref name="value"/> is greater than all elements in <paramref name="array"/>, the negative number returned is the bitwise complement of (the index of the last element plus 1). If this method is called with a non-sorted <paramref name="array"/>, the return <paramref name="value"/> can be incorrect and a negative number could be returned, even if <paramref name="value"/> is present in <paramref name="array"/>.</returns>
        </member>
        <member name="M:KeepCoding.ArrayHelper.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
            <summary>
            Searches a range of elements in a one-dimensional sorted array for a value, using the specified <see cref="T:System.Collections.IComparer"/> interface.
            </summary>
            <remarks><seealso href="https://docs.microsoft.com/en-us/dotnet/api/system.array.binarysearch?view=net-5.0#System_Array_BinarySearch_System_Array_System_Int32_System_Int32_System_Object_System_Collections_IComparer_"/></remarks>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:System.RankException"></exception>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
            <exception cref="T:System.ArgumentException"></exception>
            <exception cref="T:System.InvalidOperationException"></exception>
            <param name="array">The sorted one-dimensional <see cref="T:System.Array"/> to search.</param>
            <param name="index">The starting index of the range to search.</param>
            <param name="length">The length of the range to search.</param>
            <param name="value">The object to search for.</param>
            <param name="comparer">The <see cref="T:System.Collections.IComparer"/> implementation to use when comparing elements or <c>null</c> to use the <see cref="T:System.IComparable"/> implementation of each element..</param>
            <returns>The index of the specified <paramref name="value"/> in the specified <paramref name="array"/>, if <paramref name="value"/> is found; otherwise, a negative number. If <paramref name="value"/> is not found and <paramref name="value"/> is less than one or more elements in <paramref name="array"/>, the negative number returned is the bitwise complement of the index of the first element that is larger than <paramref name="value"/>. If <paramref name="value"/> is not found and <paramref name="value"/> is greater than all elements in <paramref name="array"/>, the negative number returned is the bitwise complement of (the index of the last element plus 1). If this method is called with a non-sorted <paramref name="array"/>, the return <paramref name="value"/> can be incorrect and a negative number could be returned, even if <paramref name="value"/> is present in <paramref name="array"/>.</returns>
        </member>
        <member name="M:KeepCoding.ArrayHelper.BinarySearch``1(``0[],``0)">
            <summary>
            Searches an entire one-dimensional sorted array for a specific element, using the <see cref="T:System.IComparable`1"/> generic interface implemented by each element of the <see cref="T:System.Array"/> and by the specified object.
            </summary>
            <remarks><seealso href="https://docs.microsoft.com/en-us/dotnet/api/system.array.binarysearch?view=net-5.0#System_Array_BinarySearch__1___0_____0_"/></remarks>
            <typeparam name="T">The type of the elements of the array.</typeparam>
            <param name="array">The sorted one-dimensional, zero-based <see cref="T:System.Array"/> to search.</param>
            <param name="value">The object to search for.</param>
            <returns>The index of the specified <paramref name="value"/> in the specified <paramref name="array"/>, if <paramref name="value"/> is found; otherwise, a negative number. If <paramref name="value"/> is not found and <paramref name="value"/> is less than one or more elements in <paramref name="array"/>, the negative number returned is the bitwise complement of the index of the first element that is larger than <paramref name="value"/>. If <paramref name="value"/> is not found and <paramref name="value"/> is greater than all elements in <paramref name="array"/>, the negative number returned is the bitwise complement of (the index of the last element plus 1). If this method is called with a non-sorted <paramref name="array"/>, the return <paramref name="value"/> can be incorrect and a negative number could be returned, even if <paramref name="value"/> is present in <paramref name="array"/>.</returns>
        </member>
        <member name="M:KeepCoding.ArrayHelper.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
            <summary>
            Searches an entire one-dimensional sorted array for a value using the specified <see cref="T:System.Collections.Generic.IComparer`1"/> generic interface.
            </summary>
            <remarks><seealso href="https://docs.microsoft.com/en-us/dotnet/api/system.array.binarysearch?view=net-5.0#System_Array_BinarySearch__1___0_____0_System_Collections_Generic_IComparer___0__"/></remarks>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:System.ArgumentException"></exception>
            <exception cref="T:System.InvalidOperationException"></exception>
            <typeparam name="T">The type of the elements of the array.</typeparam>
            <param name="array">The sorted one-dimensional, zero-based <see cref="T:System.Array"/> to search.</param>
            <param name="value">The object to search for.</param>
            <param name="comparer">The <see cref="T:System.Collections.Generic.IComparer`1"/> implementation to use when comparing elements or <c>null</c> to use the <see cref="T:System.IComparable`1"/> implementation of each element.</param>
            <returns>The index of the specified <paramref name="value"/> in the specified <paramref name="array"/>, if <paramref name="value"/> is found; otherwise, a negative number. If <paramref name="value"/> is not found and <paramref name="value"/> is less than one or more elements in <paramref name="array"/>, the negative number returned is the bitwise complement of the index of the first element that is larger than <paramref name="value"/>. If <paramref name="value"/> is not found and <paramref name="value"/> is greater than all elements in <paramref name="array"/>, the negative number returned is the bitwise complement of (the index of the last element plus 1). If this method is called with a non-sorted <paramref name="array"/>, the return <paramref name="value"/> can be incorrect and a negative number could be returned, even if <paramref name="value"/> is present in <paramref name="array"/>.</returns>
        </member>
        <member name="M:KeepCoding.ArrayHelper.BinarySearch``1(``0[],System.Int32,System.Int32,``0)">
            <summary>
            Searches a range of elements in a one-dimensional sorted array for a value, using the <see cref="T:System.IComparable`1"/> generic interface implemented by each element of the <see cref="T:System.Array"/> and by the specified value.
            </summary>
            <remarks><seealso href="https://docs.microsoft.com/en-us/dotnet/api/system.array.binarysearch?view=net-5.0#System_Array_BinarySearch__1___0___System_Int32_System_Int32___0_"/></remarks>
            <typeparam name="T">The type of the elements of the array.</typeparam>
            <param name="array">The sorted one-dimensional, zero-based <see cref="T:System.Array"/> to search.</param>
            <param name="index">The starting index of the range to search.</param>
            <param name="length">The length of the range to search.</param>
            <param name="value">The object to search for.</param>
            <returns>The index of the specified <paramref name="value"/> in the specified <paramref name="array"/>, if <paramref name="value"/> is found; otherwise, a negative number. If <paramref name="value"/> is not found and <paramref name="value"/> is less than one or more elements in <paramref name="array"/>, the negative number returned is the bitwise complement of the index of the first element that is larger than <paramref name="value"/>. If <paramref name="value"/> is not found and <paramref name="value"/> is greater than all elements in <paramref name="array"/>, the negative number returned is the bitwise complement of (the index of the last element plus 1). If this method is called with a non-sorted <paramref name="array"/>, the return <paramref name="value"/> can be incorrect and a negative number could be returned, even if <paramref name="value"/> is present in <paramref name="array"/>.</returns>
        </member>
        <member name="M:KeepCoding.ArrayHelper.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})">
            <summary>
            Searches a range of elements in a one-dimensional sorted array for a value, using the specified <see cref="T:System.Collections.Generic.IComparer`1"/> generic interface.
            </summary>
            <remarks><seealso href="https://docs.microsoft.com/en-us/dotnet/api/system.array.binarysearch?view=net-5.0#System_Array_BinarySearch__1___0___System_Int32_System_Int32___0_System_Collections_Generic_IComparer___0__"/></remarks>
            <exception cref="T:System.ArgumentException"></exception>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
            <exception cref="T:System.ArgumentException"></exception>
            <exception cref="T:System.InvalidOperationException"></exception>
            <typeparam name="T">The type of the elements of the array.</typeparam>
            <param name="array">The sorted one-dimensional, zero-based <see cref="T:System.Array"/> to search.</param>
            <param name="index">The starting index of the range to search.</param>
            <param name="length">The length of the range to search.</param>
            <param name="value">The object to search for.</param>
            <param name="comparer">The <see cref="T:System.Collections.Generic.IComparer`1"/> implementation to use when comparing elements or <c>null</c> to use the <see cref="T:System.IComparable`1"/> implementation of each element.</param>
            <returns>The index of the specified <paramref name="value"/> in the specified <paramref name="array"/>, if <paramref name="value"/> is found; otherwise, a negative number. If <paramref name="value"/> is not found and <paramref name="value"/> is less than one or more elements in <paramref name="array"/>, the negative number returned is the bitwise complement of the index of the first element that is larger than <paramref name="value"/>. If <paramref name="value"/> is not found and <paramref name="value"/> is greater than all elements in <paramref name="array"/>, the negative number returned is the bitwise complement of (the index of the last element plus 1). If this method is called with a non-sorted <paramref name="array"/>, the return <paramref name="value"/> can be incorrect and a negative number could be returned, even if <paramref name="value"/> is present in <paramref name="array"/>.</returns>
        </member>
        <member name="M:KeepCoding.ArrayHelper.Clear(System.Array,System.Int32,System.Int32)">
            <summary>
            Sets a range of elements in an array to the default value of each element type.
            </summary>
            <remarks><seealso href="https://docs.microsoft.com/en-us/dotnet/api/system.array.clear?view=net-5.0"/></remarks>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:System.IndexOutOfRangeException"></exception>
            <param name="array">The array whose elements need to be cleared.</param>
            <param name="index">The starting index of the range of elements to clear.</param>
            <param name="length">The number of elements to clear.</param>
            <returns><paramref name="array"/></returns>
        </member>
        <member name="M:KeepCoding.ArrayHelper.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
            <summary>
            Copies a range of elements from an <see cref="T:System.Array"/> starting at the specified source index and pastes them to another <see cref="T:System.Array"/> starting at the specified destination index. Guarantees that all changes are undone if the copy does not succeed completely.
            </summary>
            <remarks><seealso href="https://docs.microsoft.com/en-us/dotnet/api/system.array.constrainedcopy?view=net-5.0"/></remarks>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:System.RankException"></exception>
            <exception cref="T:System.ArrayTypeMismatchException"></exception>
            <exception cref="T:System.InvalidCastException"></exception>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
            <exception cref="T:System.ArgumentException"></exception>
            <param name="sourceArray">The <see cref="T:System.Array"/> that contains the data to copy.</param>
            <param name="sourceIndex">A 32-bit integer that represents the index in the <paramref name="sourceArray"/> at which copying begins.</param>
            <param name="destinationArray">The <see cref="T:System.Array"/> that receives the data.</param>
            <param name="destinationIndex">A 32-bit integer that represents the index in the <paramref name="destinationArray"/> at which storing begins.</param>
            <param name="length">A 32-bit integer that represents the number of elements to copy.</param>
            <returns><paramref name="destinationArray"/></returns>
        </member>
        <member name="M:KeepCoding.ArrayHelper.ConvertAll``2(``0[],System.Converter{``0,``1})">
            <summary>
            Converts an array of one type to an array of another type.
            </summary>
            <remarks><seealso href="https://docs.microsoft.com/en-us/dotnet/api/system.array.convertall?view=net-5.0"/></remarks>
            <exception cref="T:System.ArgumentNullException"></exception>
            <typeparam name="TInput">The type of the elements of the source array.</typeparam>
            <typeparam name="TOutput">The type of the elements of the target array.</typeparam>
            <param name="array">The one-dimensional, zero-based <see cref="T:System.Array"/> to convert to a target type.</param>
            <param name="converter">A <see cref="T:System.Converter`2"/> that converts each element from one type to another type.</param>
            <returns>An array of the target type containing the converted elements from the source array.</returns>
        </member>
        <member name="M:KeepCoding.ArrayHelper.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
            <summary>
            Copies a range of elements from an <see cref="T:System.Array"/> starting at the specified source index and pastes them to another <see cref="T:System.Array"/> starting at the specified destination index. The length and the indexes are specified as 64-bit integers.
            </summary>
            <remarks><seealso href="https://docs.microsoft.com/en-us/dotnet/api/system.array.copy?view=net-5.0#System_Array_Copy_System_Array_System_Int64_System_Array_System_Int64_System_Int64_"/></remarks>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:System.RankException"></exception>
            <exception cref="T:System.ArrayTypeMismatchException"></exception>
            <exception cref="T:System.InvalidCastException"></exception>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
            <exception cref="T:System.ArgumentException"></exception>
            <param name="sourceArray">The <see cref="T:System.Array"/> that contains the data to copy.</param>
            <param name="sourceIndex">A 64-bit integer that represents the index in the <paramref name="sourceArray"/> at which copying begins.</param>
            <param name="destinationArray">The <see cref="T:System.Array"/> that receives the data.</param>
            <param name="destinationIndex">A 64-bit integer that represents the index in the <paramref name="destinationIndex"/> at which storing begins.</param>
            <param name="length">A 64-bit integer that represents the number of elements to copy. The integer must be between zero and <see cref="F:System.Int32.MaxValue"/>, inclusive.</param>
            <returns><paramref name="destinationArray"/></returns>
        </member>
        <member name="M:KeepCoding.ArrayHelper.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
            <summary>
            Copies a range of elements from an <see cref="T:System.Array"/> starting at the specified source index and pastes them to another <see cref="T:System.Array"/> starting at the specified destination index. The length and the indexes are specified as 32-bit integers.
            </summary>
            <remarks><seealso href="https://docs.microsoft.com/en-us/dotnet/api/system.array.copy?view=net-5.0#System_Array_Copy_System_Array_System_Int32_System_Array_System_Int32_System_Int32_"/></remarks>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:System.RankException"></exception>
            <exception cref="T:System.ArrayTypeMismatchException"></exception>
            <exception cref="T:System.InvalidCastException"></exception>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
            <exception cref="T:System.ArgumentException"></exception>
            <param name="sourceArray">The <see cref="T:System.Array"/> that contains the data to copy.</param>
            <param name="sourceIndex">A 32-bit integer that represents the index in the <paramref name="sourceArray"/> at which copying begins.</param>
            <param name="destinationArray">The <see cref="T:System.Array"/> that receives the data.</param>
            <param name="destinationIndex">A 32-bit integer that represents the index in the <paramref name="destinationIndex"/> at which storing begins.</param>
            <param name="length">A 32-bit integer that represents the number of elements to copy.</param>
            <returns><paramref name="destinationArray"/></returns>
        </member>
        <member name="M:KeepCoding.ArrayHelper.Copy(System.Array,System.Array,System.Int64)">
            <summary>
            Copies a range of elements from an Array starting at the first element and pastes them into another Array starting at the first element. The length is specified as a 64-bit integer.
            </summary>
            <remarks><seealso href="https://docs.microsoft.com/en-us/dotnet/api/system.array.copy?view=net-5.0#System_Array_Copy_System_Array_System_Array_System_Int64_"/></remarks>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:System.RankException"></exception>
            <exception cref="T:System.ArrayTypeMismatchException"></exception>
            <exception cref="T:System.InvalidCastException"></exception>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
            <exception cref="T:System.ArgumentException"></exception>
            <param name="sourceArray">The <see cref="T:System.Array"/> that contains the data to copy.</param>
            <param name="destinationArray">The <see cref="T:System.Array"/> that receives the data.</param>
            <param name="length">A 64-bit integer that represents the number of elements to copy. The integer must be between zero and <see cref="F:System.Int32.MaxValue"/>, inclusive.</param>
            <returns><paramref name="destinationArray"/></returns>
        </member>
        <member name="M:KeepCoding.ArrayHelper.Copy(System.Array,System.Array,System.Int32)">
            <summary>
            Copies a range of elements from an <see cref="T:System.Array"/> starting at the first element and pastes them into another <see cref="T:System.Array"/> starting at the first element. The length is specified as a 32-bit integer.
            </summary>
            <remarks><seealso href="https://docs.microsoft.com/en-us/dotnet/api/system.array.copy?view=net-5.0#System_Array_Copy_System_Array_System_Array_System_Int32_"/></remarks>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:System.RankException"></exception>
            <exception cref="T:System.ArrayTypeMismatchException"></exception>
            <exception cref="T:System.InvalidCastException"></exception>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
            <exception cref="T:System.ArgumentException"></exception>
            <param name="sourceArray">The <see cref="T:System.Array"/> that contains the data to copy.</param>
            <param name="destinationArray">The <see cref="T:System.Array"/> that receives the data.</param>
            <param name="length">A 32-bit integer that represents the number of elements to copy.</param>
            <returns><paramref name="destinationArray"/></returns>
        </member>
        <member name="M:KeepCoding.ArrayHelper.CreateInstance(System.Type,System.Int32)">
            <summary>
            Creates a one-dimensional <see cref="T:System.Array"/> of the specified <see cref="T:System.Type"/> and length, with zero-based indexing.
            </summary>
            <remarks><seealso href="https://docs.microsoft.com/en-us/dotnet/api/system.array.createinstance?view=net-5.0#System_Array_CreateInstance_System_Type_System_Int32_"/></remarks>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:System.ArgumentException"></exception>
            <exception cref="T:System.NotSupportedException"></exception>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
            <param name="elementType">The <see cref="T:System.Type"/> of the <see cref="T:System.Array"/> to create.</param>
            <param name="length">The size of the <see cref="T:System.Array"/> to create.</param>
            <returns>A new one-dimensional <see cref="T:System.Array"/> of the specified <see cref="T:System.Type"/> with the specified length, using zero-based indexing.</returns>
        </member>
        <member name="M:KeepCoding.ArrayHelper.CreateInstance(System.Type,System.Int32[])">
            <summary>
            Creates a multidimensional <see cref="T:System.Array"/> of the specified <see cref="T:System.Type"/> and dimension lengths, with zero-based indexing. The dimension lengths are specified in an array of 32-bit integers.
            </summary>
            <param name="elementType">The <see cref="T:System.Type"/> of the <see cref="T:System.Array"/> to create.</param>
            <param name="lengths">An array of 32-bit integers that represent the size of each dimension of the <see cref="T:System.Array"/> to create.</param>
            <returns>A new multidimensional <see cref="T:System.Array"/> of the specified <see cref="T:System.Type"/> with the specified length for each dimension, using zero-based indexing.</returns>
        </member>
        <member name="M:KeepCoding.ArrayHelper.CreateInstance(System.Type,System.Int64[])">
            <summary>
            Creates a multidimensional <see cref="T:System.Array"/> of the specified <see cref="T:System.Type"/> and dimension lengths, with zero-based indexing. The dimension lengths are specified in an array of 64-bit integers.
            </summary>
            <remarks><seealso href="https://docs.microsoft.com/en-us/dotnet/api/system.array.createinstance?view=net-5.0#System_Array_CreateInstance_System_Type_System_Int64___"/></remarks>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:System.ArgumentException"></exception>
            <exception cref="T:System.NotSupportedException"></exception>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
            <param name="elementType">The <see cref="T:System.Type"/> of the <see cref="T:System.Array"/> to create.</param>
            <param name="lengths">An array of 64-bit integers that represent the size of each dimension of the <see cref="T:System.Array"/> to create. Each integer in the array must be between zero and <see cref="F:System.Int32.MaxValue"/>, inclusive.</param>
            <returns>A new multidimensional <see cref="T:System.Array"/> of the specified <see cref="T:System.Type"/> with the specified length for each dimension, using zero-based indexing.</returns>
        </member>
        <member name="M:KeepCoding.ArrayHelper.CreateInstance(System.Type,System.Int32,System.Int32)">
            <summary>
            Creates a two-dimensional Array of the specified Type and dimension lengths, with zero-based indexing.
            </summary>
            <remarks><see href="https://docs.microsoft.com/en-us/dotnet/api/system.array.createinstance?view=net-5.0#System_Array_CreateInstance_System_Type_System_Int32_System_Int32_"/></remarks>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:System.ArgumentException"></exception>
            <exception cref="T:System.NotSupportedException"></exception>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
            <param name="elementType">The <see cref="T:System.Type"/> of the <see cref="T:System.Array"/> to create.</param>
            <param name="length1">The size of the first dimension of the <see cref="T:System.Array"/> to create.</param>
            <param name="length2">The size of the second dimension of the <see cref="T:System.Array"/> to create.</param>
            <returns>A new two-dimensional <see cref="T:System.Array"/> of the specified <see cref="T:System.Type"/> with the specified length for each dimension, using zero-based indexing.</returns>
        </member>
        <member name="M:KeepCoding.ArrayHelper.CreateInstance(System.Type,System.Int32[],System.Int32[])">
            <summary>
            Creates a multidimensional <see cref="T:System.Array"/> of the specified <see cref="T:System.Type"/> and dimension lengths, with the specified lower bounds.
            </summary>
            <remarks><see href="https://docs.microsoft.com/en-us/dotnet/api/system.array.createinstance?view=net-5.0#System_Array_CreateInstance_System_Type_System_Int32___System_Int32___"/></remarks>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:System.ArgumentException"></exception>
            <exception cref="T:System.NotSupportedException"></exception>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
            <param name="elementType">The <see cref="T:System.Type"/> of the <see cref="T:System.Array"/> to create.</param>
            <param name="lengths">A one-dimensional array that contains the size of each dimension of the <see cref="T:System.Array"/> to create.</param>
            <param name="lowerBounds">A one-dimensional array that contains the lower bound (starting index) of each dimension of the <see cref="T:System.Array"/> to create.</param>
            <returns>A new multidimensional <see cref="T:System.Array"/> of the specified <see cref="T:System.Type"/> with the specified length and lower bound for each dimension.</returns>
        </member>
        <member name="M:KeepCoding.ArrayHelper.CreateInstance(System.Type,System.Int32,System.Int32,System.Int32)">
            <summary>
            Creates a three-dimensional <see cref="T:System.Array"/> of the specified <see cref="T:System.Type"/> and dimension lengths, with zero-based indexing.
            </summary>
            <remarks><seealso href="https://docs.microsoft.com/en-us/dotnet/api/system.array.createinstance?view=net-5.0#System_Array_CreateInstance_System_Type_System_Int32_System_Int32_System_Int32_"/></remarks>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:System.ArgumentException"></exception>
            <exception cref="T:System.NotSupportedException"></exception>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
            <param name="elementType">The <see cref="T:System.Type"/> of the <see cref="T:System.Array"/> to create.</param>
            <param name="length1">The size of the first dimension of the <see cref="T:System.Array"/> to create.</param>
            <param name="length2">The size of the second dimension of the <see cref="T:System.Array"/> to create.</param>
            <param name="length3">The size of the third dimension of the <see cref="T:System.Array"/> to create.</param>
            <returns>A new three-dimensional <see cref="T:System.Array"/> of the specified <see cref="T:System.Type"/> with the specified length for each dimension, using zero-based indexing.</returns>
        </member>
        <member name="M:KeepCoding.ArrayHelper.Exists``1(``0[],System.Predicate{``0})">
            <summary>
            Determines whether the specified array contains elements that match the conditions defined by the specified predicate.
            </summary>
            <remarks><seealso href="https://docs.microsoft.com/en-us/dotnet/api/system.array.exists?view=net-5.0"/></remarks>
            <typeparam name="T">The type of the elements of the array.</typeparam>
            <param name="array">The one-dimensional, zero-based <see cref="T:System.Array"/> to search.</param>
            <param name="match">The <see cref="T:System.Predicate`1"/> that defines the conditions of the elements to search for.</param>
            <returns><c>true</c> if <paramref name="array"/> contains one or more elements that match the conditions defined by the specified predicate; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:KeepCoding.ArrayHelper.Find``1(``0[],System.Predicate{``0})">
            <summary>
            Searches for an element that matches the conditions defined by the specified predicate, and returns the first occurrence within the entire <see cref="T:System.Array"/>.
            </summary>
            <remarks><seealso href="https://docs.microsoft.com/en-us/dotnet/api/system.array.find?view=net-5.0"/></remarks>
            <exception cref="T:System.ArgumentNullException"></exception>
            <typeparam name="T">The type of the elements of the array.</typeparam>
            <param name="array">The one-dimensional, zero-based array to search.</param>
            <param name="match">The predicate that defines the conditions of the element to search for.</param>
            <returns>The first element that matches the conditions defined by the specified predicate, if found; otherwise, the default value for type <typeparamref name="T"/>.</returns>
        </member>
        <member name="M:KeepCoding.ArrayHelper.FindAll``1(``0[],System.Predicate{``0})">
            <summary>
            Retrieves all the elements that match the conditions defined by the specified predicate.
            </summary>
            <remarks><seealso href="https://docs.microsoft.com/en-us/dotnet/api/system.array.findall?view=net-5.0"/></remarks>
            <typeparam name="T">The type of the elements of the array.</typeparam>
            <param name="array">The one-dimensional, zero-based <see cref="T:System.Array"/> to search.</param>
            <param name="match">The <see cref="T:System.Predicate`1"/> that defines the conditions of the elements to search for.</param>
            <returns>An <see cref="T:System.Array"/> containing all the elements that match the conditions defined by the specified predicate, if found; otherwise, an empty <see cref="T:System.Array"/>.</returns>
        </member>
        <member name="M:KeepCoding.ArrayHelper.FindIndex``1(``0[],System.Predicate{``0})">
            <summary>
            Searches for an element that matches the conditions defined by the specified predicate, and returns the zero-based index of the first occurrence within the entire <see cref="T:System.Array"/>.
            </summary>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
            <typeparam name="T">The type of the elements of the array.</typeparam>
            <param name="array">The one-dimensional, zero-based <see cref="T:System.Array"/> to search.</param>
            <param name="match">The <see cref="T:System.Predicate`1"/> that defines the conditions of the element to search for.</param>
            <returns>The zero-based index of the first occurrence of an element that matches the conditions defined by <paramref name="match"/>, if found; otherwise, -1.</returns>
        </member>
        <member name="M:KeepCoding.ArrayHelper.FindIndex``1(``0[],System.Int32,System.Predicate{``0})">
            <summary>
            Searches for an element that matches the conditions defined by the specified predicate, and returns the zero-based index of the first occurrence within the range of elements in the <see cref="T:System.Array"/> that extends from the specified index to the last element.
            </summary>
            <remarks><seealso href="https://docs.microsoft.com/en-us/dotnet/api/system.array.findindex?view=net-5.0#System_Array_FindIndex__1___0___System_Int32_System_Predicate___0__"/></remarks>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
            <typeparam name="T">The type of the elements of the array.</typeparam>
            <param name="array">The one-dimensional, zero-based <see cref="T:System.Array"/> to search.</param>
            <param name="startIndex">The zero-based starting index of the search.</param>
            <param name="match">The <see cref="T:System.Predicate`1"/> that defines the conditions of the element to search for.</param>
            <returns>The zero-based index of the first occurrence of an element that matches the conditions defined by <paramref name="match"/>, if found; otherwise, -1.</returns>
        </member>
        <member name="M:KeepCoding.ArrayHelper.FindIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
            <summary>
            Searches for an element that matches the conditions defined by the specified predicate, and returns the zero-based index of the first occurrence within the range of elements in the <see cref="T:System.Array"/> that starts at the specified index and contains the specified number of elements.
            </summary>
            <remarks>https://docs.microsoft.com/en-us/dotnet/api/system.array.findindex?view=net-5.0#System_Array_FindIndex__1___0___System_Int32_System_Int32_System_Predicate___0__</remarks>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
            <typeparam name="T">The type of the elements of the array.</typeparam>
            <param name="array">The one-dimensional, zero-based <see cref="T:System.Array"/> to search.</param>
            <param name="startIndex">The zero-based starting index of the search.</param>
            <param name="count">The number of elements in the section to search.</param>
            <param name="match">The <see cref="T:System.Predicate`1"/> that defines the conditions of the element to search for.</param>
            <returns>The zero-based index of the first occurrence of an element that matches the conditions defined by <see cref="T:System.Predicate`1"/>, if found; otherwise, -1.</returns>
        </member>
        <member name="M:KeepCoding.ArrayHelper.FindLast``1(``0[],System.Predicate{``0})">
            <summary>
            Searches for an element that matches the conditions defined by the specified predicate, and returns the last occurrence within the entire <see cref="T:System.Array"/>.
            </summary>
            <remarks><seealso href="https://docs.microsoft.com/en-us/dotnet/api/system.array.findlast?view=net-5.0"/></remarks>
            <typeparam name="T">The type of the elements of the array.</typeparam>
            <param name="array">The one-dimensional, zero-based <see cref="T:System.Array"/> to search.</param>
            <param name="match">The <see cref="T:System.Predicate`1"/> that defines the conditions of the element to search for.</param>
            <returns>The last element that matches the conditions defined by the specified predicate, if found; otherwise, the default value for type <typeparamref name="T"/>.</returns>
        </member>
        <member name="M:KeepCoding.ArrayHelper.FindLastIndex``1(``0[],System.Predicate{``0})">
            <summary>
            Searches for an element that matches the conditions defined by the specified predicate, and returns the zero-based index of the last occurrence within the entire <see cref="T:System.Array"/>.
            </summary>
            <remarks><see href="https://docs.microsoft.com/en-us/dotnet/api/system.array.findlastindex?view=net-5.0#System_Array_FindLastIndex__1___0___System_Predicate___0__"/></remarks>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
            <typeparam name="T">The type of the elements of the array.</typeparam>
            <param name="array">The one-dimensional, zero-based <see cref="T:System.Array"/> to search.</param>
            <param name="match">The <see cref="T:System.Predicate`1"/> that defines the conditions of the element to search for.</param>
            <returns>The zero-based index of the last occurrence of an element that matches the conditions defined by <paramref name="match"/>, if found; otherwise, -1.</returns>
        </member>
        <member name="M:KeepCoding.ArrayHelper.FindLastIndex``1(``0[],System.Int32,System.Predicate{``0})">
            <summary>
            Searches for an element that matches the conditions defined by the specified predicate, and returns the zero-based index of the last occurrence within the range of elements in the <see cref="T:System.Array"/> that extends from the specified index to the last element.
            </summary>
            <remarks><seealso href="https://docs.microsoft.com/en-us/dotnet/api/system.array.findlastindex?view=net-5.0#System_Array_FindLastIndex__1___0___System_Int32_System_Predicate___0__"/></remarks>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
            <typeparam name="T">The type of the elements of the array.</typeparam>
            <param name="array">The one-dimensional, zero-based <see cref="T:System.Array"/> to search.</param>
            <param name="startIndex">The zero-based starting index of the search.</param>
            <param name="match">The <see cref="T:System.Predicate`1"/> that defines the conditions of the element to search for.</param>
            <returns>The zero-based index of the last occurrence of an element that matches the conditions defined by <paramref name="match"/>, if found; otherwise, -1.</returns>
        </member>
        <member name="M:KeepCoding.ArrayHelper.FindLastIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
            <summary>
            Searches for an element that matches the conditions defined by the specified predicate, and returns the zero-based index of the last occurrence within the range of elements in the <see cref="T:System.Array"/> that starts at the specified index and contains the specified number of elements.
            </summary>
            <remarks>https://docs.microsoft.com/en-us/dotnet/api/system.array.findlastindex?view=net-5.0#System_Array_FindLastIndex__1___0___System_Int32_System_Int32_System_Predicate___0__</remarks>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
            <typeparam name="T">The type of the elements of the array.</typeparam>
            <param name="array">The one-dimensional, zero-based <see cref="T:System.Array"/> to search.</param>
            <param name="startIndex">The zero-based starting index of the search.</param>
            <param name="count">The number of elements in the section to search.</param>
            <param name="match">The <see cref="T:System.Predicate`1"/> that defines the conditions of the element to search for.</param>
            <returns>The zero-based index of the last occurrence of an element that matches the conditions defined by <see cref="T:System.Predicate`1"/>, if found; otherwise, -1.</returns>
        </member>
        <member name="M:KeepCoding.ArrayHelper.ForEach``1(``0[],System.Action{``0})">
            <summary>
            Performs the specified action on each element of the specified array.
            </summary>
            <remarks><seealso href="https://docs.microsoft.com/en-us/dotnet/api/system.array.foreach?view=net-5.0"/></remarks>
            <exception cref="T:System.ArgumentNullException"></exception>
            <typeparam name="T">The type of the elements of the array.</typeparam>
            <param name="array">The one-dimensional, zero-based <see cref="T:System.Array"/> on whose elements the action is to be performed.</param>
            <param name="action">The <see cref="T:System.Action`1"/> to perform on each element of <paramref name="array"/>.</param>
            <returns><paramref name="array"/></returns>
        </member>
        <member name="M:KeepCoding.ArrayHelper.IndexOf(System.Array,System.Object)">
            <summary>
            Searches for the specified object and returns the index of its first occurrence in a one-dimensional array.
            </summary>
            <remarks><seealso href="https://docs.microsoft.com/en-us/dotnet/api/system.array.indexof?view=net-5.0#System_Array_IndexOf_System_Array_System_Object_"/></remarks>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:System.RankException"></exception>
            <param name="array">The one-dimensional array to search.</param>
            <param name="value">The object to locate in <paramref name="array"/>.</param>
            <returns>The index of the first occurrence of <paramref name="value"/> in <paramref name="array"/>, if found; otherwise, the lower bound of the array minus 1.</returns>
        </member>
        <member name="M:KeepCoding.ArrayHelper.IndexOf(System.Array,System.Object,System.Int32)">
            <summary>
            Searches for the specified object in a range of elements of a one-dimensional array, and returns the index of its first occurrence. The range extends from a specified index to the end of the array.
            </summary>
            <remarks><seealso href="https://docs.microsoft.com/en-us/dotnet/api/system.array.indexof?view=net-5.0#System_Array_IndexOf_System_Array_System_Object_System_Int32_"/></remarks>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
            <exception cref="T:System.RankException"></exception>
            <param name="array">The one-dimensional array to search.</param>
            <param name="value">The object to locate in <paramref name="array"/>.</param>
            <param name="startIndex">The starting index of the search. 0 (zero) is valid in an empty array.</param>
            <returns>The index of the first occurrence of <paramref name="value"/>, if it's found, within the range of elements in <paramref name="array"/> that extends from <paramref name="startIndex"/> to the last element; otherwise, the lower bound of the array minus 1.</returns>
        </member>
        <member name="M:KeepCoding.ArrayHelper.IndexOf(System.Array,System.Object,System.Int32,System.Int32)">
            <summary>
            Searches for the specified object in a range of elements of a one-dimensional array, and returns the index of ifs first occurrence. The range extends from a specified index for a specified number of elements.
            </summary>
            <remarks><seealso href="https://docs.microsoft.com/en-us/dotnet/api/system.array.indexof?view=net-5.0#System_Array_IndexOf_System_Array_System_Object_System_Int32_System_Int32_"/></remarks>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
            <exception cref="T:System.RankException"></exception>
            <param name="array">The one-dimensional array to search.</param>
            <param name="value">The object to locate in <paramref name="array"/>.</param>
            <param name="startIndex">The starting index of the search. 0 (zero) is valid in an empty array.</param>
            <param name="count">The number of elements to search.</param>
            <returns>The index of the first occurrence of <paramref name="value"/>, if it's found in the <paramref name="array"/> from index <paramref name="startIndex"/> to <paramref name="startIndex"/> + <paramref name="count"/> - 1; otherwise, the lower bound of the array minus 1.</returns>
        </member>
        <member name="M:KeepCoding.ArrayHelper.IndexOf``1(``0[],``0,System.Int32,System.Int32)">
            <summary>
            Searches for the specified object in a range of elements of a one-dimensional array, and returns the index of its first occurrence. The range extends from a specified index for a specified number of elements.
            </summary>
            <remarks><seealso href="https://docs.microsoft.com/en-us/dotnet/api/system.array.indexof?view=net-5.0#System_Array_IndexOf__1___0_____0_System_Int32_System_Int32_"/></remarks>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
            <typeparam name="T">The type of the elements of the array.</typeparam>
            <param name="array">The one-dimensional, zero-based array to search.</param>
            <param name="value">The object to locate in <paramref name="array"/>.</param>
            <param name="startIndex">The zero-based starting index of the search. 0 (zero) is valid in an empty array.</param>
            <param name="count">The number of elements in the section to search.</param>
            <returns>The zero-based index of the first occurrence of <paramref name="value"/> within the range of elements in <paramref name="array"/> that starts at <paramref name="startIndex"/> and contains the number of elements specified in <paramref name="count"/>, if found; otherwise, -1.</returns>
        </member>
        <member name="M:KeepCoding.ArrayHelper.IndexOf``1(``0[],``0)">
            <summary>
            Searches for the specified object and returns the index of its first occurrence in a one-dimensional array.
            </summary>
            <remarks><seealso href="https://docs.microsoft.com/en-us/dotnet/api/system.array.indexof?view=net-5.0#System_Array_IndexOf__1___0_____0_"/></remarks>
            <exception cref="T:System.ArgumentNullException"></exception>
            <typeparam name="T">The type of the elements of the array.</typeparam>
            <param name="array">The one-dimensional, zero-based array to search.</param>
            <param name="value">The object to locate in <paramref name="array"/>.</param>
            <returns>The zero-based index of the first occurrence of <paramref name="value"/> in the entire <paramref name="array"/>, if found; otherwise, -1.</returns>
        </member>
        <member name="M:KeepCoding.ArrayHelper.IndexOf``1(``0[],``0,System.Int32)">
            <summary>
            Searches for the specified object in a range of elements of a one dimensional array, and returns the index of its first occurrence. The range extends from a specified index to the end of the array.
            </summary>
            <remarks><seealso href="https://docs.microsoft.com/en-us/dotnet/api/system.array.indexof?view=net-5.0#System_Array_IndexOf__1___0_____0_System_Int32_"/></remarks>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
            <typeparam name="T">The type of the elements of the array.</typeparam>
            <param name="array">The one-dimensional, zero-based array to search.</param>
            <param name="value">The object to locate in <paramref name="array"/>.</param>
            <param name="startIndex">The zero-based starting index of the search. 0 (zero) is valid in an empty array.</param>
            <returns>The zero-based index of the first occurrence of <paramref name="value"/> within the range of elements in <paramref name="array"/> that extends from <paramref name="startIndex"/> to the last element, if found; otherwise, -1.</returns>
        </member>
        <member name="M:KeepCoding.ArrayHelper.LastIndexOf(System.Array,System.Object)">
            <summary>
            Searches for the specified object and returns the index of its last occurrence in a one-dimensional array.
            </summary>
            <remarks><seealso href="https://docs.microsoft.com/en-us/dotnet/api/system.array.indexof?view=net-5.0#System_Array_IndexOf_System_Array_System_Object_"/></remarks>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:System.RankException"></exception>
            <param name="array">The one-dimensional array to search.</param>
            <param name="value">The object to locate in <paramref name="array"/>.</param>
            <returns>The index of the last occurrence of <paramref name="value"/> in <paramref name="array"/>, if found; otherwise, the lower bound of the array minus 1.</returns>
        </member>
        <member name="M:KeepCoding.ArrayHelper.LastIndexOf(System.Array,System.Object,System.Int32)">
            <summary>
            Searches for the specified object in a range of elements of a one-dimensional array, and returns the index of its last occurrence. The range extends from a specified index to the end of the array.
            </summary>
            <remarks><seealso href="https://docs.microsoft.com/en-us/dotnet/api/system.array.indexof?view=net-5.0#System_Array_IndexOf_System_Array_System_Object_System_Int32_"/></remarks>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
            <exception cref="T:System.RankException"></exception>
            <param name="array">The one-dimensional array to search.</param>
            <param name="value">The object to locate in <paramref name="array"/>.</param>
            <param name="startIndex">The starting index of the search. 0 (zero) is valid in an empty array.</param>
            <returns>The index of the last occurrence of <paramref name="value"/>, if it's found, within the range of elements in <paramref name="array"/> that extends from <paramref name="startIndex"/> to the last element; otherwise, the lower bound of the array minus 1.</returns>
        </member>
        <member name="M:KeepCoding.ArrayHelper.LastIndexOf(System.Array,System.Object,System.Int32,System.Int32)">
            <summary>
            Searches for the specified object in a range of elements of a one-dimensional array, and returns the index of ifs last occurrence. The range extends from a specified index for a specified number of elements.
            </summary>
            <remarks><seealso href="https://docs.microsoft.com/en-us/dotnet/api/system.array.indexof?view=net-5.0#System_Array_IndexOf_System_Array_System_Object_System_Int32_System_Int32_"/></remarks>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
            <exception cref="T:System.RankException"></exception>
            <param name="array">The one-dimensional array to search.</param>
            <param name="value">The object to locate in <paramref name="array"/>.</param>
            <param name="startIndex">The starting index of the search. 0 (zero) is valid in an empty array.</param>
            <param name="count">The number of elements to search.</param>
            <returns>The index of the last occurrence of <paramref name="value"/>, if it's found in the <paramref name="array"/> from index <paramref name="startIndex"/> to <paramref name="startIndex"/> + <paramref name="count"/> - 1; otherwise, the lower bound of the array minus 1.</returns>
        </member>
        <member name="M:KeepCoding.ArrayHelper.LastIndexOf``1(``0[],``0,System.Int32,System.Int32)">
            <summary>
            Searches for the specified object in a range of elements of a one-dimensional array, and returns the index of its last occurrence. The range extends from a specified index for a specified number of elements.
            </summary>
            <remarks><seealso href="https://docs.microsoft.com/en-us/dotnet/api/system.array.indexof?view=net-5.0#System_Array_IndexOf__1___0_____0_System_Int32_System_Int32_"/></remarks>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
            <typeparam name="T">The type of the elements of the array.</typeparam>
            <param name="array">The one-dimensional, zero-based array to search.</param>
            <param name="value">The object to locate in <paramref name="array"/>.</param>
            <param name="startIndex">The zero-based starting index of the search. 0 (zero) is valid in an empty array.</param>
            <param name="count">The number of elements in the section to search.</param>
            <returns>The zero-based index of the last occurrence of <paramref name="value"/> within the range of elements in <paramref name="array"/> that starts at <paramref name="startIndex"/> and contains the number of elements specified in <paramref name="count"/>, if found; otherwise, -1.</returns>
        </member>
        <member name="M:KeepCoding.ArrayHelper.LastIndexOf``1(``0[],``0)">
            <summary>
            Searches for the specified object and returns the index of its last occurrence in a one-dimensional array.
            </summary>
            <remarks><seealso href="https://docs.microsoft.com/en-us/dotnet/api/system.array.indexof?view=net-5.0#System_Array_IndexOf__1___0_____0_"/></remarks>
            <exception cref="T:System.ArgumentNullException"></exception>
            <typeparam name="T">The type of the elements of the array.</typeparam>
            <param name="array">The one-dimensional, zero-based array to search.</param>
            <param name="value">The object to locate in <paramref name="array"/>.</param>
            <returns>The zero-based index of the last occurrence of <paramref name="value"/> in the entire <paramref name="array"/>, if found; otherwise, -1.</returns>
        </member>
        <member name="M:KeepCoding.ArrayHelper.LastIndexOf``1(``0[],``0,System.Int32)">
            <summary>
            Searches for the specified object in a range of elements of a one dimensional array, and returns the index of its last occurrence. The range extends from a specified index to the end of the array.
            </summary>
            <remarks><seealso href="https://docs.microsoft.com/en-us/dotnet/api/system.array.indexof?view=net-5.0#System_Array_IndexOf__1___0_____0_System_Int32_"/></remarks>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
            <typeparam name="T">The type of the elements of the array.</typeparam>
            <param name="array">The one-dimensional, zero-based array to search.</param>
            <param name="value">The object to locate in <paramref name="array"/>.</param>
            <param name="startIndex">The zero-based starting index of the search. 0 (zero) is valid in an empty array.</param>
            <returns>The zero-based index of the last occurrence of <paramref name="value"/> within the range of elements in <paramref name="array"/> that extends from <paramref name="startIndex"/> to the last element, if found; otherwise, -1.</returns>
        </member>
        <member name="M:KeepCoding.ArrayHelper.Resize``1(``0[],System.Int32)">
            <summary>
            Changes the number of elements of a one-dimensional array to the specified new size.
            </summary>
            <remarks><seealso href="https://docs.microsoft.com/en-us/dotnet/api/system.array.resize?view=net-5.0"/></remarks>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
            <typeparam name="T">The type of the elements of the array.</typeparam>
            <param name="array">The one-dimensional, zero-based array to resize, or <c>null</c> to create a new array with the specified size.</param>
            <param name="newSize">The size of the new array.</param>
            <returns><paramref name="array"/></returns>
        </member>
        <member name="M:KeepCoding.ArrayHelper.Reverse(System.Array,System.Int32,System.Int32)">
            <summary>
            Reverses the sequence of a subset of the elements in the one-dimensional <see cref="T:System.Array"/>.
            </summary>
            <remarks>https://docs.microsoft.com/en-us/dotnet/api/system.array.reverse?view=net-5.0#System_Array_Reverse_System_Array_System_Int32_System_Int32_</remarks>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:System.RankException"></exception>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
            <exception cref="T:System.ArgumentException"></exception>
            <param name="array">The one-dimensional <see cref="T:System.Array"/> to reverse.</param>
            <param name="index">The starting index of the section to reverse.</param>
            <param name="length">The number of elements in the section to reverse.</param>
            <returns><paramref name="array"/></returns>
        </member>
        <member name="M:KeepCoding.ArrayHelper.Reverse(System.Array)">
            <summary>
            Reverses the sequence of the elements in the entire one-dimensional <see cref="T:System.Array"/>.
            </summary>
            <remarks><seealso href="https://docs.microsoft.com/en-us/dotnet/api/system.array.reverse?view=net-5.0#System_Array_Reverse_System_Array_"/></remarks>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:System.RankException"></exception>
            <param name="array">The one-dimensional <see cref="T:System.Array"/> to reverse.</param>
            <returns><paramref name="array"/></returns>
        </member>
        <member name="M:KeepCoding.ArrayHelper.Reverse``1(``0[])">
            <summary>
            Reverses the sequence of the elements in the one-dimensional generic array.
            </summary>
            <remarks><seealso href="https://docs.microsoft.com/en-us/dotnet/api/system.array.reverse?view=net-5.0#System_Array_Reverse__1___0___"/></remarks>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:System.RankException"></exception>
            <typeparam name="T">The type of the elements in <paramref name="array"/>.</typeparam>
            <param name="array">The one-dimensional array of elements to reverse.</param>
            <returns><paramref name="array"/></returns>
        </member>
        <member name="M:KeepCoding.ArrayHelper.Reverse``1(``0[],System.Int32,System.Int32)">
            <summary>
            Reverses the sequence of a subset of the elements in the one-dimensional generic array.
            </summary>
            <remarks><seealso href="https://docs.microsoft.com/en-us/dotnet/api/system.array.reverse?view=net-5.0#System_Array_Reverse__1___0___System_Int32_System_Int32_"/></remarks>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:System.RankException"></exception>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
            <exception cref="T:System.ArgumentException"></exception>
            <typeparam name="T">The type of the elements in <paramref name="array"/>.</typeparam>
            <param name="array">The one-dimensional array of elements to reverse.</param>
            <param name="index">The starting index of the section to reverse.</param>
            <param name="length">The number of elements in the section to reverse.</param>
            <returns><paramref name="array"/></returns>
        </member>
        <member name="M:KeepCoding.ArrayHelper.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
            <summary>
            Sorts the elements in a range of elements in a one-dimensional <see cref="T:System.Array"/> using the specified <see cref="T:System.Collections.IComparer"/>.
            </summary>
            <remarks><seealso href="https://docs.microsoft.com/en-us/dotnet/api/system.array.sort?view=net-5.0#System_Array_Sort_System_Array_System_Int32_System_Int32_System_Collections_IComparer_"/></remarks>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:System.RankException"></exception>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
            <exception cref="T:System.ArgumentException"></exception>
            <exception cref="T:System.InvalidOperationException"></exception>
            <param name="array">The one-dimensional <see cref="T:System.Array"/> to sort.</param>
            <param name="index">The starting index of the range to sort.</param>
            <param name="length">The number of elements in the range to sort</param>
            <param name="comparer">The <see cref="T:System.Collections.IComparer"/> implementation to use when comparing elements.</param>
            <returns><paramref name="array"/></returns>
        </member>
        <member name="M:KeepCoding.ArrayHelper.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
            <summary>
            Sorts a range of elements in a pair of one-dimensional <see cref="T:System.Array"/> objects (one contains the keys and the other contains the corresponding items) based on the keys in the first <see cref="T:System.Array"/> using the specified <see cref="T:System.Collections.IComparer"/>.
            </summary>
            <remarks><seealso href="https://docs.microsoft.com/en-us/dotnet/api/system.array.sort?view=net-5.0#System_Array_Sort_System_Array_System_Array_System_Int32_System_Int32_System_Collections_IComparer_"/></remarks>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:System.RankException"></exception>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
            <exception cref="T:System.ArgumentException"></exception>
            <exception cref="T:System.InvalidOperationException"></exception>
            <param name="keys">The one-dimensional <see cref="T:System.Array"/> that contains the keys to sort.</param>
            <param name="items">The one-dimensional <see cref="T:System.Array"/> that contains the items that correspond to each of the keys in the <paramref name="keys"/><see cref="T:System.Array"/> or <c>null</c> to sort only the <paramref name="keys"/><see cref="T:System.Array"/>.</param>
            <param name="index">The starting index of the range to sort.</param>
            <param name="length">The number of elements in the range to sort.</param>
            <param name="comparer">The <see cref="T:System.Collections.IComparer"/> implementation to use when comparing elements or <c>null</c> to use the <see cref="T:System.IComparable"/> implementation of each element.</param>
            <returns><paramref name="keys"/> and <paramref name="items"/></returns>
        </member>
        <member name="M:KeepCoding.ArrayHelper.Sort(System.Array,System.Int32,System.Int32)">
            <summary>
            Sorts the elements in a range of elements in a one-dimensional <see cref="T:System.Array"/> using the <see cref="T:System.IComparable"/> implementation of each element of the <see cref="T:System.Array"/>.
            </summary>
            <remarks><seealso href="https://docs.microsoft.com/en-us/dotnet/api/system.array.sort?view=net-5.0#System_Array_Sort_System_Array_System_Int32_System_Int32_"/></remarks>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:System.RankException"></exception>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
            <exception cref="T:System.ArgumentException"></exception>
            <exception cref="T:System.InvalidOperationException"></exception>
            <param name="array">The one-dimensional <see cref="T:System.Array"/> to sort.</param>
            <param name="index">The starting index of the range to sort.</param>
            <param name="length">The number of elements in the range to sort.</param>
            <returns><paramref name="array"/></returns>
        </member>
        <member name="M:KeepCoding.ArrayHelper.Sort(System.Array,System.Array,System.Int32,System.Int32)">
            <summary>
            Sorts a range of elements in a pair of one-dimensional <see cref="T:System.Array"/> objects (one contains the keys and the other contains the corresponding items) based on the keys in the first <see cref="T:System.Array"/> using the <see cref="T:System.IComparable"/> implementation of each key.
            </summary>
            <remarks><seealso href=""/>https://docs.microsoft.com/en-us/dotnet/api/system.array.sort?view=net-5.0#System_Array_Sort_System_Array_System_Array_System_Int32_System_Int32_</remarks>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:System.RankException"></exception>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
            <exception cref="T:System.ArgumentException"></exception>
            <exception cref="T:System.InvalidOperationException"></exception>
            <param name="keys">The one-dimensional <see cref="T:System.Array"/> that contains the keys to sort.</param>
            <param name="items">The one-dimensional <see cref="T:System.Array"/> that contains the items that correspond to each of the keys in the <paramref name="keys"/><see cref="T:System.Array"/> or <c>null</c> to sort only the <paramref name="keys"/><see cref="T:System.Array"/>.</param>
            <param name="index">The starting index of the range to sort.</param>
            <param name="length">The number of elements in the range to sort.</param>
            <returns><paramref name="keys"/> and <paramref name="items"/></returns>
        </member>
        <member name="M:KeepCoding.ArrayHelper.Sort(System.Array,System.Collections.IComparer)">
            <summary>
            Sorts the elements in a one-dimensional <see cref="T:System.Array"/> using the specified <see cref="T:System.Collections.IComparer"/>.
            </summary>
            <remarks><seealso href="https://docs.microsoft.com/en-us/dotnet/api/system.array.sort?view=net-5.0#System_Array_Sort_System_Array_System_Collections_IComparer_"/></remarks>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:System.RankException"></exception>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
            <exception cref="T:System.ArgumentException"></exception>
            <exception cref="T:System.InvalidOperationException"></exception>
            <param name="array">The one-dimensional array to sort.</param>
            <param name="comparer">The implementation to use when comparing elements or <c>null</c> to use the <see cref="T:System.IComparable"/> implementation of each element.</param>
            <returns><paramref name="array"/></returns>
        </member>
        <member name="M:KeepCoding.ArrayHelper.Sort(System.Array,System.Array,System.Collections.IComparer)">
            <summary>
            Sorts a pair of one-dimensional <see cref="T:System.Array"/> objects (one contains the keys and the other contains the corresponding items) based on the keys in the first <see cref="T:System.Array"/> using the specified <see cref="T:System.Collections.IComparer"/>.
            </summary>
            <remarks><seealso href="https://docs.microsoft.com/en-us/dotnet/api/system.array.sort?view=net-5.0#System_Array_Sort_System_Array_System_Array_System_Collections_IComparer_"/></remarks>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:System.RankException"></exception>
            <exception cref="T:System.ArgumentException"></exception>
            <exception cref="T:System.InvalidOperationException"></exception>
            <param name="keys">The one-dimensional <see cref="T:System.Array"/> that contains the keys to sort.</param>
            <param name="items">The one-dimensional <see cref="T:System.Array"/> that contains the items that correspond to each of the keys in the <paramref name="keys"/><see cref="T:System.Array"/> or <c>null</c> to sort only the <paramref name="keys"/><see cref="T:System.Array"/>.</param>
            <param name="comparer">The implementation to use when comparing elements or <c>null</c> to use the <see cref="T:System.IComparable"/> implementation of each element.</param>
            <returns><paramref name="keys"/> and <paramref name="items"/></returns>
        </member>
        <member name="M:KeepCoding.ArrayHelper.Sort(System.Array,System.Array)">
            <summary>
            Sorts a pair of one-dimensional <see cref="T:System.Array"/> objects (one contains the keys and the other contains the corresponding items) based on the keys in the first <see cref="T:System.Array"/> using the <see cref="T:System.IComparable"/> implementation of each key.
            </summary>
            <remarks><seealso href="https://docs.microsoft.com/en-us/dotnet/api/system.array.sort?view=net-5.0#System_Array_Sort_System_Array_System_Array_"/></remarks>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:System.RankException"></exception>
            <exception cref="T:System.ArgumentException"></exception>
            <exception cref="T:System.InvalidOperationException"></exception>
            <param name="keys">The one-dimensional <see cref="T:System.Array"/> that contains the keys to sort.</param>
            <param name="items">The one-dimensional <see cref="T:System.Array"/> that contains the items that correspond to each of the keys in the <paramref name="keys"/><see cref="T:System.Array"/> or <c>null</c> to sort only the <paramref name="keys"/><see cref="T:System.Array"/>.</param>
            <returns><paramref name="keys"/> and <paramref name="items"/></returns>
        </member>
        <member name="M:KeepCoding.ArrayHelper.Sort(System.Array)">
            <summary>
            Sorts the elements in an entire one-dimensional <see cref="T:System.Array"/> using the <see cref="T:System.IComparable"/> implementation of each element of the <see cref="T:System.Array"/>.
            </summary>
            <remarks><seealso href="https://docs.microsoft.com/en-us/dotnet/api/system.array.sort?view=net-5.0#System_Array_Sort_System_Array_"/></remarks>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:System.RankException"></exception>
            <exception cref="T:System.InvalidOperationException"></exception>
            <param name="array">The one-dimensional <see cref="T:System.Array"/> to sort.</param>
            <returns><paramref name="array"/></returns>
        </member>
        <member name="M:KeepCoding.ArrayHelper.Sort``1(``0[])">
            <summary>
            Sorts the elements in an entire <see cref="T:System.Array"/> using the <see cref="T:System.IComparable`1"/> generic interface implementation of each element of the <see cref="T:System.Array"/>.
            </summary>
            <remarks><seealso href="https://docs.microsoft.com/en-us/dotnet/api/system.array.sort?view=net-5.0#System_Array_Sort_System_Array_"/></remarks>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:System.InvalidOperationException"></exception>
            <typeparam name="T">The type of the elements of the array.</typeparam>
            <param name="array">The one-dimensional, zero-based Array to sort.</param>
            <returns><paramref name="array"/></returns>
        </member>
        <member name="M:KeepCoding.ArrayHelper.Sort``1(``0[],System.Collections.Generic.IComparer{``0})">
            <summary>
            Sorts the elements in an <see cref="T:System.Array"/> using the specified <see cref="T:System.Collections.Generic.IComparer`1"/> generic interface.
            </summary>
            <remarks><seealso href="https://docs.microsoft.com/en-us/dotnet/api/system.array.sort?view=net-5.0#System_Array_Sort__1___0___System_Collections_Generic_IComparer___0__"/></remarks>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:System.ArgumentException"></exception>
            <exception cref="T:System.InvalidOperationException"></exception>
            <typeparam name="T">The type of the elements of the array.</typeparam>
            <param name="array">The one-dimensional, zero-base <see cref="T:System.Array"/> to sort.</param>
            <param name="comparer">The <see cref="T:System.IComparable`1"/> generic interface implementation to use when comparing elements, or <c>null</c> to use the <see cref="T:System.IComparable`1"/> generic interface implementation of each element.</param>
            <returns><paramref name="array"/></returns>
        </member>
        <member name="M:KeepCoding.ArrayHelper.Sort``1(``0[],System.Comparison{``0})">
            <summary>
            Sorts the elements in an <see cref="T:System.Array"/> using the specified <see cref="T:System.Comparison`1"/>.
            </summary>
            <remarks><seealso href="https://docs.microsoft.com/en-us/dotnet/api/system.array.sort?view=net-5.0#System_Array_Sort__1___0___System_Comparison___0__"/></remarks>
            <exception cref="T:System.ArgumentException"></exception>
            <typeparam name="T">The type of the elements of the array.</typeparam>
            <param name="array">The one-dimensional, zero-based <see cref="T:System.Array"/> to sort.</param>
            <param name="comparison">The <see cref="T:System.Comparison`1"/> to use when comparing elements.</param>
            <returns><paramref name="array"/></returns>
        </member>
        <member name="M:KeepCoding.ArrayHelper.Sort``1(``0[],System.Int32,System.Int32)">
            <summary>
            Sorts the elements in a range of elements in an <see cref="T:System.Array"/> using the <see cref="T:System.IComparable`1"/> generic interface implementation of each element of the <see cref="T:System.Array"/>.
            </summary>
            <remarks><seealso href="https://docs.microsoft.com/en-us/dotnet/api/system.array.sort?view=net-5.0#System_Array_Sort__1___0___System_Int32_System_Int32_"/></remarks>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
            <exception cref="T:System.ArgumentException"></exception>
            <exception cref="T:System.InvalidOperationException"></exception>
            <typeparam name="T">The type of the elements of the array.</typeparam>
            <param name="array">The one-dimensional, zero-based <see cref="T:System.Array"/> to sort.</param>
            <param name="index">The starting index of the range to sort.</param>
            <param name="length">The number of elements in the range to sort.</param>
            <returns><paramref name="array"/></returns>
        </member>
        <member name="M:KeepCoding.ArrayHelper.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
            <summary>
            Sorts the elements in a range of elements in an <see cref="T:System.Array"/> using the specified <see cref="T:System.Collections.Generic.IComparer`1"/> generic interface.
            </summary>
            <remarks><seealso href="https://docs.microsoft.com/en-us/dotnet/api/system.array.sort?view=net-5.0#System_Array_Sort__1___0___System_Int32_System_Int32_System_Collections_Generic_IComparer___0__"/></remarks>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
            <exception cref="T:System.ArgumentException"></exception>
            <exception cref="T:System.InvalidOperationException"></exception>
            <typeparam name="T">The type of the elements of the array.</typeparam>
            <param name="array">The one-dimensional, zero-based <see cref="T:System.Array"/> to sort.</param>
            <param name="index">The starting index of the range to sort.</param>
            <param name="length">The number of elements in the range to sort.</param>
            <param name="comparer">The implementation to use when comparing elements or <c>null</c> to use the <see cref="T:System.IComparable"/> implementation of each element.</param>
            <returns><paramref name="array"/></returns>
        </member>
        <member name="M:KeepCoding.ArrayHelper.Sort``2(``0[],``1[])">
            <summary>
            Sorts a pair of <see cref="T:System.Array"/> objects (one contains the keys and the other contains the corresponding items) based on the keys in the first <see cref="T:System.Array"/> using the <see cref="T:System.IComparable`1"/> generic interface implementation of each key.
            </summary>
            <remarks><seealso href="https://docs.microsoft.com/en-us/dotnet/api/system.array.sort?view=net-5.0#System_Array_Sort__1___0___System_Collections_Generic_IComparer___0__"/></remarks>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:System.ArgumentException"></exception>
            <exception cref="T:System.InvalidOperationException"></exception>
            <typeparam name="TKey">The type of the elements of the key array.</typeparam>
            <typeparam name="TValue">The type of the elements of the items array.</typeparam>
            <param name="keys">The one-dimensional, zero-based <see cref="T:System.Array"/> that contains the keys to sort.</param>
            <param name="items">The one-dimensional, zero-based <see cref="T:System.Array"/> that contains the items that correspond to the keys in <paramref name="keys"/>, or <c>null</c> to sort only <paramref name="keys"/>.</param>
            <returns><paramref name="keys"/> and <paramref name="items"/></returns>
        </member>
        <member name="M:KeepCoding.ArrayHelper.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
            <summary>
            Sorts a pair of <see cref="T:System.Array"/> objects (one contains the keys and the other contains the corresponding items) based on the keys in the first <see cref="T:System.Array"/> using the specified <see cref="T:System.Collections.Generic.IComparer`1"/> generic interface.
            </summary>
            <remarks><seealso href="https://docs.microsoft.com/en-us/dotnet/api/system.array.sort?view=net-5.0#System_Array_Sort__2___0_____1___System_Collections_Generic_IComparer___0__"/></remarks>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:System.RankException"></exception>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
            <exception cref="T:System.ArgumentException"></exception>
            <exception cref="T:System.InvalidOperationException"></exception>
            <typeparam name="TKey">The type of the elements of the key array.</typeparam>
            <typeparam name="TValue">The type of the elements of the items array.</typeparam>
            <param name="keys">The one-dimensional, zero-based <see cref="T:System.Array"/> that contains the keys to sort.</param>
            <param name="items">The one-dimensional, zero-based <see cref="T:System.Array"/> that contains the items that correspond to the keys in <paramref name="keys"/>, or <c>null</c> to sort only <paramref name="keys"/>.</param>
            <param name="comparer">The <see cref="T:System.IComparable`1"/> generic interface implementation to use when comparing elements, or <c>null</c> to use the <see cref="T:System.IComparable`1"/> generic interface implementation of each element.</param>
            <returns><paramref name="keys"/> and <paramref name="items"/></returns>
        </member>
        <member name="M:KeepCoding.ArrayHelper.Sort``2(``0[],``1[],System.Int32,System.Int32)">
            <summary>
            Sorts a range of elements in a pair of <see cref="T:System.Array"/> objects (one contains the keys and the other contains the corresponding items) based on the keys in the first <see cref="T:System.Array"/> using the <see cref="T:System.IComparable`1"/> generic interface implementation of each key.
            </summary>
            <remarks><seealso href="https://docs.microsoft.com/en-us/dotnet/api/system.array.sort?view=net-5.0#System_Array_Sort__2___0_____1___System_Int32_System_Int32_"/></remarks>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
            <exception cref="T:System.ArgumentException"></exception>
            <exception cref="T:System.InvalidOperationException"></exception>
            <typeparam name="TKey">The type of the elements of the key array.</typeparam>
            <typeparam name="TValue">The type of the elements of the items array.</typeparam>
            <param name="keys">The one-dimensional, zero-based <see cref="T:System.Array"/> that contains the keys to sort.</param>
            <param name="items">The one-dimensional, zero-based <see cref="T:System.Array"/> that contains the items that correspond to the keys in <paramref name="keys"/>, or <c>null</c> to sort only <paramref name="keys"/>.</param>
            <param name="index">The starting index of the range to sort.</param>
            <param name="length">The number of elements in the range to sort.</param>
            <returns><paramref name="keys"/> and <paramref name="items"/></returns>
        </member>
        <member name="M:KeepCoding.ArrayHelper.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
            <summary>
            Sorts a range of elements in a pair of <see cref="T:System.Array"/> objects (one contains the keys and the other contains the corresponding items) based on the keys in the first <see cref="T:System.Array"/> using the specified <see cref="T:System.Collections.Generic.IComparer`1"/> generic interface.
            </summary>
            <remarks><seealso href="https://docs.microsoft.com/en-us/dotnet/api/system.array.sort?view=net-5.0#System_Array_Sort__2___0_____1___System_Int32_System_Int32_System_Collections_Generic_IComparer___0__"/></remarks>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:System.RankException"></exception>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
            <exception cref="T:System.ArgumentException"></exception>
            <exception cref="T:System.InvalidOperationException"></exception>
            <typeparam name="TKey">The type of the elements of the key array.</typeparam>
            <typeparam name="TValue">The type of the elements of the items array.</typeparam>
            <param name="keys">The one-dimensional, zero-based <see cref="T:System.Array"/> that contains the keys to sort.</param>
            <param name="items">The one-dimensional, zero-based <see cref="T:System.Array"/> that contains the items that correspond to the keys in <paramref name="keys"/>, or <c>null</c> to sort only <paramref name="keys"/>.</param>
            <param name="index">The starting index of the range to sort.</param>
            <param name="length">The number of elements in the range to sort.</param>
            <param name="comparer">The implementation to use when comparing elements or <c>null</c> to use the <see cref="T:System.IComparable"/> implementation of each element.</param>
            <returns><paramref name="keys"/> and <paramref name="items"/></returns>
        </member>
        <member name="M:KeepCoding.ArrayHelper.TrueForAll``1(``0[],System.Predicate{``0})">
            <summary>
            Determines whether every element in the array matches the conditions defined by the specified predicate.
            </summary>
            <remarks><seealso href="https://docs.microsoft.com/en-us/dotnet/api/system.array.trueforall?view=net-5.0"/></remarks>
            <exception cref="T:System.ArgumentNullException"></exception>
            <typeparam name="T">The type of the elements of the array.</typeparam>
            <param name="array">The one-dimensional, zero-based <see cref="T:System.Array"/> to check against the conditions.</param>
            <param name="match">The predicate that defines the conditions to check against the elements.</param>
            <returns><c>true</c> if every element in <paramref name="array"/> matches the conditions defined by the specified predicate; otherwise, <c>false</c>. If there are no elements in the array, the return value is <c>true</c>.</returns>
        </member>
        <member name="M:KeepCoding.ArrayHelper.Clone(System.Array)">
            <summary>
            Creates a shallow copy of the <see cref="T:System.Array"/>
            </summary>
            <remarks><seealso href="https://docs.microsoft.com/en-us/dotnet/api/system.array.clone?view=net-5.0"/></remarks>
            <param name="this"><c>this</c></param>
            <returns>A shallow copy of the <paramref name="this"/>.</returns>
        </member>
        <member name="M:KeepCoding.ArrayHelper.CopyTo(System.Array,System.Array,System.Int32)">
            <summary>
            Copies all the elements of the current one-dimensional array to the specified one-dimensional array starting at the specified destination array index. The index is specified as a 64-bit integer.
            </summary>
            <remarks><seealso href="https://docs.microsoft.com/en-us/dotnet/api/system.array.copyto?view=net-5.0#System_Array_CopyTo_System_Array_System_Int32_"/></remarks>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
            <exception cref="T:System.ArgumentException"></exception>
            <param name="this"><c>this</c></param>
            <param name="array">The one-dimensional array that is the destination of the elements copied from the current array.</param>
            <param name="index">A 32-bit integer that represents the index in <paramref name="array"/> at which copying begins.</param>
            <returns><paramref name="array"/></returns>
        </member>
        <member name="M:KeepCoding.ArrayHelper.CopyTo(System.Array,System.Array,System.Int64)">
            <summary>
            Copies all the elements of the current one-dimensional array to the specified one-dimensional array starting at the specified destination array index. The index is specified as a 64-bit integer.
            </summary>
            <remarks><seealso href="https://docs.microsoft.com/en-us/dotnet/api/system.array.copyto?view=net-5.0#System_Array_CopyTo_System_Array_System_Int32_"/></remarks>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
            <exception cref="T:System.ArgumentException"></exception>
            <param name="this"><c>this</c></param>
            <param name="array">The one-dimensional array that is the destination of the elements copied from the current array.</param>
            <param name="index">A 64-bit integer that represents the index in <paramref name="array"/> at which copying begins.</param>
            <returns><paramref name="array"/></returns>
        </member>
        <member name="M:KeepCoding.ArrayHelper.GetEnumerator(System.Array)">
            <summary>
            Returns an <see cref="T:System.Collections.IEnumerator"/> for the <see cref="T:System.Array"/>.
            </summary>
            <remarks><seealso href="https://docs.microsoft.com/en-us/dotnet/api/system.array.getenumerator?view=net-5.0"/></remarks>
            <param name="this"><c>this</c></param>
            <returns>An <see cref="T:System.Collections.IEnumerator"/> for the Array.</returns>
        </member>
        <member name="M:KeepCoding.ArrayHelper.GetLength(System.Array,System.Int32)">
            <summary>
            Gets a 32-bit integer that represents the number of elements in the specified dimension of the <see cref="T:System.Array"/>.
            </summary>
            <remarks><seealso href="https://docs.microsoft.com/en-us/dotnet/api/system.array.getlength?view=net-5.0"/></remarks>
            <exception cref="T:System.IndexOutOfRangeException"></exception>
            <param name="this"><c>this</c></param>
            <param name="dimension">A zero-based dimension of the <see cref="T:System.Array"/> whose length needs to be determined.</param>
            <returns>A 32-bit integer that represents the number of elements in the specified dimension.</returns>
        </member>
        <member name="M:KeepCoding.ArrayHelper.GetLongLength(System.Array,System.Int32)">
            <summary>
            Gets a 64-bit integer that represents the number of elements in the specified dimension of the <see cref="T:System.Array"/>.
            </summary>
            <remarks><seealso href="https://docs.microsoft.com/en-us/dotnet/api/system.array.getlonglength?view=net-5.0"/></remarks>
            <exception cref="T:System.IndexOutOfRangeException"></exception>
            <param name="this"><c>this</c></param>
            <param name="dimension">A zero-based dimension of the <see cref="T:System.Array"/> whose length needs to be determined.</param>
            <returns>A 64-bit integer that represents the number of elements in the specified dimension.</returns>
        </member>
        <member name="M:KeepCoding.ArrayHelper.GetLowerBound(System.Array,System.Int32)">
            <summary>
            Gets the index of the first element of the specified dimension in the array.
            </summary>
            <remarks><seealso href="https://docs.microsoft.com/en-us/dotnet/api/system.array.getlowerbound?view=net-5.0"/></remarks>
            <exception cref="T:System.IndexOutOfRangeException"></exception>
            <param name="this"><c>this</c></param>
            <param name="dimension">A zero-based dimension of the array whose starting index needs to be determined.</param>
            <returns>The index of the first element of the specified dimension in the array.</returns>
        </member>
        <member name="M:KeepCoding.ArrayHelper.GetUpperBound(System.Array,System.Int32)">
            <summary>
            Gets the index of the last element of the specified dimension in the array.
            </summary>
            <remarks><seealso href="https://docs.microsoft.com/en-us/dotnet/api/system.array.getupperbound?view=net-5.0"/></remarks>
            <exception cref="T:System.IndexOutOfRangeException"></exception>
            <param name="this"><c>this</c></param>
            <param name="dimension">A zero-based dimension of the array whose starting index needs to be determined.</param>
            <returns>The index of the first element of the specified dimension in the array.</returns>
        </member>
        <member name="M:KeepCoding.ArrayHelper.Get(System.Array,System.Int64,System.Int64,System.Int64)">
            <summary>
            Gets the value at the specified position in the three-dimensional <see cref="T:System.Array"/>. The indexes are specified as 64-bit integers.
            </summary>
            <remarks><seealso href="https://docs.microsoft.com/en-us/dotnet/api/system.array.getvalue?view=net-5.0#System_Array_GetValue_System_Int64_System_Int64_System_Int64_"/></remarks>
            <exception cref="T:System.ArgumentException"></exception>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
            <param name="this"><c>this</c></param>
            <param name="index1">A 64-bit integer that represents the first-dimension index of the <see cref="T:System.Array"/> element to get.</param>
            <param name="index2">A 64-bit integer that represents the second-dimension index of the <see cref="T:System.Array"/> element to get.</param>
            <param name="index3">A 64-bit integer that represents the third-dimension index of the <see cref="T:System.Array"/> element to get.</param>
            <returns>The value at the specified position in the three-dimensional <see cref="T:System.Array"/>.</returns>
        </member>
        <member name="M:KeepCoding.ArrayHelper.Get(System.Array,System.Int32,System.Int32,System.Int32)">
            <summary>
            Gets the value at the specified position in the three-dimensional <see cref="T:System.Array"/>. The indexes are specified as 32-bit integers.
            </summary>
            <remarks><seealso href="https://docs.microsoft.com/en-us/dotnet/api/system.array.getvalue?view=net-5.0#System_Array_GetValue_System_Int32_System_Int32_System_Int32_"/></remarks>
            <exception cref="T:System.ArgumentException"></exception>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
            <param name="this"><c>this</c></param>
            <param name="index1">A 32-bit integer that represents the first-dimension index of the <see cref="T:System.Array"/> element to get.</param>
            <param name="index2">A 32-bit integer that represents the second-dimension index of the <see cref="T:System.Array"/> element to get.</param>
            <param name="index3">A 32-bit integer that represents the third-dimension index of the <see cref="T:System.Array"/> element to get.</param>
            <returns>The value at the specified position in the three-dimensional <see cref="T:System.Array"/>.</returns>
        </member>
        <member name="M:KeepCoding.ArrayHelper.GetValue(System.Array,System.Int64,System.Int64)">
            <summary>
            Gets the value at the specified position in the two-dimensional <see cref="T:System.Array"/>. The indexes are specified as 64-bit integers.
            </summary>
            <remarks><seealso href="https://docs.microsoft.com/en-us/dotnet/api/system.array.getvalue?view=net-5.0#System_Array_GetValue_System_Int64_System_Int64_"/></remarks>
            <exception cref="T:System.ArgumentException"></exception>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
            <param name="this"><c>this</c></param>
            <param name="index1">A 64-bit integer that represents the first-dimension index of the <see cref="T:System.Array"/> element to get.</param>
            <param name="index2">A 64-bit integer that represents the second-dimension index of the <see cref="T:System.Array"/> element to get.</param>
            <returns>The value at the specified position in the two-dimensional <see cref="T:System.Array"/>.</returns>
        </member>
        <member name="M:KeepCoding.ArrayHelper.Get(System.Array,System.Int32,System.Int32)">
            <summary>
            Gets the value at the specified position in the two-dimensional <see cref="T:System.Array"/>. The indexes are specified as 32-bit integers.
            </summary>
            <remarks><seealso href="https://docs.microsoft.com/en-us/dotnet/api/system.array.getvalue?view=net-5.0#System_Array_GetValue_System_Int32_System_Int32_"/></remarks>
            <exception cref="T:System.ArgumentException"></exception>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
            <param name="this"><c>this</c></param>
            <param name="index1">A 32-bit integer that represents the first-dimension index of the <see cref="T:System.Array"/> element to get.</param>
            <param name="index2">A 32-bit integer that represents the second-dimension index of the <see cref="T:System.Array"/> element to get.</param>
            <returns>The value at the specified position in the two-dimensional <see cref="T:System.Array"/>.</returns>
        </member>
        <member name="M:KeepCoding.ArrayHelper.Get(System.Array,System.Int32)">
            <summary>
            Gets the value at the specified position in the one-dimensional <see cref="T:System.Array"/>. The indexes are specified as 32-bit integers.
            </summary>
            <remarks><seealso href="https://docs.microsoft.com/en-us/dotnet/api/system.array.getvalue?view=net-5.0#System_Array_GetValue_System_Int32_"/></remarks>
            <exception cref="T:System.ArgumentException"></exception>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
            <param name="this"><c>this</c></param>
            <param name="index">A 32-bit integer that represents the first-dimension index of the <see cref="T:System.Array"/> element to get.</param>
            <returns>The value at the specified position in the one-dimensional <see cref="T:System.Array"/>.</returns>
        </member>
        <member name="M:KeepCoding.ArrayHelper.Get(System.Array,System.Int64)">
            <summary>
            Gets the value at the specified position in the one-dimensional <see cref="T:System.Array"/>. The indexes are specified as 64-bit integers.
            </summary>
            <remarks><seealso href="https://docs.microsoft.com/en-us/dotnet/api/system.array.getvalue?view=net-5.0#System_Array_GetValue_System_Int64_"/></remarks>
            <exception cref="T:System.ArgumentException"></exception>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
            <param name="this"><c>this</c></param>
            <param name="index">A 64-bit integer that represents the first-dimension index of the <see cref="T:System.Array"/> element to get.</param>
            <returns>The value at the specified position in the one-dimensional <see cref="T:System.Array"/>.</returns>
        </member>
        <member name="M:KeepCoding.ArrayHelper.Get(System.Array,System.Int32[])">
            <summary>
            Gets the value at the specified position in the multidimensional <see cref="T:System.Array"/>. The indexes are specified as an array of 32-bit integers.
            </summary>
            <remarks><seealso href="https://docs.microsoft.com/en-us/dotnet/api/system.array.getvalue?view=net-5.0#System_Array_GetValue_System_Int32___"/></remarks>
            <exception cref="T:System.ArgumentException"></exception>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
            <param name="this"><c>this</c></param>
            <param name="indices">A one-dimensional array of 32-bit integers that represent the indexes specifying the position of the Array element to get.</param>
            <returns>The value at the specified position in the multidimensional <see cref="T:System.Array"/>.</returns>
        </member>
        <member name="M:KeepCoding.ArrayHelper.Get(System.Array,System.Int64[])">
            <summary>
            Gets the value at the specified position in the multidimensional <see cref="T:System.Array"/>. The indexes are specified as an array of 64-bit integers.
            </summary>
            <remarks><seealso href="https://docs.microsoft.com/en-us/dotnet/api/system.array.getvalue?view=net-5.0#System_Array_GetValue_System_Int64___"/></remarks>
            <exception cref="T:System.ArgumentException"></exception>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
            <param name="this"><c>this</c></param>
            <param name="indices">A one-dimensional array of 64-bit integers that represent the indexes specifying the position of the Array element to get.</param>
            <returns>The value at the specified position in the multidimensional <see cref="T:System.Array"/>.</returns>
        </member>
        <member name="M:KeepCoding.ArrayHelper.Initialize(System.Array)">
            <summary>
            Initializes every element of the value-type <see cref="T:System.Array"/> by calling the parameterless constructor of the value type.
            </summary>
            <remarks><seealso href="https://docs.microsoft.com/en-us/dotnet/api/system.array.initialize?view=net-5.0"/></remarks>
            <param name="this"><c>this</c></param>
            <returns><paramref name="this"/></returns>
        </member>
        <member name="M:KeepCoding.ArrayHelper.Set(System.Array,System.Object,System.Int32)">
            <summary>
            Sets a value to the element at the specified position in the one-dimensional Array. The index is specified as a 32-bit integer.
            </summary>
            <remarks><seealso href="https://docs.microsoft.com/en-us/dotnet/api/system.array.setvalue?view=net-5.0#System_Array_SetValue_System_Object_System_Int32_"/></remarks>
            <exception cref="T:System.ArgumentException"></exception>
            <exception cref="T:System.InvalidCastException"></exception>
            <exception cref="T:System.IndexOutOfRangeException"></exception>
            <param name="this"><c>this</c></param>
            <param name="value">The new value for the specified element.</param>
            <param name="index">A 32-bit integer that represents the position of the <see cref="T:System.Array"/> element to set.</param>
            <returns><paramref name="this"/></returns>
        </member>
        <member name="M:KeepCoding.ArrayHelper.Set(System.Array,System.Object,System.Int32[])">
            <summary>
            Sets a value to the element at the specified position in the multi-dimensional Array. The index is specified as a 32-bit integer.
            </summary>
            <remarks><seealso href="https://docs.microsoft.com/en-us/dotnet/api/system.array.setvalue?view=net-5.0#System_Array_SetValue_System_Object_System_Int32___"/></remarks>
            <exception cref="T:System.ArgumentException"></exception>
            <exception cref="T:System.InvalidCastException"></exception>
            <exception cref="T:System.IndexOutOfRangeException"></exception>
            <param name="this"><c>this</c></param>
            <param name="value">The new value for the specified element.</param>
            <param name="indices">A one-dimensional array of 32-bit integers that represent the indexes specifying the position of the element to set.</param>
            <returns><paramref name="this"/></returns>
        </member>
        <member name="M:KeepCoding.ArrayHelper.Set(System.Array,System.Object,System.Int64)">
            <summary>
            Sets a value to the element at the specified position in the one-dimensional Array. The index is specified as a 64-bit integer.
            </summary>
            <remarks><seealso href="https://docs.microsoft.com/en-us/dotnet/api/system.array.setvalue?view=net-5.0#System_Array_SetValue_System_Object_System_Int64_"/></remarks>
            <exception cref="T:System.ArgumentException"></exception>
            <exception cref="T:System.InvalidCastException"></exception>
            <exception cref="T:System.IndexOutOfRangeException"></exception>
            <param name="this"><c>this</c></param>
            <param name="value">The new value for the specified element.</param>
            <param name="index">A 64-bit integer that represents the position of the <see cref="T:System.Array"/> element to set.</param>
            <returns><paramref name="this"/></returns>
        </member>
        <member name="M:KeepCoding.ArrayHelper.Set(System.Array,System.Object,System.Int64[])">
            <summary>
            Sets a value to the element at the specified position in the multi-dimensional Array. The index is specified as a 64-bit integer.
            </summary>
            <remarks><seealso href="https://docs.microsoft.com/en-us/dotnet/api/system.array.setvalue?view=net-5.0#System_Array_SetValue_System_Object_System_Int64___"/></remarks>
            <exception cref="T:System.ArgumentException"></exception>
            <exception cref="T:System.InvalidCastException"></exception>
            <exception cref="T:System.IndexOutOfRangeException"></exception>
            <param name="this"><c>this</c></param>
            <param name="value">The new value for the specified element.</param>
            <param name="indices">A one-dimensional array of 64-bit integers that represent the indexes specifying the position of the element to set.</param>
            <returns><paramref name="this"/></returns>
        </member>
        <member name="M:KeepCoding.ArrayHelper.Set(System.Array,System.Object,System.Int32,System.Int32)">
            <summary>
            Sets a value to the element at the specified position in the two-dimensional Array. The index is specified as a 32-bit integer.
            </summary>
            <remarks><seealso href="https://docs.microsoft.com/en-us/dotnet/api/system.array.setvalue?view=net-5.0#System_Array_SetValue_System_Object_System_Int32_System_Int32_"/></remarks>
            <exception cref="T:System.ArgumentException"></exception>
            <exception cref="T:System.InvalidCastException"></exception>
            <exception cref="T:System.IndexOutOfRangeException"></exception>
            <param name="this"><c>this</c></param>
            <param name="value">The new value for the specified element.</param>
            <param name="index1">A 32-bit integer that represents the first-dimension index of the <see cref="T:System.Array"/> element to set.</param>
            <param name="index2">A 32-bit integer that represents the second-dimension index of the <see cref="T:System.Array"/> element to set.</param>
            <returns><paramref name="this"/></returns>
        </member>
        <member name="M:KeepCoding.ArrayHelper.Set(System.Array,System.Object,System.Int64,System.Int64)">
            <summary>
            Sets a value to the element at the specified position in the two-dimensional Array. The index is specified as a 64-bit integer.
            </summary>
            <remarks><seealso href="https://docs.microsoft.com/en-us/dotnet/api/system.array.setvalue?view=net-5.0#System_Array_SetValue_System_Object_System_Int64_System_Int64_"/></remarks>
            <exception cref="T:System.ArgumentException"></exception>
            <exception cref="T:System.InvalidCastException"></exception>
            <exception cref="T:System.IndexOutOfRangeException"></exception>
            <param name="this"><c>this</c></param>
            <param name="value">The new value for the specified element.</param>
            <param name="index1">A 64-bit integer that represents the first-dimension index of the <see cref="T:System.Array"/> element to set.</param>
            <param name="index2">A 64-bit integer that represents the second-dimension index of the <see cref="T:System.Array"/> element to set.</param>
            <returns><paramref name="this"/></returns>
        </member>
        <member name="M:KeepCoding.ArrayHelper.Set(System.Array,System.Object,System.Int32,System.Int32,System.Int32)">
            <summary>
            Sets a value to the element at the specified position in the three-dimensional Array. The index is specified as a 32-bit integer.
            </summary>
            <remarks><seealso href="https://docs.microsoft.com/en-us/dotnet/api/system.array.setvalue?view=net-5.0#System_Array_SetValue_System_Object_System_Int32_System_Int32_System_Int32_"/></remarks>
            <exception cref="T:System.ArgumentException"></exception>
            <exception cref="T:System.InvalidCastException"></exception>
            <exception cref="T:System.IndexOutOfRangeException"></exception>
            <param name="this"><c>this</c></param>
            <param name="value">The new value for the specified element.</param>
            <param name="index1">A 32-bit integer that represents the first-dimension index of the <see cref="T:System.Array"/> element to set.</param>
            <param name="index2">A 32-bit integer that represents the second-dimension index of the <see cref="T:System.Array"/> element to set.</param>
            <param name="index3">A 32-bit integer that represents the third-dimension index of the <see cref="T:System.Array"/> element to set.</param>
            <returns><paramref name="this"/></returns>
        </member>
        <member name="M:KeepCoding.ArrayHelper.Set(System.Array,System.Object,System.Int64,System.Int64,System.Int64)">
            <summary>
            Sets a value to the element at the specified position in the three-dimensional Array. The index is specified as a 64-bit integer.
            </summary>
            <remarks><seealso href="https://docs.microsoft.com/en-us/dotnet/api/system.array.setvalue?view=net-5.0#System_Array_SetValue_System_Object_System_Int64_System_Int64_System_Int64_"/></remarks>
            <exception cref="T:System.ArgumentException"></exception>
            <exception cref="T:System.InvalidCastException"></exception>
            <exception cref="T:System.IndexOutOfRangeException"></exception>
            <param name="this"><c>this</c></param>
            <param name="value">The new value for the specified element.</param>
            <param name="index1">A 64-bit integer that represents the first-dimension index of the <see cref="T:System.Array"/> element to set.</param>
            <param name="index2">A 64-bit integer that represents the second-dimension index of the <see cref="T:System.Array"/> element to set.</param>
            <param name="index3">A 64-bit integer that represents the third-dimension index of the <see cref="T:System.Array"/> element to set.</param>
            <returns><paramref name="this"/></returns>
        </member>
        <member name="T:KeepCoding.EventHelper">
            <summary>
            KMFramework extension methods that makes it easier to assign multiple events to a variable in one statement.
            </summary>
        </member>
        <member name="M:KeepCoding.EventHelper.Assign(KMBombInfo,System.Action,System.Action)">
            <summary>
            Assigns events specified into <paramref name="bombInfo"/>. Reassigning them will replace their values.
            </summary>
            <remarks>
            An event that is null will be skipped. This extension method simplifies all of the KMFramework events into Actions or Functions.
            </remarks>
            <exception cref="T:UnityEngine.UnassignedReferenceException"></exception>
            <param name="bombInfo">The bomb info instance to assign events to.</param>
            <param name="onBombExploded">Called when the bomb explodes.</param>
            <param name="onBombSolved">Called when the bomb is defused.</param>
        </member>
        <member name="M:KeepCoding.EventHelper.Assign(KMBombModule,System.Action,System.Action,System.Action)">
            <summary>
            Assigns events specified into <paramref name="bombModule"/>. Reassigning them will replace their values.
            </summary>
            <remarks>
            An event that is null will be skipped. This extension method simplifies all of the KMFramework events into Actions or Functions.
            </remarks>
            <param name="bombModule">The bomb instance to assign events to.</param>
            <param name="onActivate">Called when the lights turn on.</param>
            <param name="onPass">Called when the module is solved.</param>
            <param name="onStrike">Called when the module strikes.</param>
        </member>
        <member name="M:KeepCoding.EventHelper.Assign(KMGameInfo,System.Action{KMGameInfo.State},System.Action{System.Boolean},System.Action{System.Boolean})">
            <summary>
            Assigns events specified into <paramref name="gameInfo"/>. Reassigning them will replace their values.
            </summary>
            <remarks>
            An event that is null will be skipped. This extension method simplifies all of the KMFramework events into Actions.
            </remarks>
            <exception cref="T:UnityEngine.UnassignedReferenceException"></exception>
            <param name="gameInfo">The game info instance to assign events to.</param>
            <param name="onStateChange">Called when the state of the game changes.</param>
            <param name="onAlarmClockChange">Called when the alarm clock changes state, and passes in whether it's on or off.</param>
            <param name="onLightsChange">Called when the lights change state, and passes in whether it's on or off.</param>
        </member>
        <member name="M:KeepCoding.EventHelper.Assign(KMNeedyModule,System.Action,System.Action,System.Action,System.Action,System.Action,System.Action)">
            <summary>
            Assigns events specified into <paramref name="needyModule"/>. Reassigning them will replace their values.
            </summary>
            <remarks>
            An event that is null will be skipped. This extension method simplifies all of the KMFramework events into Actions or Functions.
            </remarks>
            <param name="needyModule">The needy instance to assign events to.</param>
            <param name="onActivate">Called when the lights turn on.</param>
            <param name="onNeedyActivation">Called when the needy activates.</param>
            <param name="onNeedyDeactivation">Called when the needy deactivates.</param>
            <param name="onPass">Called when the needy is solved.</param>
            <param name="onStrike">Called when the needy strikes.</param>
            <param name="onTimerExpired">Called when the timer runs out of time.</param>
        </member>
        <member name="M:KeepCoding.EventHelper.StopSound(KMAudio.KMAudioRef[])">
            <summary>
            Stops all sounds for the entire <see cref="T:KMAudio.KMAudioRef"/> <see cref="T:System.Array"/>.
            </summary>
            <param name="audioRefs">The <see cref="T:KMAudio.KMAudioRef"/> <see cref="T:System.Array"/> to mute all sounds from, using <see cref="F:KMAudio.KMAudioRef.StopSound"/>.</param>
        </member>
        <member name="M:KeepCoding.EventHelper.StopSound(KeepCoding.Sound[])">
            <summary>
            Stops all sounds for the entire <see cref="T:KeepCoding.Sound"/> <see cref="T:System.Array"/>.
            </summary>
            <param name="sounds">The <see cref="T:KeepCoding.Sound"/> <see cref="T:System.Array"/> to mute all sounds from, using <see cref="F:KMAudio.KMAudioRef.StopSound"/>.</param>
        </member>
        <member name="M:KeepCoding.EventHelper.Combine(System.Action,System.Action[])">
            <summary>
            Combines actions together, only if these actions are not <see langword="null"/>.
            </summary>
            <param name="self">The action to modify.</param>
            <param name="others">The actions to combine with <paramref name="self"/>.</param>
            <returns><paramref name="self"/> with <paramref name="others"/> appended.</returns>
        </member>
        <member name="M:KeepCoding.EventHelper.Combine``1(System.Action{``0},System.Action{``0}[])">
            <summary>
            Combines actions together, only if these actions are not <see langword="null"/>.
            </summary>
            <param name="self">The action to modify.</param>
            <param name="others">The actions to combine with <paramref name="self"/>.</param>
            <returns><paramref name="self"/> with <paramref name="others"/> appended.</returns>
        </member>
        <member name="M:KeepCoding.EventHelper.Combine``2(System.Action{``0,``1},System.Action{``0,``1}[])">
            <summary>
            Combines actions together, only if these actions are not <see langword="null"/>.
            </summary>
            <param name="self">The action to modify.</param>
            <param name="others">The actions to combine with <paramref name="self"/>.</param>
            <returns><paramref name="self"/> with <paramref name="others"/> appended.</returns>
        </member>
        <member name="M:KeepCoding.EventHelper.Combine``3(System.Action{``0,``1,``2},System.Action{``0,``1,``2}[])">
            <summary>
            Combines actions together, only if these actions are not <see langword="null"/>.
            </summary>
            <param name="self">The action to modify.</param>
            <param name="others">The actions to combine with <paramref name="self"/>.</param>
            <returns><paramref name="self"/> with <paramref name="others"/> appended.</returns>
        </member>
        <member name="M:KeepCoding.EventHelper.Combine``4(System.Action{``0,``1,``2,``3},System.Action{``0,``1,``2,``3}[])">
            <summary>
            Combines actions together, only if these actions are not <see langword="null"/>.
            </summary>
            <param name="self">The action to modify.</param>
            <param name="others">The actions to combine with <paramref name="self"/>.</param>
            <returns><paramref name="self"/> with <paramref name="others"/> appended.</returns>
        </member>
        <member name="M:KeepCoding.EventHelper.Set``1(System.Delegate,``0@)">
            <summary>
            Adds a <see cref="T:System.Delegate"/> onto the referenced variable.
            </summary>
            <exception cref="T:System.ArgumentException"></exception>
            <exception cref="T:System.ArgumentNullException"></exception>
            <typeparam name="T">The type of the <paramref name="mutator"/> and <see cref="T:System.Delegate"/> casting.</typeparam>
            <param name="dele">The <see cref="T:System.Delegate"/> to add.</param>
            <param name="mutator">The variable that transmutates and adds <paramref name="dele"/> onto itself.</param>
            <returns><paramref name="mutator"/> with the value <paramref name="dele"/>, or itself if <paramref name="dele"/> is null.</returns>
        </member>
        <member name="M:KeepCoding.EventHelper.Cast``1(System.Delegate)">
            <summary>
            Casts a <see cref="T:System.Delegate"/> onto the type <typeparamref name="T"/>.
            </summary>
            <remarks>
            Both types must have the same parameter and return types, and the <paramref name="dele"/> argument cannot have its <see cref="P:System.Delegate.Target"/> or <see cref="P:System.Delegate.Method"/> be null.
            </remarks>
            <exception cref="T:System.ArgumentException"></exception>
            <exception cref="T:System.ArgumentNullException"></exception>
            <typeparam name="T">The type to cast the delegate into.</typeparam>
            <param name="dele">The delegate to cast.</param>
            <returns><paramref name="dele"/> as <typeparamref name="T"/>.</returns>
        </member>
        <member name="M:KeepCoding.EventHelper.CreateDelegate``1(System.Delegate)">
            <summary>
            Creates a delegate of the specified type.
            </summary>
            <typeparam name="T">The type of delegate to create.</typeparam>
            <param name="dele">The delegate to reference from.</param>
            <returns>A delegate of type <typeparamref name="T"/> using <paramref name="dele"/>'s target and method.</returns>
        </member>
        <member name="M:KeepCoding.EventHelper.Combine``1(System.Func{``0},System.Func{``0}[])">
            <summary>
            Combines actions together, only if these functions are not <see langword="null"/>.
            </summary>
            <param name="self">The function to modify.</param>
            <param name="others">The functions to combine with <paramref name="self"/>.</param>
            <returns><paramref name="self"/> with <paramref name="others"/> appended.</returns>
        </member>
        <member name="M:KeepCoding.EventHelper.Combine``2(System.Func{``0,``1},System.Func{``0,``1}[])">
            <summary>
            Combines actions together, only if these functions are not <see langword="null"/>.
            </summary>
            <param name="self">The function to modify.</param>
            <param name="others">The functions to combine with <paramref name="self"/>.</param>
            <returns><paramref name="self"/> with <paramref name="others"/> appended.</returns>
        </member>
        <member name="M:KeepCoding.EventHelper.Combine``3(System.Func{``0,``1,``2},System.Func{``0,``1,``2}[])">
            <summary>
            Combines actions together, only if these functions are not <see langword="null"/>.
            </summary>
            <param name="self">The function to modify.</param>
            <param name="others">The functions to combine with <paramref name="self"/>.</param>
            <returns><paramref name="self"/> with <paramref name="others"/> appended.</returns>
        </member>
        <member name="M:KeepCoding.EventHelper.Combine``4(System.Func{``0,``1,``2,``3},System.Func{``0,``1,``2,``3}[])">
            <summary>
            Combines actions together, only if these functions are not <see langword="null"/>.
            </summary>
            <param name="self">The function to modify.</param>
            <param name="others">The functions to combine with <paramref name="self"/>.</param>
            <returns><paramref name="self"/> with <paramref name="others"/> appended.</returns>
        </member>
        <member name="M:KeepCoding.EventHelper.Combine``5(System.Func{``0,``1,``2,``3,``4},System.Func{``0,``1,``2,``3,``4}[])">
            <summary>
            Combines actions together, only if these functions are not <see langword="null"/>.
            </summary>
            <param name="self">The function to modify.</param>
            <param name="others">The functions to combine with <paramref name="self"/>.</param>
            <returns><paramref name="self"/> with <paramref name="others"/> appended.</returns>
        </member>
        <member name="T:KeepCoding.Helper">
            <summary>
            General extension class covering both KMFramework and native datatypes.
            </summary>
        </member>
        <member name="F:KeepCoding.Helper.Flags">
            <summary>
            Contains the most commonly used flags, use this as a "catch-all" expression.
            </summary>
        </member>
        <member name="F:KeepCoding.Helper.Alphanumeric">
            <summary>
            The entire alphanumeric series, also known as base-62. From 0-9, A-Z, a-z.
            </summary>
        </member>
        <member name="F:KeepCoding.Helper.Decimal">
            <summary>
            The entire decimal series, also known as base-10. From 0-9.
            </summary>
        </member>
        <member name="F:KeepCoding.Helper.Binary">
            <summary>
            The entire binary series, also known as base-2. From 0-1.
            </summary>
        </member>
        <member name="M:KeepCoding.Helper.HasComponent``1(UnityEngine.GameObject,``0@)">
            <summary>
            Determines if the current game object has a component of a specific type.
            </summary>
            <remarks>
            This uses <see cref="M:UnityEngine.GameObject.GetComponent``1"/>, meaning that the component must be part of the same game object for this to return true.
            </remarks>
            <typeparam name="T">The type of component to find.</typeparam>
            <param name="obj">The game object to search with.</param>
            <param name="component">The variable to store the component in.</param>
            <returns>True if a component has been found of type <typeparamref name="T"/> from <paramref name="obj"/>.</returns>
        </member>
        <member name="M:KeepCoding.Helper.ImplementsMethod``1(``0,System.String,System.Reflection.BindingFlags)">
            <summary>
            Determines if a <see langword="class"/> implements a given method.
            </summary>
            <typeparam name="T">The <see cref="T:System.Type"/> to check all <see cref="T:System.Reflection.MethodInfo"/>s.</typeparam>
            <param name="_">The discard to get the <see cref="T:System.Type"/>.</param>
            <param name="method">The method to get.</param>
            <param name="flags">The <see cref="T:System.Reflection.BindingFlags"/> to use in <see cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)"/>.</param>
            <returns><see langword="true"/> if <typeparamref name="T"/> has <paramref name="method"/>.</returns>
        </member>
        <member name="M:KeepCoding.Helper.ImplementsMethod``1(System.String,System.Reflection.BindingFlags)">
            <summary>
            Determines if a <see langword="class"/> implements a given method.
            </summary>
            <typeparam name="T">The <see cref="T:System.Type"/> to check all <see cref="T:System.Reflection.MethodInfo"/>s.</typeparam>
            <param name="method">The method to get.</param>
            <param name="flags">The <see cref="T:System.Reflection.BindingFlags"/> to use in <see cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)"/>.</param>
            <returns><see langword="true"/> if <typeparamref name="T"/> has <paramref name="method"/>.</returns>
        </member>
        <member name="M:KeepCoding.Helper.ImplementsMethod(System.Type,System.String,System.Reflection.BindingFlags)">
            <summary>
            Determines if a <see langword="class"/> implements a given method.
            </summary>
            <typeparam name="T">The <see cref="T:System.Type"/> to check all <see cref="T:System.Reflection.MethodInfo"/>s.</typeparam>
            <param name="type">The type to check.</param>
            <param name="method">The method to get.</param>
            <param name="flags">The <see cref="T:System.Reflection.BindingFlags"/> to use in <see cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)"/>.</param>
            <returns><see langword="true"/> if <typeparamref name="T"/> has <paramref name="method"/>.</returns>
        </member>
        <member name="M:KeepCoding.Helper.IsBetween(System.Int32,System.Int32,System.Int32)">
            <summary>
            Determines whether the number is equal or in-between 2 values.
            </summary>
            <param name="comparison">The number to use as comparison.</param>
            <param name="min">The minimum value required to return true.</param>
            <param name="max">The maximum value required to return true.</param>
            <returns>True if <paramref name="comparison"/> is more than or equal <paramref name="min"/> and less than or equal <paramref name="max"/>.</returns>
        </member>
        <member name="M:KeepCoding.Helper.IsBetween(System.Int32,KeepCoding.Tuple{System.Int32,System.Int32})">
            <summary>
            Determines whether the number is equal or in-between a tuple's <see cref="P:KeepCoding.Tuple`1.Item1"/> (minimum) and <see cref="P:KeepCoding.Tuple`2.Item2"/> (maximum).
            </summary>
            <param name="comparison">The number to use as comparison.</param>
            <param name="range">The minimum and maximum value required to return true.</param>
            <returns>True if <paramref name="comparison"/> is more than or equal <see cref="P:KeepCoding.Tuple`1.Item1"/> and less than or equal <see cref="P:KeepCoding.Tuple`2.Item2"/>.</returns>
        </member>
        <member name="M:KeepCoding.Helper.IsBetween(System.Single,System.Single,System.Single)">
            <summary>
            Determines whether the number is equal or in-between 2 values.
            </summary>
            <param name="comparison">The number to use as comparison.</param>
            <param name="min">The minimum value required to return true.</param>
            <param name="max">The maximum value required to return true.</param>
            <returns>True if <paramref name="comparison"/> is more than or equal <paramref name="min"/> and less than or equal <paramref name="max"/>.</returns>
        </member>
        <member name="M:KeepCoding.Helper.IsBetween(System.Single,KeepCoding.Tuple{System.Single,System.Single})">
            <summary>
            Determines whether the number is equal or in-between a tuple's <see cref="P:KeepCoding.Tuple`1.Item1"/> (minimum) and <see cref="P:KeepCoding.Tuple`2.Item2"/> (maximum).
            </summary>
            <param name="comparison">The number to use as comparison.</param>
            <param name="range">The minimum and maximum value required to return true.</param>
            <returns>True if <paramref name="comparison"/> is more than or equal <see cref="P:KeepCoding.Tuple`1.Item1"/> and less than or equal <see cref="P:KeepCoding.Tuple`2.Item2"/>.</returns>
        </member>
        <member name="M:KeepCoding.Helper.IsIndexNull``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
            <summary>
            Determines if the index is pointing to null in any way.
            </summary>
            <param name="source">The array to index with.</param>
            <param name="index">The index.</param>
            <returns>True if <paramref name="source"/> is null, if <paramref name="index"/> is out of range, or if the element is null.</returns>
        </member>
        <member name="M:KeepCoding.Helper.IsIterator``1(``0)">
            <summary>
            Determines if the item is an iterator type.
            </summary>
            <param name="item">The item to check the type for.</param>
            <returns><paramref name="item"/> is either <see cref="T:System.String"/>, <see cref="T:System.Collections.IEnumerable"/>, or <see cref="T:System.Collections.IEnumerator"/>.</returns>
        </member>
        <member name="M:KeepCoding.Helper.IsNullOrEmpty(System.String)">
            <summary>
            Determines if the string is null or empty.
            </summary>
            <param name="str">The string to check for.</param>
            <returns>True if <paramref name="str"/> is equal to null, or empty.</returns>
        </member>
        <member name="M:KeepCoding.Helper.IsNullOrEmpty``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Determines if the <see cref="T:System.Collections.Generic.IEnumerable`1"/> is null or empty.
            </summary>
            <param name="source">The <see cref="T:System.Collections.Generic.IEnumerable`1"/> to check for.</param>
            <returns>True if <paramref name="source"/> is equal to null, or empty.</returns>
        </member>
        <member name="M:KeepCoding.Helper.IsNullOrEmpty``1(System.Collections.Generic.IEnumerator{``0})">
            <summary>
            Determines if the <see cref="T:System.Collections.Generic.IEnumerator`1"/> is null or empty.
            </summary>
            <param name="source">The <see cref="T:System.Collections.Generic.IEnumerable`1"/> to check for.</param>
            <returns>True if <paramref name="source"/> is equal to null, or empty.</returns>
        </member>
        <member name="M:KeepCoding.Helper.IsParent(KMSelectable)">
            <summary>
            Determines if the <see cref="T:KMSelectable"/> is a parent of another <see cref="T:KMSelectable"/>.
            </summary>
            <param name="kmSelectable">This is required to check the children field.</param>
            <returns>True if <see cref="F:KMSelectable.Children"/> is empty.</returns>
        </member>
        <member name="M:KeepCoding.Helper.RandomBoolean(System.Single)">
            <summary>
            Generates a random boolean.
            </summary>
            <remarks>
            As this uses <see cref="T:UnityEngine.Random"/>, you may not use this in a constructor. Use it in <c>Awake()</c> or <c>Start()</c> in that case.
            </remarks>
            <param name="weighting">The odds of the boolean being true.</param>
            <returns>A random boolean, with probability based off of <paramref name="weighting"/>.</returns>
        </member>
        <member name="M:KeepCoding.Helper.RandomBooleans(System.Int32,System.Single)">
            <summary>
            Creates an <see cref="T:System.Array"/> of random boolean values.
            </summary>
            <remarks>
            As this uses <see cref="T:UnityEngine.Random"/>, you may not use this in a constructor. Use it in <c>Awake()</c> or <c>Start()</c> in that case.
            </remarks>
            <param name="length">The length of the array.</param>
            <param name="weighting">The odds of the boolean being true.</param>
            <returns>An array of random booleans of length <paramref name="length"/>, with probability based off of <paramref name="weighting"/>.</returns>
            <returns></returns>
        </member>
        <member name="M:KeepCoding.Helper.ToNumber(System.Char)">
            <summary>
            Converts a character to a number.
            </summary>
            <exception cref="T:KeepCoding.Internal.UnrecognizedValueException"></exception>
            <param name="source">The character to convert.</param>
            <returns><paramref name="source"/> as <see cref="T:System.Byte"/>.</returns>
        </member>
        <member name="M:KeepCoding.Helper.ToLower(System.Char)">
            <summary>
            Converts a character to lowercase.
            </summary>
            <param name="source">The character to convert.</param>
            <returns><paramref name="source"/> as lowercase.</returns>
        </member>
        <member name="M:KeepCoding.Helper.ToUpper(System.Char)">
            <summary>
            Converts a character to uppercase.
            </summary>
            <param name="source">The character to convert.</param>
            <returns><paramref name="source"/> as uppercase.</returns>
        </member>
        <member name="M:KeepCoding.Helper.DigitalRoot(System.Int32)">
            <summary>
            Gets the digital root of the number, which is obtained by repeatedly getting the sum of all digits until 1 digit remains.
            </summary>
            <param name="number">The number to get the digital root of.</param>
            <returns>The digital root of <paramref name="number"/>.</returns>
        </member>
        <member name="M:KeepCoding.Helper.GetUpperBound(System.String)">
            <summary>
            Returns the last index of the string.
            </summary>
            <param name="str">The string to check length for.</param>
            <returns><see cref="P:System.String.Length"/> - 1</returns>
        </member>
        <member name="M:KeepCoding.Helper.GetUpperBound``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Returns the last index of the <see cref="T:System.Collections.Generic.IEnumerable`1"/>.
            </summary>
            <param name="source">The <see cref="T:System.Collections.Generic.IEnumerable`1"/> to check length for.</param>
            <returns><paramref name="source"/>.Count() - 1</returns>
        </member>
        <member name="M:KeepCoding.Helper.LengthOrDefault``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Returns the length of the <see cref="T:System.Collections.Generic.IEnumerable`1"/>, or if null, the default value 0.
            </summary>
            <param name="source">The <see cref="T:System.Collections.Generic.IEnumerable`1"/> to check its length.</param>
            <returns><paramref name="source"/>'s length, or 0.</returns>
        </member>
        <member name="M:KeepCoding.Helper.MemberCount``1">
            <summary>
            Counts the number of members in an enum.
            </summary>
            <typeparam name="T">The enum to check the length for.</typeparam>
            <returns>The number of members in <typeparamref name="T"/>.</returns>
        </member>
        <member name="M:KeepCoding.Helper.Modulo(System.Int32,System.Int32)">
            <summary>
            Calculates the rem-euclid modulo, which allows negative numbers to be properly calculated.
            </summary>
            <param name="number">The left-hand side operator</param>
            <param name="modulo">The right-hand side operator.</param>
            <returns><paramref name="number"/> mod <paramref name="modulo"/>.</returns>
        </member>
        <member name="M:KeepCoding.Helper.SetOrReplace``1(System.Collections.Generic.IDictionary{``0,System.Int32},``0,System.Func{System.Int32,System.Int32})">
            <summary>
            Sets or replaces the value of a dictionary with a given function.
            </summary>
            <exception cref="T:KeepCoding.Internal.NullIteratorException"></exception>
            <exception cref="T:System.NullReferenceException"></exception>
            <typeparam name="T">Type of the key of the dictionary.</typeparam>
            <param name="source">Dictionary to operate on.</param>
            <param name="key">Key at which the list is located in the dictionary.</param>
            <param name="func">The function that returns the new value.</param>
            <returns>The new value at the specified key.</returns>
        </member>
        <member name="M:KeepCoding.Helper.Ranges(System.Int32,System.Int32,System.Int32)">
            <summary>
            Generates a random set of integers.
            </summary>
            <remarks>
            As this uses <see cref="T:UnityEngine.Random"/>, you may not use this in a constructor. Use it in <c>Awake()</c> or <c>Start()</c> in that case.
            </remarks>
            <param name="length">The length of the array.</param>
            <param name="min">The minimum value for each index. (inclusive)</param>
            <param name="max">The maximum value for each index. (exclusive)</param>
            <returns>Random integer array of length <paramref name="length"/> between <paramref name="min"/> and <paramref name="max"/>.</returns>
        </member>
        <member name="M:KeepCoding.Helper.Ranges(System.Int32,KeepCoding.Tuple{System.Int32,System.Int32})">
            <summary>
            Generates a random set of integers.
            </summary>
            <remarks>
            As this uses <see cref="T:UnityEngine.Random"/>, you may not use this in a constructor. Use it in <c>Awake()</c> or <c>Start()</c> in that case.
            </remarks>
            <param name="length">The length of the array.</param>
            <param name="range">The minimum (inclusive) and maximum (exclusive) values.</param>
            <returns>Random integer array of length <paramref name="length"/> between <paramref name="range"/>'s values.</returns>
        </member>
        <member name="M:KeepCoding.Helper.ToNumbers``1(``0[],System.Nullable{System.Int32},System.Nullable{System.Int32},System.Nullable{System.Int32},System.Nullable{System.Int32})">
            <summary>
            Parses each element of an array into a number. If it succeeds it returns the integer array, if it fails then it returns null.
            </summary>
            <param name="ts">The array to convert to an integer.</param>
            <param name="min">The minimum acceptable value of any given index. (inclusive)</param>
            <param name="max">The maximum acceptable value of any given index. (inclusive)</param>
            <param name="minLength">The minimum acceptable length of the array. (inclusive)</param>
            <param name="maxLength">The maximum acceptable length of the array. (inclusive)</param>
            <returns>The array as integers, or null if it fails.</returns>
        </member>
        <member name="M:KeepCoding.Helper.BaseToLong(System.String,System.Int32)">
            <summary>
            Converts any base number to any base-10.
            </summary>
            <param name="value">The value to convert.</param>
            <param name="baseNumber">Which base it currently is.</param>
            <returns>The integer, but in the base specified.</returns>
        </member>
        <member name="M:KeepCoding.Helper.BaseToLong(System.String,System.String)">
            <summary>
            Converts any base number to base-10.
            </summary>
            <exception cref="T:System.FormatException"></exception>
            <exception cref="T:KeepCoding.Internal.NullIteratorException"></exception>
            <param name="value">The value to convert.</param>
            <param name="baseChars">All of the base characters for the conversion from the base number, use <see cref="F:KeepCoding.Helper.Alphanumeric"/> for Base-62, use <see cref="F:KeepCoding.Helper.Decimal"/> for Base-10, use <see cref="F:KeepCoding.Helper.Binary"/> for Base-2. The length of the array is the base number.</param>
            <returns><paramref name="value"/>, but in the base specified.</returns>
        </member>
        <member name="M:KeepCoding.Helper.Modulo(System.Single,System.Single)">
            <summary>
            Calculates the rem-euclid modulo, which allows negative numbers to be properly calculated.
            </summary>
            <param name="number">The left-hand side operator</param>
            <param name="modulo">The right-hand side operator.</param>
            <returns><paramref name="number"/> mod <paramref name="modulo"/>.</returns>
        </member>
        <member name="M:KeepCoding.Helper.Ranges(System.Int32,System.Single,System.Single)">
            <summary>
            Generates a random set of floats.
            </summary>
            <remarks>
            As this uses <see cref="T:UnityEngine.Random"/>, you may not use this in a constructor. Use it in <c>Awake()</c> or <c>Start()</c> in that case.
            </remarks>
            <param name="length">The length of the array.</param>
            <param name="min">The minimum value for each index. (inclusive)</param>
            <param name="max">The maximum value for each index. (inclusive)</param>
            <returns>Random float array of length <paramref name="length"/> between <paramref name="min"/> and <paramref name="max"/>.</returns>
        </member>
        <member name="M:KeepCoding.Helper.Ranges(System.Int32,KeepCoding.Tuple{System.Single,System.Single})">
            <summary>
            Generates a random set of integers.
            </summary>
            <remarks>
            As this uses <see cref="T:UnityEngine.Random"/>, you may not use this in a constructor. Use it in <c>Awake()</c> or <c>Start()</c> in that case.
            </remarks>
            <param name="length">The length of the array.</param>
            <param name="range">The minimum (inclusive) and maximum (exclusive) values.</param>
            <returns>Random integer array of length <paramref name="length"/> between <paramref name="range"/>'s values.</returns>
        </member>
        <member name="M:KeepCoding.Helper.Base(System.String,System.String,System.String)">
            <summary>
            Converts any base number to any base.
            </summary>a
            <param name="value">The value to convert.</param>
            <param name="fromBaseChars">All of the base characters for the conversion from the base number, use <see cref="F:KeepCoding.Helper.Alphanumeric"/> for Base-62, use <see cref="F:KeepCoding.Helper.Decimal"/> for Base-10, use <see cref="F:KeepCoding.Helper.Binary"/> for Base-2. The length of the array is the base number.</param>
            <param name="toBaseChars">All of the base characters for the conversion to the base number, use <see cref="F:KeepCoding.Helper.Alphanumeric"/> for Base-62, use <see cref="F:KeepCoding.Helper.Decimal"/> for Base-10, use <see cref="F:KeepCoding.Helper.Binary"/> for Base-2. The length of the array is the base number.</param>
            <returns><paramref name="value"/>, but in the base specified.</returns>
        </member>
        <member name="M:KeepCoding.Helper.Base(System.String,System.Int32,System.Int32)">
            <summary>
            Converts any base number to any base.
            </summary>
            <param name="value">The value to convert.</param>
            <param name="fromBaseNumber">Which base it currently is.</param>
            <param name="toBaseNumber">Which base to convert it to.</param>
            <returns>The integer, but in the base specified.</returns>
        </member>
        <member name="M:KeepCoding.Helper.Find(System.Collections.Generic.List{System.String},System.String)">
            <summary>
            Finds a file name within a list of directories, or <see langword="null"/> if none is found.
            </summary>
            <param name="directories">The list of directories.</param>
            <param name="file">The file to search for.</param>
            <returns>The directory containing the path to the file searched for, or <see langword="null"/>.</returns>
        </member>
        <member name="M:KeepCoding.Helper.Form(System.String,System.Object[])">
            <summary>
            Formats the string. Shorthand for <see cref="M:System.String.Format(System.String,System.Object[])"/>.
            </summary>
            <param name="str">The string to format. Typically with placeholders involving {0}, {1}, {2}...</param>
            <param name="args">All of the arguments to put into <paramref name="str"/>.</param>
            <returns>The formatted <see cref="T:System.String"/>.</returns>
        </member>
        <member name="M:KeepCoding.Helper.InsertNewlines(System.String,System.UInt16)">
            <summary>
            Replaces whitespace characters with line breaks based on the line length.
            </summary>
            <remarks>
            This can be useful to prevent a <see cref="T:UnityEngine.TextMesh"/> from going outside its boundaries. A monospaced font is recommended in this case.
            </remarks>
            <param name="condition">The string to insert line breaks with.</param>
            <param name="maxLineLength">The maximum number of characters in one line.</param>
            <returns><paramref name="condition"/> with a line break every <paramref name="maxLineLength"/> or less characters.</returns>
        </member>
        <member name="M:KeepCoding.Helper.LongToBase(System.Int64,System.String)">
            <summary>
            Converts any base-10 number to any base.
            </summary>
            <exception cref="T:KeepCoding.Internal.NullIteratorException"></exception>
            <param name="value">The value to convert.</param>
            <param name="baseChars">All of the base characters for the conversion to the base number, use <see cref="F:KeepCoding.Helper.Alphanumeric"/> for Base-62, use <see cref="F:KeepCoding.Helper.Decimal"/> for Base-10, use <see cref="F:KeepCoding.Helper.Binary"/> for Base-2. The length of the array is the base number.</param>
            <returns><paramref name="value"/>, but in the base specified.</returns>
        </member>
        <member name="M:KeepCoding.Helper.LongToBase(System.Int64,System.Int32)">
            <summary>
            Converts any base-10 number to any base.
            </summary>
            <param name="value">The value to convert.</param>
            <param name="baseNumber">Which base to convert it to.</param>
            <returns>The integer, but in the base specified.</returns>
        </member>
        <member name="M:KeepCoding.Helper.NullOrEmptyCheck(System.String,System.String)">
            <summary>
            Throws an exception if the <see cref="T:System.String"/> is null or empty.
            </summary>
            <exception cref="T:KeepCoding.Internal.NullIteratorException"></exception>
            <exception cref="T:KeepCoding.Internal.EmptyIteratorException"></exception>
            <param name="source">The string to check for null and empty.</param>
            <param name="message">The optional message to throw if null or empty. Leaving it default will throw a default message.</param>
        </member>
        <member name="M:KeepCoding.Helper.Reverse(System.String)">
            <summary>
            Reverses a string.
            </summary>
            <exception cref="T:System.NullReferenceException"></exception>
            <param name="source">The string to reverse.</param>
            <returns><paramref name="source"/> where contents are oredered backwards.</returns>
        </member>
        <member name="M:KeepCoding.Helper.Split(System.String,System.String)">
            <summary>
            Splits the <see cref="T:System.String"/> based on the separator.
            </summary>
            <param name="source">The <see cref="T:System.String"/> of characters to split by.</param>
            <param name="separator">The separator to split <paramref name="source"/> by.</param>
            <returns>An <see cref="T:System.Array"/> where each index is where <paramref name="separator"/> was found in <paramref name="source"/>.</returns>
        </member>
        <member name="M:KeepCoding.Helper.ToOrdinal(System.Int32)">
            <summary>
            Converts a number to the ordinal as <see cref="T:System.String"/>.
            </summary>
            <param name="i">The number to convert to an ordinal.</param>
            <returns><paramref name="i"/> as an ordinal. (<see cref="T:System.String"/>)</returns>
        </member>
        <member name="M:KeepCoding.Helper.UnwrapToString``1(``0,System.Boolean,System.String)">
            <summary>
            Unwraps any object, whether it be a class, list, tuple, or any other data and concatenates it into a string.
            </summary>
            <param name="item">The object to unwrap.</param>
            <param name="getVariables">Whether it should search recursively inside the variable and yield return the elements inside <paramref name="item"/>.</param>
            <param name="delimiter">The characters in-between each element.</param>
            <returns>A string consisting of all values from <paramref name="item"/>.</returns>
        </member>
        <member name="M:KeepCoding.Helper.Unwrap``1(``0,System.Boolean)">
            <summary>
            Unwraps any object, whether it be a class, list, tuple, or any other data.
            </summary>
            <param name="source">The object to unwrap.</param>
            <param name="isRecursive">Whether it should search inside the variable and yield return the elements inside <paramref name="source"/>.</param>
            <returns>An <see cref="T:System.Object"/> <see cref="T:System.Array"/> of all elements within <paramref name="source"/>.</returns>
        </member>
        <member name="M:KeepCoding.Helper.Method(UnityEngine.LogType)">
            <summary>
            Gets the appropriate log method depending on the type of <see cref="T:UnityEngine.LogType"/>.
            </summary>
            <param name="logType">The type of method to get.</param>
            <returns>The log method representing the enum <paramref name="logType"/>.</returns>
        </member>
        <member name="M:KeepCoding.Helper.Modulo(System.Object,KeepCoding.BigInteger)">
            <summary>
            Calculates the rem-euclid modulo, which allows negative numbers to be properly calculated.
            </summary>
            <param name="item">The left-hand side operator.</param>
            <param name="bigInteger">The right-hand side operator.</param>
            <returns>Itself mod <paramref name="bigInteger"/>.</returns>
        </member>
        <member name="M:KeepCoding.Helper.Stop(UnityEngine.MonoBehaviour,UnityEngine.Coroutine[])">
            <summary>
            Stops the coroutines only if they aren't <see langword="null"/>.
            </summary>
            <param name="monoBehaviour">The <see cref="T:UnityEngine.MonoBehaviour"/> instance needed to stop coroutines.</param>
            <param name="coroutines">The <see cref="T:UnityEngine.Coroutine"/>s to stop.</param>
            <returns>The array of <see cref="T:UnityEngine.Coroutine"/>s given.</returns>
        </member>
        <member name="M:KeepCoding.Helper.GetNullException``1(``0)">
            <summary>
            Gets the appropriate <see cref="T:System.Exception"/> based on the data type.
            </summary>
            <param name="item">The item to check the type for.</param>
            <returns><see cref="T:KeepCoding.Internal.NullIteratorException"/> if <paramref name="item"/> is an iterator, evaluated with <see cref="M:KeepCoding.Helper.IsIterator``1(``0)"/>, otherwise <see cref="T:System.NullReferenceException"/></returns>
        </member>
        <member name="M:KeepCoding.Helper.AsEnumerable(System.Collections.IEnumerator)">
            <summary>
            Converts an <see cref="T:System.Collections.IEnumerator"/> to an <see cref="T:System.Collections.IEnumerable"/>.
            </summary>
            <exception cref="T:KeepCoding.Internal.NullIteratorException"></exception>
            <param name="source">The <see cref="T:System.Collections.IEnumerator"/> to convert.</param>
            <returns><paramref name="source"/> as an <see cref="T:System.Collections.IEnumerable"/>.</returns>
        </member>
        <member name="M:KeepCoding.Helper.AsEnumerable``1(System.Collections.Generic.IEnumerator{``0})">
            <summary>
            Converts an <see cref="T:System.Collections.IEnumerator"/> to an <see cref="T:System.Collections.IEnumerable"/>.
            </summary>
            <exception cref="T:KeepCoding.Internal.NullIteratorException"></exception>
            <typeparam name="T">The parameter and return type.</typeparam>
            <param name="source">The <see cref="T:System.Collections.IEnumerator"/> to convert.</param>
            <returns><paramref name="source"/> as an <see cref="T:System.Collections.IEnumerable"/>.</returns>
        </member>
        <member name="M:KeepCoding.Helper.Append``1(System.Collections.Generic.IEnumerable{``0},``0)">
            <summary>
            Appends the element provided to the <see cref="T:System.Collections.Generic.IEnumerable`1"/>.
            </summary>
            <typeparam name="T">The datatype of both the <see cref="T:System.Collections.Generic.IEnumerable`1"/> and element.</typeparam>
            <param name="source">The <see cref="T:System.Collections.Generic.IEnumerable`1"/> to be modified.</param>
            <param name="item">The element to append to the <paramref name="source"/>.</param>
            <returns><paramref name="source"/>, but with an added <paramref name="item"/> as the last index.</returns>
        </member>
        <member name="M:KeepCoding.Helper.Exclude``1(System.Collections.Generic.IEnumerable{``0},System.Int32[])">
            <summary>
            Removes the elements whose index matches any of the indices.
            </summary>
            <typeparam name="T">The datatype of both the <see cref="T:System.Collections.Generic.IEnumerable`1"/>.</typeparam>
            <param name="source">The <see cref="T:System.Collections.Generic.IEnumerable`1"/> to be modified.</param>
            <param name="indices">The indices to exclude from <paramref name="source"/>.</param>
            <returns><paramref name="source"/>, but without the element indexing <paramref name="indices"/>.</returns>
        </member>
        <member name="M:KeepCoding.Helper.ReflectAll``1(``0)">
            <summary>
            Gets all fields and properties of the item using reflection.
            </summary>
            <param name="source">The item to get all fields and properties.</param>
            <returns>All fields and properties of <paramref name="source"/>.</returns>
        </member>
        <member name="M:KeepCoding.Helper.Include``1(System.Collections.Generic.IEnumerable{``0},System.Int32[])">
            <summary>
            Removes the elements whose index does not match any of the indices.
            </summary>
            <typeparam name="T">The datatype of both the <see cref="T:System.Collections.Generic.IEnumerable`1"/>.</typeparam>
            <param name="source">The <see cref="T:System.Collections.Generic.IEnumerable`1"/> to be modified.</param>
            <param name="indices">The indices to include in <paramref name="source"/>.</param>
            <returns><paramref name="source"/>, but without the element indexing <paramref name="indices"/>.</returns>
        </member>
        <member name="M:KeepCoding.Helper.Indistinct``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Filters an <see cref="T:System.Collections.Generic.IEnumerable`1"/>, only allowing duplicated items.
            </summary>
            <typeparam name="T">The type of the <see cref="T:System.Collections.Generic.IEnumerable`1"/>.</typeparam>
            <param name="source">The <see cref="T:System.Collections.Generic.IEnumerable`1"/> to filter through.</param>
            <returns>A new instance of <paramref name="source"/> that only includes elements which are repeated in the array.</returns>
        </member>
        <member name="M:KeepCoding.Helper.NullOrEmptyCheck``1(System.Collections.Generic.IEnumerable{``0},System.String)">
            <summary>
            Throws an exception if the <see cref="T:System.Collections.Generic.IEnumerable`1"/> is null or empty.
            </summary>
            <exception cref="T:KeepCoding.Internal.NullIteratorException"></exception>
            <exception cref="T:KeepCoding.Internal.EmptyIteratorException"></exception>
            <param name="source">The <see cref="T:System.Array"/> to check for null and empty.</param>
            <param name="message">The optional message to throw if null or empty. Leaving it default will throw a default message.</param>
        </member>
        <member name="M:KeepCoding.Helper.Prepend``1(System.Collections.Generic.IEnumerable{``0},``0)">
            <summary>
            Prepends the element provided to the <see cref="T:System.Collections.Generic.IEnumerable`1"/>.
            </summary>
            <typeparam name="T">The datatype of both the <see cref="T:System.Collections.Generic.IEnumerable`1"/>.</typeparam>
            <param name="source">The <see cref="T:System.Collections.Generic.IEnumerable`1"/> to be modified.</param>
            <param name="item">The element to append to the <paramref name="source"/>.</param>
            <returns><paramref name="source"/>, but with an added <paramref name="item"/> as the first index.</returns>
        </member>
        <member name="M:KeepCoding.Helper.Randomize``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Shuffles a collection of items using <see cref="T:UnityEngine.Random"/>.
            </summary>
            <typeparam name="T">The type of <see cref="T:System.Collections.Generic.IEnumerable`1"/> to shuffle.</typeparam>
            <param name="source">The <see cref="T:System.Collections.Generic.IEnumerable`1"/> to shuffle.</param>
            <returns><paramref name="source"/> in a random order.</returns>
        </member>
        <member name="M:KeepCoding.Helper.Randomize``1(System.Collections.Generic.IEnumerable{``0},System.Random)">
            <summary>
            Shuffles a collection of items using a specified <see cref="T:System.Random"/>.
            </summary>
            <typeparam name="T">The type of <see cref="T:System.Collections.Generic.IEnumerable`1"/> to shuffle.</typeparam>
            <param name="source">The <see cref="T:System.Collections.Generic.IEnumerable`1"/> to shuffle.</param>
            <param name="rng">The <see cref="T:System.Random"/> to generate numbers by.</param>
            <returns><paramref name="source"/> in a random order.</returns>
        </member>
        <member name="M:KeepCoding.Helper.Randomize``1(System.Collections.Generic.IEnumerable{``0},System.Func{System.Int32,System.Int32,System.Int32})">
            <summary>
            Shuffles a collection of items using a user-specified algorithm.
            </summary>
            <typeparam name="T">The type of <see cref="T:System.Collections.Generic.IEnumerable`1"/> to shuffle.</typeparam>
            <param name="source">The <see cref="T:System.Collections.Generic.IEnumerable`1"/> to shuffle.</param>
            <param name="randomizer">The method to take the current and maximum indices, and return a new number to swap the current with.</param>
            <returns><paramref name="source"/> in a random order.</returns>
        </member>
        <member name="M:KeepCoding.Helper.Replace``1(System.Collections.Generic.IEnumerable{``0},System.Int32,``0)">
            <summary>
            Replaces an index in the <see cref="T:System.Collections.Generic.IEnumerable`1"/> and returns the new one.
            </summary>
            <exception cref="T:KeepCoding.Internal.NullIteratorException"></exception>
            <typeparam name="T">The type of the <see cref="T:System.Collections.IEnumerable"/>.</typeparam>
            <param name="source">The initial source.</param>
            <param name="index">The index to change.</param>
            <param name="value">The value to replace at <paramref name="source"/>'s <paramref name="index"/> element.</param>
            <returns><paramref name="source"/> but the <paramref name="index"/> element is <paramref name="value"/> instead.</returns>
        </member>
        <member name="M:KeepCoding.Helper.Slice``1(System.Collections.Generic.IEnumerable{``0},System.Int32,System.Int32)">
            <summary>
            Returns a slice of an <see cref="T:System.Collections.Generic.IEnumerable`1"/>.
            </summary>
            <exception cref="T:KeepCoding.Internal.NullIteratorException"></exception>
            <typeparam name="T">The type of the <paramref name="source"/> and return type.</typeparam>
            <param name="source">The <see cref="T:System.Collections.Generic.IEnumerable`1"/> to take a slice of.</param>
            <param name="start">The starting index of the slice.</param>
            <param name="count">The amount of items to take.</param>
            <returns>A slice of <paramref name="source"/> based on <paramref name="start"/> and <paramref name="count"/>.</returns>
        </member>
        <member name="M:KeepCoding.Helper.SplitEvery``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
            <summary>
            Chops the <see cref="T:System.Collections.Generic.IEnumerable`1"/> into multiple <see cref="T:System.Collections.Generic.IEnumerable`1"/>s, based on the length provided.
            </summary>
            <exception cref="T:System.ArgumentException"></exception>
            <exception cref="T:System.NullReferenceException"></exception>
            <typeparam name="T">The type of <paramref name="source"/>.</typeparam>
            <param name="source">The <see cref="T:System.Collections.Generic.IEnumerable`1"/> to split.</param>
            <param name="length">The length of each <see cref="T:System.Collections.Generic.IEnumerable`1"/> within the containing <see cref="T:System.Collections.Generic.IEnumerable`1"/>.</param>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1"/> of <see cref="T:System.Collections.Generic.IEnumerable`1"/>s, where each <see cref="T:System.Collections.Generic.IEnumerable`1"/> is as long as <paramref name="length"/>.</returns>
        </member>
        <member name="M:KeepCoding.Helper.NullOrEmptyCheck``1(System.Collections.Generic.IEnumerator{``0},System.String)">
            <summary>
            Throws an exception if the <see cref="T:System.Collections.Generic.IEnumerator`1"/> is null or empty.
            </summary>
            <exception cref="T:KeepCoding.Internal.NullIteratorException"></exception>
            <exception cref="T:KeepCoding.Internal.EmptyIteratorException"></exception>
            <param name="source">The string to check for null and empty.</param>
            <param name="message">The optional message to throw if null or empty. Leaving it default will throw a default message.</param>
        </member>
        <member name="M:KeepCoding.Helper.Unwrap(System.Collections.IEnumerable,System.Boolean)">
            <summary>
            Unwraps any <see cref="T:System.Collections.IEnumerable"/> of type <see cref="T:System.Object"/>, which ends up flattening it as a <see cref="T:System.Array"/> of type <see cref="T:System.Object"/>.
            </summary>
            <param name="source">The object to unwrap.</param>
            <param name="isRecursive">Whether it should search inside the variable and yield return the elements inside <paramref name="source"/>.</param>
            <returns>An <see cref="T:System.Object"/> <see cref="T:System.Array"/> of all elements within <paramref name="source"/>.</returns>
        </member>
        <member name="M:KeepCoding.Helper.Flatten(System.Collections.IEnumerator,System.Predicate{System.Object})">
            <summary>
            Flattens an <see cref="T:System.Collections.IEnumerator"/> such that nested <see cref="T:System.Collections.IEnumerator"/> calls get replaced with the output of those calls.
            </summary>
            <param name="source">The <see cref="T:System.Collections.IEnumerator"/> to flatten.</param>
            <param name="unwrap">Determines if it should call <see cref="M:KeepCoding.Helper.Unwrap``1(``0,System.Boolean)"/> for the item.</param>
            <returns><paramref name="source"/> where <see langword="yield"/> <see langword="return"/> <see cref="T:System.Collections.IEnumerator"/>s gets replaced with the output of those calls.</returns>
        </member>
        <member name="M:KeepCoding.Helper.GetUnsolvedModuleIDs(KMBombInfo)">
            <summary>
            Gives list of module names that are unsolved.
            </summary>
            <param name="bombInfo">The instance of <see cref="T:KMBombInfo"/> needed to get the modules.</param>
            <returns>A list of unsolved module names.</returns>
        </member>
        <member name="M:KeepCoding.Helper.GetUnsolvedModuleNames(KMBombInfo)">
            <summary>
            Gives list of module names that are unsolved.
            </summary>
            <param name="bombInfo">The instance of <see cref="T:KMBombInfo"/> needed to get the modules.</param>
            <returns>A list of unsolved modules.</returns>
        </member>
        <member name="M:KeepCoding.Helper.Rev``1(System.Collections.Generic.List{``0})">
            <summary>
            Reverses a list and returns the new list.
            </summary>
            <exception cref="T:KeepCoding.Internal.NullIteratorException"></exception>
            <typeparam name="T">The type of the list.</typeparam>
            <param name="source">The list to reverse.</param>
            <returns><paramref name="source"/> with the elements reversed.</returns>
        </member>
        <member name="M:KeepCoding.Helper.GetMethodInfo``1(System.Linq.Expressions.Expression{System.Action{``0}})">
            <summary>
            Gets the method info from an expression.
            </summary>
            <typeparam name="T">The type of the action.</typeparam>
            <param name="expression">The expression that retrieves the method.</param>
            <returns>The method info of the function.</returns>
        </member>
        <member name="M:KeepCoding.Helper.SplitBy``1(System.Collections.Generic.IEnumerable{``0},System.Predicate{``0})">
            <summary>
            Splits an <see cref="T:System.Collections.IEnumerable"/> in two based on a method provided.
            </summary>
            <typeparam name="T">The type of the collection.</typeparam>
            <param name="source">The collection to split.</param>
            <param name="predicate">The method that decides where the item ends up.</param>
            <returns>A <see cref="T:KeepCoding.Tuple`2"/> consisting of items from <paramref name="source"/> where <see cref="P:KeepCoding.Tuple`1.Item1"/> contains items that returned true in <paramref name="predicate"/>, and <see cref="P:KeepCoding.Tuple`2.Item2"/> otherwise.</returns>
        </member>
        <member name="M:KeepCoding.Helper.Assert``1(``0,System.String)">
            <summary>
            Throws a <see cref="T:UnityEngine.MissingComponentException"/> if the <see cref="T:UnityEngine.Object"/> given is <see langword="null"/>, then returning the <see cref="T:UnityEngine.Object"/> <paramref name="obj"/>.
            </summary>
            <typeparam name="T">The type of <see cref="T:UnityEngine.Object"/>.</typeparam>
            <param name="obj">The <see cref="T:UnityEngine.Object"/> to do a null check on.</param>
            <param name="message">The message of the exception.</param>
            <returns>The component <paramref name="obj"/>.</returns>
        </member>
        <member name="M:KeepCoding.Helper.Call``1(``0,System.Action{``0})">
            <summary>
            Invokes a method of <typeparamref name="T"/> and then returns the argument provided.
            </summary>
            <remarks>
            This can be used to intercept current variables or calculations by for example, printing the value as it is being passed as an argument.
            </remarks>
            <typeparam name="T">The type of <paramref name="item"/> and <paramref name="action"/>.</typeparam>
            <param name="item">The item to use as reference and modify.</param>
            <param name="action">The action to apply <paramref name="item"/> to.</param>
            <returns>The item <paramref name="item"/>.</returns>
        </member>
        <member name="M:KeepCoding.Helper.Call``1(``0,UnityEngine.LogType)">
            <summary>
            Invokes a logging method and then returns the argument provided.
            </summary>
            <typeparam name="T">The type of logging.</typeparam>
            <param name="item">The item to log</param>
            <param name="logType">The type of logging.</param>
            <returns>The item <paramref name="item"/>.</returns>
        </member>
        <member name="M:KeepCoding.Helper.ElementAtWrap``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
            <summary>
            Returns the element of an array, pretending that the array wraps around or is circular.
            </summary>
            <exception cref="T:KeepCoding.Internal.NullIteratorException"></exception>
            <exception cref="T:KeepCoding.Internal.EmptyIteratorException"></exception>
            <typeparam name="T">The type of the array.</typeparam>
            <param name="source">The array itself.</param>
            <param name="index">The index, which will wrap around if it's larger than the array.</param>
            <returns>The element in <paramref name="source"/> using <paramref name="index"/> with rem-euclid modulo.</returns>
        </member>
        <member name="M:KeepCoding.Helper.FirstValue``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``0})">
            <summary>
            Returns the first element which doesn't return null, or null if all of them return null.
            </summary>
            <exception cref="T:KeepCoding.Internal.NullIteratorException"></exception>
            <exception cref="T:System.NullReferenceException"></exception>
            <typeparam name="T">The type of array, and method.</typeparam>
            <param name="source">The array to iterate on.</param>
            <param name="func">The method which returns</param>
            <returns>The first value from <paramref name="source"/> where <paramref name="func"/> doesn't return null, or null.</returns>
        </member>
        <member name="M:KeepCoding.Helper.LastValue``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``0})">
            <summary>
            Returns the last element which doesn't return null, or null if all of them return null.
            </summary>
            <exception cref="T:KeepCoding.Internal.NullIteratorException"></exception>
            <exception cref="T:System.NullReferenceException"></exception>
            <typeparam name="T">The type of array, and method.</typeparam>
            <param name="source">The array to iterate on.</param>
            <param name="func">The method which returns</param>
            <returns>The last value from <paramref name="source"/> where <paramref name="func"/> doesn't return null, or null.</returns>
        </member>
        <member name="M:KeepCoding.Helper.NullCheck``1(``0,System.String)">
            <summary>
            Throws a <see cref="T:System.NullReferenceException"/> or <see cref="T:KeepCoding.Internal.NullIteratorException"/> if the parameter provided is null.
            </summary>
            <exception cref="T:KeepCoding.Internal.NullIteratorException"></exception>
            <exception cref="T:System.NullReferenceException"></exception>
            <typeparam name="T">The type of the value.</typeparam>
            <param name="item">The parameter to check null for.</param>
            <param name="message">The optional message to throw if null.</param>
            <returns><paramref name="item"/></returns>
        </member>
        <member name="M:KeepCoding.Helper.Apply``2(``0,System.Func{``0,``1})">
            <summary>
            Invokes a method of <typeparamref name="TInput"/> to <typeparamref name="TOutput"/> and then returns the argument provided.
            </summary>
            <remarks>
            This can be used to intercept current variables or calculations by for example, printing the value as it is being passed as an argument.
            </remarks>
            <typeparam name="TInput">The type of <paramref name="item"/>.</typeparam>
            <typeparam name="TOutput">The type to return.</typeparam>
            <param name="item">The item to use as reference and modify.</param>
            <param name="func">The function to apply <paramref name="item"/> to.</param>
            <returns>The item <paramref name="item"/> after <paramref name="func"/>.</returns>
        </member>
        <member name="M:KeepCoding.Helper.Append``1(``0[],``0)">
            <summary>
            Appends the element provided to the array.
            </summary>
            <typeparam name="T">The datatype of both the array and element.</typeparam>
            <param name="array">The array to be appended with.</param>
            <param name="item">The element to append to the <paramref name="array"/>.</param>
            <returns><paramref name="array"/>, but with an added <paramref name="item"/> as the last index.</returns>
        </member>
        <member name="M:KeepCoding.Helper.Call``1(``0[],System.Action{``0,System.Int32})">
            <summary>
            Invokes a method of <typeparamref name="T"/> and then returns the argument provided.
            </summary>
            <remarks>
            This can be used to intercept current variables or calculations by for example, printing the value as it is being passed as an argument.
            </remarks>
            <exception cref="T:KeepCoding.Internal.NullIteratorException"></exception>
            <typeparam name="T">The type of <paramref name="source"/> and <paramref name="action"/>.</typeparam>
            <param name="source">The item to use as reference and modify.</param>
            <param name="action">The action to apply <paramref name="source"/> to.</param>
            <returns>The item <paramref name="source"/>.</returns>
        </member>
        <member name="M:KeepCoding.Helper.GetValues``1">
            <summary>
            Gets all the values of an <see cref="T:System.Enum"/> as an <see cref="T:System.Array"/>.
            </summary>
            <typeparam name="T">The type of <see cref="T:System.Enum"/>.</typeparam>
            <returns>An <see cref="T:System.Array"/> of <typeparamref name="T"/> containing all the values of that enum.</returns>
        </member>
        <member name="M:KeepCoding.Helper.GetValues``1(``0)">
            <summary>
            Gets all the values of an <see cref="T:System.Enum"/> as an <see cref="T:System.Array"/>.
            </summary>
            <typeparam name="T">The type of <see cref="T:System.Enum"/>.</typeparam>
            <param name="_">A discard value, which can implicitly let the method know the type.</param>
            <returns>An <see cref="T:System.Array"/> of <typeparamref name="T"/> containing all the values of that enum.</returns>
        </member>
        <member name="M:KeepCoding.Helper.Prepend``1(``0[],``0)">
            <summary>
            Prepends the element provided to the array.
            </summary>
            <typeparam name="T">The datatype of both the array and element.</typeparam>
            <param name="array">The array to be appended with.</param>
            <param name="item">The element to append to the <paramref name="array"/>.</param>
            <returns><paramref name="array"/>, but with an added <paramref name="item"/> as the first index.</returns>
        </member>
        <member name="M:KeepCoding.Helper.Apply``2(``0[],System.Func{``0,System.Int32,``1})">
            <summary>
            Invokes a method of <typeparamref name="TInput"/> to <typeparamref name="TOutput"/> and then returns the argument provided.
            </summary>
            <remarks>
            This can be used to intercept current variables or calculations by for example, printing the value as it is being passed as an argument.
            </remarks>
            <typeparam name="TInput">The type of <paramref name="items"/>.</typeparam>
            <typeparam name="TOutput">The type to return.</typeparam>
            <param name="items">The item to use as reference and modify.</param>
            <param name="func">The function to apply <paramref name="items"/> to.</param>
            <returns>The item <paramref name="items"/> after <paramref name="func"/>.</returns>
        </member>
        <member name="T:KeepCoding.KeyHelper">
            <summary>
            Inline methods for when typically key words are used.
            </summary>
        </member>
        <member name="M:KeepCoding.KeyHelper.As``1(System.Object)">
            <summary>
            The <see langword="as"/> operator explicitly converts the result of an expression to a given reference or nullable value type. If the conversion is not possible, the <see langword="as"/> operator returns <see langword="null"/>. Unlike a cast expression, the <see langword="as"/> operator never throws an exception.
            </summary>
            <remarks>
            <seealso href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/operators/type-testing-and-cast#as-operator"/>
            </remarks>
            <typeparam name="T">The type to cast the object into.</typeparam>
            <param name="obj">The object to cast into.</param>
            <returns><paramref name="obj"/> <see langword="as"/> <typeparamref name="T"/></returns>
        </member>
        <member name="M:KeepCoding.KeyHelper.Catch(System.Action,System.Action{System.Exception},System.Action,System.Type[])">
            <summary>
            The try-catch statement consists of a <see langword="try"/> block followed by one or more <see langword="catch"/> clauses, which specify handlers for different exceptions.
            </summary>
            <remarks>
            <seealso href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/try-catch"/>
            </remarks>
            <exception cref="T:System.NullReferenceException"></exception>
            <param name="action">The action to try.</param>
            <param name="caught">The action to run when an exception is caught.</param>
            <param name="final">The action to run on either clause.</param>
            <param name="exceptions">The types of exceptions to catch.</param>
        </member>
        <member name="M:KeepCoding.KeyHelper.Catch``1(System.Action,System.Action{System.Exception},System.Action)">
            <summary>
            The try-catch statement consists of a <see langword="try"/> block followed by one or more <see langword="catch"/> clauses, which specify handlers for different exceptions.
            </summary>
            <remarks>
            <seealso href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/try-catch"/>
            </remarks>
            <exception cref="T:System.NullReferenceException"></exception>
            <typeparam name="T">The type to catch.</typeparam>
            <param name="action">The action to try.</param>
            <param name="caught">The action to run when an exception is caught.</param>
            <param name="final">The action to run on either clause.</param>
        </member>
        <member name="M:KeepCoding.KeyHelper.Catch``2(System.Action,System.Action{System.Exception},System.Action)">
            <summary>
            The try-catch statement consists of a <see langword="try"/> block followed by one or more <see langword="catch"/> clauses, which specify handlers for different exceptions.
            </summary>
            <remarks>
            <seealso href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/try-catch"/>
            </remarks>
            <exception cref="T:System.NullReferenceException"></exception>
            <typeparam name="T1">The first type to catch.</typeparam>
            <typeparam name="T2">The second type to catch.</typeparam>
            <param name="action">The action to try.</param>
            <param name="caught">The action to run when an exception is caught.</param>
            <param name="final">The action to run on either clause.</param>
        </member>
        <member name="M:KeepCoding.KeyHelper.Catch``3(System.Action,System.Action{System.Exception},System.Action)">
            <summary>
            The try-catch statement consists of a <see langword="try"/> block followed by one or more <see langword="catch"/> clauses, which specify handlers for different exceptions.
            </summary>
            <remarks>
            <seealso href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/try-catch"/>
            </remarks>
            <exception cref="T:System.NullReferenceException"></exception>
            <typeparam name="T1">The first type to catch.</typeparam>
            <typeparam name="T2">The second type to catch.</typeparam>
            <typeparam name="T3">The third type to catch.</typeparam>
            <param name="action">The action to try.</param>
            <param name="caught">The action to run when an exception is caught.</param>
            <param name="final">The action to run on either clause.</param>
        </member>
        <member name="M:KeepCoding.KeyHelper.Catch``4(System.Action,System.Action{System.Exception},System.Action)">
            <summary>
            The try-catch statement consists of a <see langword="try"/> block followed by one or more <see langword="catch"/> clauses, which specify handlers for different exceptions.
            </summary>
            <remarks>
            <seealso href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/try-catch"/>
            </remarks>
            <exception cref="T:System.NullReferenceException"></exception>
            <typeparam name="T1">The first type to catch.</typeparam>
            <typeparam name="T2">The second type to catch.</typeparam>
            <typeparam name="T3">The third type to catch.</typeparam>
            <typeparam name="T4">The fourth type to catch.</typeparam>
            <param name="action">The action to try.</param>
            <param name="caught">The action to run when an exception is caught.</param>
            <param name="final">The action to run on either clause.</param>
        </member>
        <member name="M:KeepCoding.KeyHelper.Catch``1(System.Func{``0},System.Func{System.Exception,``0},System.Type[])">
            <summary>
            The try-catch statement consists of a <see langword="try"/> block followed by one or more <see langword="catch"/> clauses, which specify handlers for different exceptions.
            </summary>
            <remarks>
            <seealso href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/try-catch"/>
            </remarks>
            <exception cref="T:System.NullReferenceException"></exception>
            <typeparam name="T">The return type.</typeparam>
            <param name="action">The action to try.</param>
            <param name="caught">The action to run when an exception is caught.</param>
            <param name="exceptions">The types of exceptions to catch.</param>
        </member>
        <member name="M:KeepCoding.KeyHelper.Catch``2(System.Func{``1},System.Func{System.Exception,``1})">
            <summary>
            The try-catch statement consists of a <see langword="try"/> block followed by one or more <see langword="catch"/> clauses, which specify handlers for different exceptions.
            </summary>
            <remarks>
            <seealso href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/try-catch"/>
            </remarks>
            <exception cref="T:System.NullReferenceException"></exception>
            <typeparam name="T">The type to catch.</typeparam>
            <typeparam name="TResult">The return type.</typeparam>
            <param name="action">The action to try.</param>
            <param name="caught">The action to run when an exception is caught.</param>
        </member>
        <member name="M:KeepCoding.KeyHelper.Catch``3(System.Func{``2},System.Func{System.Exception,``2})">
            <summary>
            The try-catch statement consists of a <see langword="try"/> block followed by one or more <see langword="catch"/> clauses, which specify handlers for different exceptions.
            </summary>
            <remarks>
            <seealso href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/try-catch"/>
            </remarks>
            <exception cref="T:System.NullReferenceException"></exception>
            <typeparam name="T1">The first type to catch.</typeparam>
            <typeparam name="T2">The second type to catch.</typeparam>
            <typeparam name="TResult">The return type.</typeparam>
            <param name="action">The action to try.</param>
            <param name="caught">The action to run when an exception is caught.</param>
        </member>
        <member name="M:KeepCoding.KeyHelper.Catch``4(System.Func{``3},System.Func{System.Exception,``3})">
            <summary>
            The try-catch statement consists of a <see langword="try"/> block followed by one or more <see langword="catch"/> clauses, which specify handlers for different exceptions.
            </summary>
            <remarks>
            <seealso href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/try-catch"/>
            </remarks>
            <exception cref="T:System.NullReferenceException"></exception>
            <typeparam name="T1">The first type to catch.</typeparam>
            <typeparam name="T2">The second type to catch.</typeparam>
            <typeparam name="T3">The third type to catch.</typeparam>
            <typeparam name="TResult">The return type.</typeparam>
            <param name="action">The action to try.</param>
            <param name="caught">The action to run when an exception is caught.</param>
        </member>
        <member name="M:KeepCoding.KeyHelper.Catch``5(System.Func{``4},System.Func{System.Exception,``4})">
            <summary>
            The try-catch statement consists of a <see langword="try"/> block followed by one or more <see langword="catch"/> clauses, which specify handlers for different exceptions.
            </summary>
            <remarks>
            <seealso href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/try-catch"/>
            </remarks>
            <exception cref="T:System.NullReferenceException"></exception>
            <typeparam name="T1">The first type to catch.</typeparam>
            <typeparam name="T2">The second type to catch.</typeparam>
            <typeparam name="T3">The third type to catch.</typeparam>
            <typeparam name="T4">The fourth type to catch.</typeparam>
            <typeparam name="TResult">The return type.</typeparam>
            <param name="action">The action to try.</param>
            <param name="caught">The action to run when an exception is caught.</param>
        </member>
        <member name="M:KeepCoding.KeyHelper.Checked(System.Action)">
            <summary>
            The <see langword="checked"/> keyword is used to explicitly enable overflow checking for integral-type arithmetic operations and conversions.
            </summary>
            <remarks>
            <seealso href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/checked"/>
            </remarks>
            <exception cref="T:System.NullReferenceException"></exception>
            <param name="action">The action to run inside a <see langword="checked"/> block.</param>
        </member>
        <member name="M:KeepCoding.KeyHelper.Checked``1(System.Func{``0})">
            <summary>
            The <see langword="checked"/> keyword is used to explicitly enable overflow checking for integral-type arithmetic operations and conversions.
            </summary>
            <remarks>
            <seealso href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/checked"/>
            </remarks>
            <exception cref="T:System.NullReferenceException"></exception>
            <param name="func">The function to run inside a <see langword="checked"/> block.</param>
            <returns>The output of <paramref name="func"/>.</returns>
        </member>
        <member name="M:KeepCoding.KeyHelper.DoWhile(System.Action,System.Func{System.Boolean})">
            <summary>
            The <see langword="do"/> statement executes a statement or a block of statements while a specified Boolean expression evaluates to <see langword="true"/>. Because that expression is evaluated after each execution of the loop, a <see langword="do"/> loop executes one or more times. This differs from a <see langword="while"/> loop, which executes zero or more times.
            </summary>
            <remarks>
            <seealso href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-do-statement"/>
            </remarks>
            <exception cref="T:System.NullReferenceException"></exception>
            <param name="action">The action to run in the loop.</param>
            <param name="condition">The condition to determine whether the loop should keep going.</param>
        </member>
        <member name="M:KeepCoding.KeyHelper.DoWhile``1(System.Func{``0},System.Func{System.Boolean})">
            <summary>
            The <see langword="do"/> statement executes a statement or a block of statements while a specified Boolean expression evaluates to <see langword="true"/>. Because that expression is evaluated after each execution of the loop, a <see langword="do"/> loop executes one or more times. This differs from a <see langword="while"/> loop, which executes zero or more times.
            </summary>
            <remarks>
            <seealso href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-do-statement"/>
            </remarks>
            <exception cref="T:System.NullReferenceException"></exception>
            <param name="func">The function to run in the loop.</param>
            <param name="condition">The condition to determine whether the loop should keep going.</param>
            <returns>All instances that <paramref name="func"/> used in an <see cref="T:System.Collections.Generic.IEnumerable`1"/>.</returns>
        </member>
        <member name="M:KeepCoding.KeyHelper.For(System.Int32,System.Action{System.Int32})">
            <summary>
            The <see langword="for"/> statement executes a statement or a block of statements while a specified Boolean expression evaluates to <see langword="true"/>.
            </summary>
            <remarks>
            <seealso href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-for-statement"/>
            </remarks>
            <exception cref="T:System.NullReferenceException"></exception>
            <param name="length">The length to reach to in the for loop.</param>
            <param name="action">The action for each loop.</param>
            <returns><paramref name="length"/></returns>
        </member>
        <member name="M:KeepCoding.KeyHelper.For``1(``0,System.Action{``0},System.Predicate{``0},System.Func{``0,``0})">
            <summary>
            The <see langword="for"/> statement executes a statement or a block of statements while a specified Boolean expression evaluates to <see langword="true"/>.
            </summary>
            <remarks>
            <seealso href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-for-statement"/>
            </remarks>
            <exception cref="T:System.NullReferenceException"></exception>
            <typeparam name="T">The type of the declaring variable.</typeparam>
            <param name="item">The item to read and write on.</param>
            <param name="action">The action for each loop.</param>
            <param name="condition">The condition for whether the loop should continue.</param>
            <param name="loop">The action to run after <paramref name="action"/>.</param>
            <returns><paramref name="item"/></returns>
        </member>
        <member name="M:KeepCoding.KeyHelper.For``1(System.Int32,System.Func{System.Int32,``0})">
            <summary>
            The <see langword="for"/> statement executes a statement or a block of statements while a specified Boolean expression evaluates to <see langword="true"/>.
            </summary>
            <remarks>
            <seealso href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-for-statement"/>
            </remarks>
            <exception cref="T:System.NullReferenceException"></exception>
            <param name="length">The length to reach to in the for loop.</param>
            <param name="func">The function for each loop.</param>
            <returns>All instances that <paramref name="func"/> used in an <see cref="T:System.Collections.Generic.IEnumerable`1"/>.</returns>
        </member>
        <member name="M:KeepCoding.KeyHelper.For``1(``0,System.Func{``0,``0},System.Predicate{``0},System.Func{``0,``0})">
            <summary>
            The <see langword="for"/> statement executes a statement or a block of statements while a specified Boolean expression evaluates to <see langword="true"/>.
            </summary>
            <remarks>
            <seealso href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-for-statement"/>
            </remarks>
            <exception cref="T:System.NullReferenceException"></exception>
            <typeparam name="T">The type of the declaring variable.</typeparam>
            <param name="item">The item to read and write on.</param>
            <param name="func">The function for each loop.</param>
            <param name="condition">The condition for whether the loop should continue.</param>
            <param name="loop">The action to run after <paramref name="func"/>.</param>
            <returns>All instances that <paramref name="func"/> used in an <see cref="T:System.Collections.Generic.IEnumerable`1"/>.</returns>
        </member>
        <member name="M:KeepCoding.KeyHelper.ForEach(System.Collections.IEnumerable,System.Action{System.Object})">
            <summary>
            The <see langword="foreach"/> statement executes a statement or a block of statements for each element in an instance of the type that implements the <see cref="T:System.Collections.IEnumerable"/> or <see cref="T:System.Collections.Generic.IEnumerable`1"/> interface.
            </summary>
            <remarks>
            <seealso href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-foreach-statement"/>
            </remarks>
            <exception cref="T:System.NullReferenceException"></exception>
            <param name="iterator">The collection of items to go through one-by-one.</param>
            <param name="action">The action to do on each item in <paramref name="iterator"/>.</param>
            <returns><paramref name="iterator"/></returns>
        </member>
        <member name="M:KeepCoding.KeyHelper.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0})">
            <summary>
            The <see langword="foreach"/> statement executes a statement or a block of statements for each element in an instance of the type that implements the <see cref="T:System.Collections.IEnumerable"/> or <see cref="T:System.Collections.Generic.IEnumerable`1"/> interface.
            </summary>
            <remarks>
            <seealso href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-foreach-statement"/>
            </remarks>
            <exception cref="T:System.NullReferenceException"></exception>
            <typeparam name="T">The type of iterator.</typeparam>
            <param name="iterator">The collection of items to go through one-by-one.</param>
            <param name="action">The action to do on each item in <paramref name="iterator"/>.</param>
            <returns><paramref name="iterator"/></returns>
        </member>
        <member name="M:KeepCoding.KeyHelper.ForEach(System.Collections.IEnumerator,System.Action{System.Object})">
            <summary>
            The <see langword="foreach"/> statement executes a statement or a block of statements for each element in an instance of the type that implements the <see cref="T:System.Collections.IEnumerable"/> or <see cref="T:System.Collections.Generic.IEnumerable`1"/> interface.
            </summary>
            <remarks>
            <seealso href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-foreach-statement"/>
            </remarks>
            <exception cref="T:System.NullReferenceException"></exception>
            <param name="iterator">The collection of items to go through one-by-one.</param>
            <param name="action">The action to do on each item in <paramref name="iterator"/>.</param>
            <returns><paramref name="iterator"/></returns>
        </member>
        <member name="M:KeepCoding.KeyHelper.ForEach``1(System.Collections.Generic.IEnumerator{``0},System.Action{``0})">
            <summary>
            The <see langword="foreach"/> statement executes a statement or a block of statements for each element in an instance of the type that implements the <see cref="T:System.Collections.IEnumerable"/> or <see cref="T:System.Collections.Generic.IEnumerable`1"/> interface.
            </summary>
            <remarks>
            <seealso href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-foreach-statement"/>
            </remarks>
            <exception cref="T:System.NullReferenceException"></exception>
            <typeparam name="T">The type of iterator.</typeparam>
            <param name="iterator">The collection of items to go through one-by-one.</param>
            <param name="action">The action to do on each item in <paramref name="iterator"/>.</param>
            <returns><paramref name="iterator"/></returns>
        </member>
        <member name="M:KeepCoding.KeyHelper.If(System.Boolean,System.Action,System.Action)">
            <summary>
            An <see langword="if"/> statement identifies which statement to run based on the value of a Boolean expression.
            </summary>
            <remarks>
            <seealso href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/if-else"/>
            </remarks>
            <exception cref="T:System.NullReferenceException"></exception>
            <param name="condition">The condition to check.</param>
            <param name="action">The action to run when <paramref name="condition"/> is <see langword="true"/>.</param>
            <param name="otherwise">The action to run when <paramref name="condition"/> is <see langword="false"/>.</param>
            <returns><paramref name="condition"/></returns>
        </member>
        <member name="M:KeepCoding.KeyHelper.If``1(System.Boolean,System.Func{``0},System.Func{``0})">
            <summary>
            An <see langword="if"/> statement identifies which statement to run based on the value of a Boolean expression.
            </summary>
            <remarks>
            <seealso href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/if-else"/>
            </remarks>
            <exception cref="T:System.NullReferenceException"></exception>
            <param name="condition">The condition to check.</param>
            <param name="action">The action to run when <paramref name="condition"/> is <see langword="true"/>.</param>
            <param name="otherwise">The action to run when <paramref name="condition"/> is <see langword="false"/>.</param>
        </member>
        <member name="M:KeepCoding.KeyHelper.Is``1(System.Object)">
            <summary>
            The <see langword="is"/> operator checks if the result of an expression is compatible with a given type.
            </summary>
            <remarks>
            <seealso href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/operators/is"/>
            </remarks>
            <typeparam name="T">The type to cast into.</typeparam>
            <param name="obj">The object to cast.</param>
            <returns><paramref name="obj"/> <see langword="is"/> <typeparamref name="T"/></returns>
        </member>
        <member name="M:KeepCoding.KeyHelper.Is``1(System.Object,``0@)">
            <summary>
            The <see langword="is"/> operator checks if the result of an expression is compatible with a given type.
            </summary>
            <remarks>
            <seealso href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/operators/is"/>
            </remarks>
            <typeparam name="T">The type to cast into.</typeparam>
            <param name="obj">The object to cast.</param>
            <param name="item">The object casted into the type.</param>
            <returns><paramref name="obj"/> <see langword="is"/> <typeparamref name="T"/> <paramref name="item"/></returns>
        </member>
        <member name="M:KeepCoding.KeyHelper.Is``1(System.Object,System.Action{``0},System.Action)">
            <summary>
            The <see langword="is"/> operator checks if the result of an expression is compatible with a given type.
            </summary>
            <remarks>
            <seealso href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/operators/is"/>
            </remarks>
            <typeparam name="T">The type to cast into.</typeparam>
            <param name="obj">The object to cast.</param>
            <param name="action">The action to run when <paramref name="obj"/> is <typeparamref name="T"/>.</param>
            <param name="otherwise">The action to run when <paramref name="obj"/> is not <typeparamref name="T"/>.</param>
            <returns><paramref name="obj"/> <see langword="is"/> <typeparamref name="T"/> item</returns>
        </member>
        <member name="M:KeepCoding.KeyHelper.Lock``1(``0,System.Action{``0})">
            <summary>
            The <see langword="lock"/> statement acquires the mutual-exclusion lock for a given object, executes a statement block, and then releases the lock. While a lock is held, the thread that holds the lock can again acquire and release the lock. Any other thread is blocked from acquiring the lock and waits until the lock is released.
            </summary>
            <remarks>
            <seealso href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/lock-statement"/>
            </remarks>
            <exception cref="T:System.NullReferenceException"></exception>
            <typeparam name="T">The type of item to lock.</typeparam>
            <param name="item">The item to lock.</param>
            <param name="action">The action to run while the item is locked.</param>
        </member>
        <member name="M:KeepCoding.KeyHelper.Lock``1(``0,System.Func{``0,``0})">
            <summary>
            The <see langword="lock"/> statement acquires the mutual-exclusion lock for a given object, executes a statement block, and then releases the lock. While a lock is held, the thread that holds the lock can again acquire and release the lock. Any other thread is blocked from acquiring the lock and waits until the lock is released.
            </summary>
            <remarks>
            <seealso href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/lock-statement"/>
            </remarks>
            <exception cref="T:System.NullReferenceException"></exception>
            <typeparam name="T">The type of item to lock.</typeparam>
            <param name="item">The item to lock.</param>
            <param name="func">The function to run while the item is locked.</param>
            <returns>The output of <paramref name="func"/>.</returns>
        </member>
        <member name="M:KeepCoding.KeyHelper.NameOf``1(System.Linq.Expressions.Expression{System.Func{``0}})">
            <summary>
            A <see langword="nameof"/> expression produces the name of a variable, type, or member as the string constant.
            </summary>
            <remarks>
            <seealso href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/operators/nameof"/>
            </remarks>
            <typeparam name="T">The type of item.</typeparam>
            <param name="expression">The expression to get the name from.</param>
            <returns>The name of the expression.</returns>
        </member>
        <member name="M:KeepCoding.KeyHelper.Unchecked(System.Action)">
            <summary>
            The <see langword="unchecked"/> keyword is used to suppress overflow-checking for integral-type arithmetic operations and conversions.
            </summary>
            <remarks>
            <seealso href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/unchecked"/>
            </remarks>
            <exception cref="T:System.NullReferenceException"></exception>
            <param name="action">The action to ignore overflow-checking.</param>
        </member>
        <member name="M:KeepCoding.KeyHelper.Unchecked``1(System.Func{``0})">
            <summary>
            The <see langword="unchecked"/> keyword is used to suppress overflow-checking for integral-type arithmetic operations and conversions.
            </summary>
            <remarks>
            <seealso href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/unchecked"/>
            </remarks>
            <exception cref="T:System.NullReferenceException"></exception>
            <param name="func">The function to ignore overflow-checking.</param>
            <returns>The output of <paramref name="func"/>.</returns>
        </member>
        <member name="M:KeepCoding.KeyHelper.Using``1(``0,System.Action{``0})">
            <summary>
            Provides a convenient syntax that ensures the correct use of <see cref="T:System.IDisposable"/> objects.
            </summary>
            <remarks>
            <seealso href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/using-statement"/>
            </remarks>
            <exception cref="T:System.NullReferenceException"></exception>
            <typeparam name="T">The type of <see cref="T:System.IDisposable"/>.</typeparam>
            <param name="item">The item to use.</param>
            <param name="action">The action to use <paramref name="item"/> on.</param>
            <returns><paramref name="item"/></returns>
        </member>
        <member name="M:KeepCoding.KeyHelper.Using``1(``0,System.Func{``0,``0})">
            <summary>
            Provides a convenient syntax that ensures the correct use of <see cref="T:System.IDisposable"/> objects.
            </summary>
            <remarks>
            <seealso href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/using-statement"/>
            </remarks>
            <exception cref="T:System.NullReferenceException"></exception>
            <typeparam name="T">The type of <see cref="T:System.IDisposable"/>.</typeparam>
            <param name="item">The item to use.</param>
            <param name="func">The function to use <paramref name="item"/> on.</param>
            <returns>The output of <paramref name="func"/>.</returns>
        </member>
        <member name="M:KeepCoding.KeyHelper.While(System.Action,System.Func{System.Boolean})">
            <summary>
            The <see langword="while"/> statement executes a statement or a block of statements while a specified Boolean expression evaluates to <see langword="true"/>. Because that expression is evaluated before each execution of the loop, a <see langword="while"/> loop executes zero or more times. This differs from a <see langword="do"/> loop, which executes one or more times.
            </summary>
            <remarks>
            <seealso href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-while-statement"/>
            </remarks>
            <exception cref="T:System.NullReferenceException"></exception>
            <param name="action">The action to run in the loop.</param>
            <param name="condition">The condition to determine whether the loop should keep going.</param>
        </member>
        <member name="M:KeepCoding.KeyHelper.While``1(System.Func{``0},System.Func{System.Boolean})">
            <summary>
            The <see langword="while"/> statement executes a statement or a block of statements while a specified Boolean expression evaluates to <see langword="true"/>. Because that expression is evaluated before each execution of the loop, a <see langword="while"/> loop executes zero or more times. This differs from a <see langword="do"/> loop, which executes one or more times.
            </summary>
            <remarks>
            <seealso href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-while-statement"/>
            </remarks>
            <exception cref="T:System.NullReferenceException"></exception>
            <param name="func">The function to run in the loop.</param>
            <param name="condition">The condition to determine whether the loop should keep going.</param>
            <returns>All instances that <paramref name="func"/> used in an <see cref="T:System.Collections.Generic.IEnumerable`1"/>.</returns>
        </member>
        <member name="T:KeepCoding.TypeHelper">
            <summary>
            Extension methods to help you create data types easier.
            </summary>
        </member>
        <member name="M:KeepCoding.TypeHelper.IsEqual(UnityEngine.Color32,UnityEngine.Color32)">
            <summary>
            Checks if both colors have the same RGBA values.
            </summary>
            <param name="colorA">The first color.</param>
            <param name="colorB">The second color.</param>
            <returns>Boolean, true only if both colors have the same R, G, B, and A values.</returns>
        </member>
        <member name="M:KeepCoding.TypeHelper.IsEqual(UnityEngine.Color,UnityEngine.Color)">
            <summary>
            Checks if both colors have the same RGBA values.
            </summary>
            <param name="colorA">The first color.</param>
            <param name="colorB">The second color.</param>
            <returns>Boolean, true only if both colors have the same R, G, B, and A values.</returns>
        </member>
        <member name="M:KeepCoding.TypeHelper.IsAnyEqual(UnityEngine.Color32[],UnityEngine.Color32)">
            <summary>
            Checks if any elements in the array <paramref name="colors"/> are equal to <paramref name="color"/>.
            </summary>
            <param name="colors">The array of colors to compare to <paramref name="color"/>.</param>
            <param name="color">The color to compare it to.</param>
            <returns>Boolean, true only if any color in <paramref name="colors"/> is the exact same as <paramref name="color"/>'s R, G, B, and A values.</returns>
        </member>
        <member name="M:KeepCoding.TypeHelper.IsAnyEqual(UnityEngine.Color[],UnityEngine.Color)">
            <summary>
            Checks if any elements in the array <paramref name="colors"/> are equal to <paramref name="color"/>.
            </summary>
            <exception cref="!:NullIteratorException"></exception>
            <param name="colors">The array of colors to compare to <paramref name="color"/>.</param>
            <param name="color">The color to compare it to.</param>
            <returns>Boolean, true only if any color in <paramref name="colors"/> is the exact same as <paramref name="color"/>'s R, G, B, and A values.</returns>
        </member>
        <member name="M:KeepCoding.TypeHelper.Add(UnityEngine.Color,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Duplicates the color, and adds the RGBA components only if they are specified.
            </summary>
            <remarks>
            You can also use negative numbers to subtract.
            </remarks>
            <param name="color">The color to duplicate and modify.</param>
            <param name="r">The red component.</param>
            <param name="g">The blue component.</param>
            <param name="b">The green component.</param>
            <param name="a">The alpha component; opacity.</param>
            <returns>A new instance of the <paramref name="color"/>, with the arguments replacing the values.</returns>
        </member>
        <member name="M:KeepCoding.TypeHelper.Add(UnityEngine.Color,System.Byte,System.Byte,System.Byte,System.Byte)">
            <summary>
            Duplicates the color, and adds the RGBA components only if they are specified.
            </summary>
            <remarks>
            You can also use negative numbers to subtract.
            </remarks>
            <param name="color">The <see cref="T:UnityEngine.Color"/> to duplicate and modify.</param>
            <param name="r">The red component.</param>
            <param name="g">The blue component.</param>
            <param name="b">The green component.</param>
            <param name="a">The alpha component; opacity.</param>
            <returns>A new instance of the <paramref name="color"/>, with the arguments replacing the values.</returns>
        </member>
        <member name="M:KeepCoding.TypeHelper.IntertwineColor(UnityEngine.Color,UnityEngine.Color,System.Single)">
            <summary>
            Creates an in-between color between 2 different colors.
            </summary>
            <param name="colorA">The first color, with 0 <paramref name="concentrationOfB"/> being biased towards this color.</param>
            <param name="colorB">The second color, with 1 <paramref name="concentrationOfB"/> being biased towards this color.</param>
            <param name="concentrationOfB">The bias towards either color, between 0-1. 0.5 blends both colors equally.</param>
            <returns>A blended color of the 2 provided.</returns>
        </member>
        <member name="M:KeepCoding.TypeHelper.IntertwineColor(UnityEngine.Renderer,UnityEngine.Color,UnityEngine.Color,System.Single)">
            <summary>
            Sets the <see cref="P:UnityEngine.Renderer.material"/>'s color to be a mix of 2 colors.
            </summary>
            <param name="renderer">The renderer to change the color of.</param>
            <param name="colorA">The first color, with 0 <paramref name="concentrationOfB"/> being biased towards this color.</param>
            <param name="colorB">The second color, with 1 <paramref name="concentrationOfB"/> being biased towards this color.</param>
            <param name="concentrationOfB">The bias towards either color, between 0-1. 0.5 blends both colors equally.</param>
            <returns>The resulting color that the <paramref name="renderer"/> becomes.</returns>
        </member>
        <member name="M:KeepCoding.TypeHelper.Set(UnityEngine.Color,System.Nullable{System.Single},System.Nullable{System.Single},System.Nullable{System.Single},System.Nullable{System.Single})">
            <summary>
            Duplicates the color, and sets the RGBA components only if they are specified.
            </summary>
            <param name="color">The <see cref="T:UnityEngine.Color"/> to duplicate and modify.</param>
            <param name="r">The red component.</param>
            <param name="g">The blue component.</param>
            <param name="b">The green component.</param>
            <param name="a">The alpha component; opacity.</param>
            <returns>A new instance of the <paramref name="color"/>, with the arguments replacing the values.</returns>
        </member>
        <member name="M:KeepCoding.TypeHelper.Set(UnityEngine.Color,System.Nullable{System.Byte},System.Nullable{System.Byte},System.Nullable{System.Byte},System.Nullable{System.Byte})">
            <summary>
            Duplicates the color, and sets the RGBA components only if they are specified.
            </summary>
            <param name="color">The <see cref="T:UnityEngine.Color"/> to duplicate and modify.</param>
            <param name="r">The red component.</param>
            <param name="g">The blue component.</param>
            <param name="b">The green component.</param>
            <param name="a">The alpha component; opacity.</param>
            <returns>A new instance of the <paramref name="color"/>, with the arguments replacing the values.</returns>
        </member>
        <member name="M:KeepCoding.TypeHelper.Add(UnityEngine.Color32,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Duplicates the color, and adds the RGBA components only if they are specified.
            </summary>
            <remarks>
            You can also use negative numbers to subtract. As this is <see cref="T:UnityEngine.Color32"/>, be careful of byte underflows/overflows.
            </remarks>
            <param name="color">The <see cref="T:UnityEngine.Color32"/> to duplicate and modify.</param>
            <param name="r">The red component.</param>
            <param name="g">The blue component.</param>
            <param name="b">The green component.</param>
            <param name="a">The alpha component; opacity.</param>
            <returns>A new instance of the <paramref name="color"/>, with the arguments replacing the values.</returns>
        </member>
        <member name="M:KeepCoding.TypeHelper.Add(UnityEngine.Color32,System.Byte,System.Byte,System.Byte,System.Byte)">
            <summary>
            Duplicates the color, and adds the RGBA components only if they are specified.
            </summary>
            <remarks>
            You can also use negative numbers to subtract. As this is <see cref="T:UnityEngine.Color32"/>, be careful of byte underflows/overflows.
            </remarks>
            <param name="color">The <see cref="T:UnityEngine.Color32"/> to duplicate and modify.</param>
            <param name="r">The red component.</param>
            <param name="g">The blue component.</param>
            <param name="b">The green component.</param>
            <param name="a">The alpha component; opacity.</param>
            <returns>A new instance of the <paramref name="color"/>, with the arguments replacing the values.</returns>
        </member>
        <member name="M:KeepCoding.TypeHelper.HexToColor(System.String)">
            <summary>
            Converts a hexadecimal string into colors.
            </summary>
            <exception cref="T:System.FormatException"></exception>
            <param name="hex">A string of hexadecimal, which can be formatted as "FFFFFF", "#FFFFFF", or "0xFFFFFF"</param>
            <returns><see cref="T:UnityEngine.Color32"/> converted from hexadecimal string.</returns>
        </member>
        <member name="M:KeepCoding.TypeHelper.IntertwineColor(UnityEngine.Color32,UnityEngine.Color32,System.Single)">
            <summary>
            Creates an in-between color between 2 different colors.
            </summary>
            <param name="colorA">The first color, with 0 <paramref name="concentrationOfB"/> being biased towards this color.</param>
            <param name="colorB">The second color, with 1 <paramref name="concentrationOfB"/> being biased towards this color.</param>
            <param name="concentrationOfB">The bias towards either color, between 0-1. 0.5 blends both colors equally.</param>
            <returns>A blended color of the 2 provided.</returns>
        </member>
        <member name="M:KeepCoding.TypeHelper.IntertwineColor(UnityEngine.Renderer,UnityEngine.Color32,UnityEngine.Color32,System.Single)">
            <summary>
            Sets the <see cref="P:UnityEngine.Renderer.material"/>'s color to be a mix of 2 colors.
            </summary>
            <param name="renderer">The renderer to change the color of.</param>
            <param name="colorA">The first color, with 0 <paramref name="concentrationOfB"/> being biased towards this color.</param>
            <param name="colorB">The second color, with 1 <paramref name="concentrationOfB"/> being biased towards this color.</param>
            <param name="concentrationOfB">The bias towards either color, between 0-1. 0.5 blends both colors equally.</param>
            <returns>The resulting color that the <paramref name="renderer"/> becomes.</returns>
        </member>
        <member name="M:KeepCoding.TypeHelper.Set(UnityEngine.Color32,System.Nullable{System.Single},System.Nullable{System.Single},System.Nullable{System.Single},System.Nullable{System.Single})">
            <summary>
            Duplicates the color, and sets the RGBA components only if they are specified.
            </summary>
            <param name="color">The <see cref="T:UnityEngine.Color32"/> to duplicate and modify.</param>
            <param name="r">The red component.</param>
            <param name="g">The blue component.</param>
            <param name="b">The green component.</param>
            <param name="a">The alpha component; opacity.</param>
            <returns>A new instance of the <paramref name="color"/>, with the arguments replacing the values.</returns>
        </member>
        <member name="M:KeepCoding.TypeHelper.Set(UnityEngine.Color32,System.Nullable{System.Byte},System.Nullable{System.Byte},System.Nullable{System.Byte},System.Nullable{System.Byte})">
            <summary>
            Duplicates the color, and sets the RGBA components only if they are specified.
            </summary>
            <param name="color">The <see cref="T:UnityEngine.Color32"/> to duplicate and modify.</param>
            <param name="r">The red component.</param>
            <param name="g">The blue component.</param>
            <param name="b">The green component.</param>
            <param name="a">The alpha component; opacity.</param>
            <returns>A new instance of the <paramref name="color"/>, with the arguments replacing the values.</returns>
        </member>
        <member name="M:KeepCoding.TypeHelper.ToLogger``1(``0,System.String,System.Boolean)">
            <summary>
            Converts arguments to a new <see cref="T:KeepCoding.Logger"/>.
            </summary>
            <typeparam name="T">The type of the argument, which is used as the name if <paramref name="name"/> is <see langword="null"/>.</typeparam>
            <param name="_">The discard which is only needed for the type.</param>
            <param name="name">The name of the value.</param>
            <param name="showId">Determines whether to show the unique identifier when logging.</param>
            <returns>A new <see cref="T:KeepCoding.Logger"/> containing the arguments specified.</returns>
        </member>
        <member name="M:KeepCoding.TypeHelper.ToRoutine(UnityEngine.MonoBehaviour,System.Func{System.Collections.IEnumerator})">
            <summary>
            Converts arguments to a new <see cref="T:KeepCoding.Routine"/>.
            </summary>
            <param name="func">The function to call when the <see cref="T:System.Collections.IEnumerator"/> is called.</param>
            <param name="monoBehaviour">The instance of the <see cref="T:UnityEngine.MonoBehaviour"/> to start the <see cref="T:UnityEngine.Coroutine"/> from.</param>
            <returns>A new <see cref="T:KeepCoding.Routine"/> containing the arguments provided.</returns>
        </member>
        <member name="M:KeepCoding.TypeHelper.ToRoutine``1(UnityEngine.MonoBehaviour,System.Func{``0,System.Collections.IEnumerator})">
            <summary>
            Converts arguments to a new <see cref="T:KeepCoding.Routine`1"/>.
            </summary>
            <param name="func">The function to call when the <see cref="T:System.Collections.IEnumerator"/> is called.</param>
            <param name="monoBehaviour">The instance of the <see cref="T:UnityEngine.MonoBehaviour"/> to start the <see cref="T:UnityEngine.Coroutine"/> from.</param>
            <returns>A new <see cref="T:KeepCoding.Routine`1"/> containing the arguments provided.</returns>
        </member>
        <member name="M:KeepCoding.TypeHelper.ToRoutine``2(UnityEngine.MonoBehaviour,System.Func{``0,``1,System.Collections.IEnumerator})">
            <summary>
            Converts arguments to a new <see cref="T:KeepCoding.Routine`2"/>.
            </summary>
            <param name="func">The function to call when the <see cref="T:System.Collections.IEnumerator"/> is called.</param>
            <param name="monoBehaviour">The instance of the <see cref="T:UnityEngine.MonoBehaviour"/> to start the <see cref="T:UnityEngine.Coroutine"/> from.</param>
            <returns>A new <see cref="T:KeepCoding.Routine`2"/> containing the arguments provided.</returns>
        </member>
        <member name="M:KeepCoding.TypeHelper.ToRoutine``3(UnityEngine.MonoBehaviour,System.Func{``0,``1,``2,System.Collections.IEnumerator})">
            <summary>
            Converts arguments to a new <see cref="T:KeepCoding.Routine`3"/>.
            </summary>
            <param name="func">The function to call when the <see cref="T:System.Collections.IEnumerator"/> is called.</param>
            <param name="monoBehaviour">The instance of the <see cref="T:UnityEngine.MonoBehaviour"/> to start the <see cref="T:UnityEngine.Coroutine"/> from.</param>
            <returns>A new <see cref="T:KeepCoding.Routine`3"/> containing the arguments provided.</returns>
        </member>
        <member name="M:KeepCoding.TypeHelper.ToRoutine``4(UnityEngine.MonoBehaviour,System.Func{``0,``1,``2,``3,System.Collections.IEnumerator})">
            <summary>
            Converts arguments to a new <see cref="T:KeepCoding.Routine`4"/>.
            </summary>
            <param name="func">The function to call when the <see cref="T:System.Collections.IEnumerator"/> is called.</param>
            <param name="monoBehaviour">The instance of the <see cref="T:UnityEngine.MonoBehaviour"/> to start the <see cref="T:UnityEngine.Coroutine"/> from.</param>
            <returns>A new <see cref="T:KeepCoding.Routine`4"/> containing the arguments provided.</returns>
        </member>
        <member name="M:KeepCoding.TypeHelper.ToTuple``1(``0)">
            <summary>
            Converts arguments to a new <see cref="T:KeepCoding.Tuple`1"/>.
            </summary>
            <typeparam name="T">The type of tuple.</typeparam>
            <param name="item">The argument to pass into the tuple.</param>
            <returns>A new <see cref="T:KeepCoding.Tuple`1"/> containing <paramref name="item"/>.</returns>
        </member>
        <member name="M:KeepCoding.TypeHelper.ToTuple``2(``0,``1)">
            <summary>
            Converts arguments to a new <see cref="T:KeepCoding.Tuple`2"/>.
            </summary>
            <typeparam name="T1">The first type of the tuple.</typeparam>
            <typeparam name="T2">The second type of the tuple.</typeparam>
            <param name="item1">The first argument to pass into the tuple.</param>
            <param name="item2">The second argument to pass into the tuple.</param>
            <returns>A new <seealso cref="T:KeepCoding.Tuple`2"/> containing <paramref name="item1"/> and <paramref name="item2"/></returns>
        </member>
        <member name="M:KeepCoding.TypeHelper.ToTuple``3(``0,``1,``2)">
            <summary>
            Converts arguments to a new <see cref="T:KeepCoding.Tuple`3"/>.
            </summary>
            <typeparam name="T1">The first type of the tuple.</typeparam>
            <typeparam name="T2">The second type of the tuple.</typeparam>
            <typeparam name="T3">The third type of the tuple.</typeparam>
            <param name="item1">The first argument to pass into the tuple.</param>
            <param name="item2">The second argument to pass into the tuple.</param>
            <param name="item3">The third argument to pass into the tuple.</param>
            <returns>A new <seealso cref="T:KeepCoding.Tuple`3"/> containing <paramref name="item1"/>, <paramref name="item2"/>, and <paramref name="item3"/></returns>
        </member>
        <member name="M:KeepCoding.TypeHelper.ToTuple``4(``0,``1,``2,``3)">
            <summary>
            Converts arguments to a new <see cref="T:KeepCoding.Tuple`4"/>.
            </summary>
            <typeparam name="T1">The first type of the tuple.</typeparam>
            <typeparam name="T2">The second type of the tuple.</typeparam>
            <typeparam name="T3">The third type of the tuple.</typeparam>
            <typeparam name="T4">The fourth type of the tuple.</typeparam>
            <param name="item1">The first argument to pass into the tuple.</param>
            <param name="item2">The second argument to pass into the tuple.</param>
            <param name="item3">The third argument to pass into the tuple.</param>
            <param name="item4">The fourth argument to pass into the tuple.</param>
            <returns>A new <seealso cref="T:KeepCoding.Tuple`4"/> containing <paramref name="item1"/>, <paramref name="item2"/>, <paramref name="item3"/>, and <paramref name="item4"/></returns>
        </member>
        <member name="M:KeepCoding.TypeHelper.Add(UnityEngine.Vector2@,System.Single,System.Single)">
            <summary>
            Duplicates the vector, and sets the x and y components only if they are specified.
            </summary>
            <param name="vector">The <see cref="T:UnityEngine.Vector2"/> to duplicate and modify.</param>
            <param name="x">The x value.</param>
            <param name="y">The y value.</param>
            <returns>A new instance of <paramref name="vector"/>, with the arguments replacing the values.</returns>
        </member>
        <member name="M:KeepCoding.TypeHelper.Add(UnityEngine.Vector2,System.Single,System.Single)">
            <summary>
            Takes the vector, and sets the x and y components only if they are specified.
            </summary>
            <param name="vector">The <see cref="T:UnityEngine.Vector2"/> to duplicate and modify.</param>
            <param name="x">The x value.</param>
            <param name="y">The y value.</param>
            <returns>A new instance of <paramref name="vector"/>, with the arguments replacing the values.</returns>
        </member>
        <member name="M:KeepCoding.TypeHelper.Add(UnityEngine.Vector3@,System.Single,System.Single,System.Single)">
            <summary>
            Duplicates the vector, and sets the x, y, and z components only if they are specified.
            </summary>
            <param name="vector">The <see cref="T:UnityEngine.Vector3"/> to duplicate and modify.</param>
            <param name="x">The x value.</param>
            <param name="y">The y value.</param>
            <param name="z">The z value.</param>
            <returns>A new instance of <paramref name="vector"/>, with the arguments replacing the values.</returns>
        </member>
        <member name="M:KeepCoding.TypeHelper.Add(UnityEngine.Vector3,System.Single,System.Single,System.Single)">
            <summary>
            Takes the vector, and sets the x, y, and z components only if they are specified.
            </summary>
            <param name="vector">The <see cref="T:UnityEngine.Vector3"/> to duplicate and modify.</param>
            <param name="x">The x value.</param>
            <param name="y">The y value.</param>
            <param name="z">The z value.</param>
            <returns>A new instance of <paramref name="vector"/>, with the arguments replacing the values.</returns>
        </member>
        <member name="M:KeepCoding.TypeHelper.Add(UnityEngine.Vector4@,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Duplicates the vector, and sets the x, y, z, and w components only if they are specified.
            </summary>
            <param name="vector">The <see cref="T:UnityEngine.Vector3"/> to duplicate and modify.</param>
            <param name="x">The x value.</param>
            <param name="y">The y value.</param>
            <param name="z">The z value.</param>
            <param name="w">The w value.</param>
            <returns>A new instance of <paramref name="vector"/>, with the arguments replacing the values.</returns>
        </member>
        <member name="M:KeepCoding.TypeHelper.Add(UnityEngine.Vector4,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Takes the vector, and sets the x, y, z, and w components only if they are specified.
            </summary>
            <param name="vector">The <see cref="T:UnityEngine.Vector3"/> to duplicate and modify.</param>
            <param name="x">The x value.</param>
            <param name="y">The y value.</param>
            <param name="z">The z value.</param>
            <param name="w">The w value.</param>
            <returns>A new instance of <paramref name="vector"/>, with the arguments replacing the values.</returns>
        </member>
        <member name="M:KeepCoding.TypeHelper.Set(UnityEngine.Vector2@,System.Nullable{System.Single},System.Nullable{System.Single})">
            <summary>
            Takes the vector, and sets the x and y components only if they are specified.
            </summary>
            <param name="vector">The <see cref="T:UnityEngine.Vector2"/> to duplicate and modify.</param>
            <param name="x">The x value.</param>
            <param name="y">The y value.</param>
            <returns>A new instance of <paramref name="vector"/>, with the arguments replacing the values.</returns>
        </member>
        <member name="M:KeepCoding.TypeHelper.Set(UnityEngine.Vector2,System.Nullable{System.Single},System.Nullable{System.Single})">
            <summary>
            Duplicates the vector, and sets the x and y components only if they are specified.
            </summary>
            <param name="vector">The <see cref="T:UnityEngine.Vector2"/> to duplicate and modify.</param>
            <param name="x">The x value.</param>
            <param name="y">The y value.</param>
            <returns>A new instance of <paramref name="vector"/>, with the arguments replacing the values.</returns>
        </member>
        <member name="M:KeepCoding.TypeHelper.Set(UnityEngine.Vector3@,System.Nullable{System.Single},System.Nullable{System.Single},System.Nullable{System.Single})">
            <summary>
            Takes the vector, and sets the x, y, and z components only if they are specified.
            </summary>
            <param name="vector">The <see cref="T:UnityEngine.Vector3"/> to duplicate and modify.</param>
            <param name="x">The x value.</param>
            <param name="y">The y value.</param>
            <param name="z">The z value.</param>
            <returns>A new instance of <paramref name="vector"/>, with the arguments replacing the values.</returns>
        </member>
        <member name="M:KeepCoding.TypeHelper.Set(UnityEngine.Vector3,System.Nullable{System.Single},System.Nullable{System.Single},System.Nullable{System.Single})">
            <summary>
            Duplicates the vector, and sets the x, y, and z components only if they are specified.
            </summary>
            <param name="vector">The <see cref="T:UnityEngine.Vector3"/> to duplicate and modify.</param>
            <param name="x">The x value.</param>
            <param name="y">The y value.</param>
            <param name="z">The z value.</param>
            <returns>A new instance of <paramref name="vector"/>, with the arguments replacing the values.</returns>
        </member>
        <member name="M:KeepCoding.TypeHelper.Set(UnityEngine.Vector4@,System.Nullable{System.Single},System.Nullable{System.Single},System.Nullable{System.Single},System.Nullable{System.Single})">
            <summary>
            Takes the vector, and sets the x, y, z, and w components only if they are specified.
            </summary>
            <param name="vector">The <see cref="T:UnityEngine.Vector3"/> to duplicate and modify.</param>
            <param name="x">The x value.</param>
            <param name="y">The y value.</param>
            <param name="z">The z value.</param>
            <param name="w">The w value.</param>
            <returns>A new instance of <paramref name="vector"/>, with the arguments replacing the values.</returns>
        </member>
        <member name="M:KeepCoding.TypeHelper.Set(UnityEngine.Vector4,System.Nullable{System.Single},System.Nullable{System.Single},System.Nullable{System.Single},System.Nullable{System.Single})">
            <summary>
            Duplicates the vector, and sets the x, y, z, and w components only if they are specified.
            </summary>
            <param name="vector">The <see cref="T:UnityEngine.Vector3"/> to duplicate and modify.</param>
            <param name="x">The x value.</param>
            <param name="y">The y value.</param>
            <param name="z">The z value.</param>
            <param name="w">The w value.</param>
            <returns>A new instance of <paramref name="vector"/>, with the arguments replacing the values.</returns>
        </member>
        <member name="M:KeepCoding.TypeHelper.ToVersion(System.String)">
            <summary>
            Converts argument to a new <see cref="T:System.Version"/>. Major-only versions are compatible.
            </summary>
            <param name="s">The string to convert to a version.</param>
            <returns>A new <see cref="T:System.Version"/> representing the input <paramref name="s"/>.</returns>
        </member>
        <member name="M:KeepCoding.TypeHelper.ToWork(System.Action)">
            <summary>
            Converts argument to a new <see cref="T:KeepCoding.Work"/>
            </summary>
            <param name="action">The action to run when the thread is active.</param>
            <returns>A new <see cref="T:KeepCoding.Work"/> consisting of the arguments provided.</returns>
        </member>
        <member name="M:KeepCoding.TypeHelper.ToWork(System.UInt32,System.Action,System.Boolean)">
            <summary>
            Converts argument to a new <see cref="T:KeepCoding.Work"/>
            </summary>
            <param name="action">The action to run when the thread is active.</param>
            <param name="allowSimultaneousActive">Whether it should allow multiple of itself to be running at once.</param>
            <param name="maximumThreadsActive">The amount of threads this class, and all of its overloads can run at once.</param>
            <returns>A new <see cref="T:KeepCoding.Work"/> consisting of the arguments provided.</returns>
        </member>
        <member name="M:KeepCoding.TypeHelper.ToWork``1(System.Func{``0})">
            <summary>
            Converts argument to a new <see cref="T:KeepCoding.Work"/>
            </summary>
            <param name="func">The action to run when the thread is active.</param>
            <returns>A new <see cref="T:KeepCoding.Work"/> consisting of the arguments provided.</returns>
        </member>
        <member name="M:KeepCoding.TypeHelper.ToWork``1(System.UInt32,System.Func{``0},System.Boolean)">
            <summary>
            Converts argument to a new <see cref="T:KeepCoding.Work`1"/>
            </summary>
            <param name="func">The action to run when the thread is active.</param>
            <param name="allowSimultaneousActive">Whether it should allow multiple of itself to be running at once.</param>
            <param name="maximumThreadsActive">The amount of threads this class, and all of its overloads can run at once.</param>
            <returns>A new <see cref="T:KeepCoding.Work`1"/> consisting of the arguments provided.</returns>
        </member>
        <member name="M:KeepCoding.TypeHelper.ToWork``2(System.Func{``0,``1})">
            <summary>
            Converts argument to a new <see cref="T:KeepCoding.Work"/>
            </summary>
            <param name="func">The action to run when the thread is active.</param>
            <returns>A new <see cref="T:KeepCoding.Work"/> consisting of the arguments provided.</returns>
        </member>
        <member name="M:KeepCoding.TypeHelper.ToWork``2(System.UInt32,System.Func{``0,``1},System.Boolean)">
            <summary>
            Converts argument to a new <see cref="T:KeepCoding.Work`2"/>
            </summary>
            <param name="func">The action to run when the thread is active.</param>
            <param name="allowSimultaneousActive">Whether it should allow multiple of itself to be running at once.</param>
            <param name="maximumThreadsActive">The amount of threads this class, and all of its overloads can run at once.</param>
            <returns>A new <see cref="T:KeepCoding.Work`2"/> consisting of the arguments provided.</returns>
        </member>
        <member name="M:KeepCoding.TypeHelper.ToWork``3(System.Func{``0,``1,``2})">
            <summary>
            Converts argument to a new <see cref="T:KeepCoding.Work"/>
            </summary>
            <param name="func">The action to run when the thread is active.</param>
            <returns>A new <see cref="T:KeepCoding.Work"/> consisting of the arguments provided.</returns>
        </member>
        <member name="M:KeepCoding.TypeHelper.ToWork``3(System.UInt32,System.Func{``0,``1,``2},System.Boolean)">
            <summary>
            Converts argument to a new <see cref="T:KeepCoding.Work`3"/>
            </summary>
            <param name="func">The action to run when the thread is active.</param>
            <param name="allowSimultaneousActive">Whether it should allow multiple of itself to be running at once.</param>
            <param name="maximumThreadsActive">The amount of threads this class, and all of its overloads can run at once.</param>
            <returns>A new <see cref="T:KeepCoding.Work`3"/> consisting of the arguments provided.</returns>
        </member>
        <member name="M:KeepCoding.TypeHelper.ToWork``4(System.Func{``0,``1,``2,``3})">
            <summary>
            Converts argument to a new <see cref="T:KeepCoding.Work"/>
            </summary>
            <param name="func">The action to run when the thread is active.</param>
            <returns>A new <see cref="T:KeepCoding.Work"/> consisting of the arguments provided.</returns>
        </member>
        <member name="M:KeepCoding.TypeHelper.ToWork``4(System.UInt32,System.Func{``0,``1,``2,``3},System.Boolean)">
            <summary>
            Converts argument to a new <see cref="T:KeepCoding.Work`4"/>
            </summary>
            <param name="func">The action to run when the thread is active.</param>
            <param name="allowSimultaneousActive">Whether it should allow multiple of itself to be running at once.</param>
            <param name="maximumThreadsActive">The amount of threads this class, and all of its overloads can run at once.</param>
            <returns>A new <see cref="T:KeepCoding.Work`4"/> consisting of the arguments provided.</returns>
        </member>
        <member name="M:KeepCoding.TypeHelper.ToWork``5(System.Func{``0,``1,``2,``3,``4})">
            <summary>
            Converts argument to a new <see cref="T:KeepCoding.Work"/>
            </summary>
            <param name="func">The action to run when the thread is active.</param>
            <returns>A new <see cref="T:KeepCoding.Work"/> consisting of the arguments provided.</returns>
        </member>
        <member name="M:KeepCoding.TypeHelper.ToWork``5(System.UInt32,System.Func{``0,``1,``2,``3,``4},System.Boolean)">
            <summary>
            Converts argument to a new <see cref="T:KeepCoding.Work`5"/>
            </summary>
            <param name="func">The action to run when the thread is active.</param>
            <param name="allowSimultaneousActive">Whether it should allow multiple of itself to be running at once.</param>
            <param name="maximumThreadsActive">The amount of threads this class, and all of its overloads can run at once.</param>
            <returns>A new <see cref="T:KeepCoding.Work`5"/> consisting of the arguments provided.</returns>
        </member>
        <member name="T:KeepCoding.BigInteger">
            <summary>
            Stores an arbitrarily large number.
            </summary>
        </member>
        <member name="M:KeepCoding.BigInteger.#ctor">
            <summary>
            Creates a big integer with the default value. (0)
            </summary>
        </member>
        <member name="M:KeepCoding.BigInteger.#ctor(System.Object)">
            <summary>
            Creates a big integer containing the number specified.
            </summary>
            <exception cref="T:KeepCoding.Internal.NullIteratorException"></exception>
            <exception cref="T:System.NullReferenceException"></exception>
            <exception cref="T:KeepCoding.Internal.ConstructorArgumentException"></exception>
            <exception cref="T:KeepCoding.Internal.UnrecognizedValueException"></exception>
            <param name="value">The value to store. <see cref="T:System.Array"/>, <see cref="T:System.String"/>, and any number-type are compatible.</param>
        </member>
        <member name="P:KeepCoding.BigInteger.Item(System.Int32,System.Boolean)">
            <summary>
            Indexable number. Allows you to treat the value as an array.
            </summary>
            <exception cref="T:System.IndexOutOfRangeException"></exception>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
            <param name="index">The <paramref name="index"/>th digit to look from.</param>
            <param name="isLeftToRight">Determines if the index goes from left-to-right (<see langword="true"/>), or right-to-left (<see langword="false"/>).</param>
            <returns>The current value's <paramref name="index"/>th digit.</returns>
        </member>
        <member name="P:KeepCoding.BigInteger.IsNegative">
            <summary>
            Whether or not the number is negative.
            </summary>
        </member>
        <member name="P:KeepCoding.BigInteger.Length">
            <summary>
            The amount of digits of the value.
            </summary>
        </member>
        <member name="P:KeepCoding.BigInteger.GetLowerBound">
            <summary>
            The first digit's index.
            </summary>
        </member>
        <member name="P:KeepCoding.BigInteger.GetUpperBound">
            <summary>
            The last digit's index.
            </summary>
        </member>
        <member name="P:KeepCoding.BigInteger.Value">
            <summary>
            The number itself. The instance is duplicated so that the original BigInteger's value may not be modified directly.
            </summary>
        </member>
        <member name="P:KeepCoding.BigInteger.Zero">
            <summary>
            BigInteger with value zero. (Default value)
            </summary>
        </member>
        <member name="P:KeepCoding.BigInteger.One">
            <summary>
            BigInteger with value one.
            </summary>
        </member>
        <member name="M:KeepCoding.BigInteger.op_Equality(KeepCoding.BigInteger,KeepCoding.BigInteger)">
            <summary>
            Equals operator; determines if both integers contain the same value.
            </summary>
            <param name="bigIntegerA">The left-hand side operator</param>
            <param name="bigIntegerB">The right-hand side operator.</param>
            <returns>True if both are the same number.</returns>
        </member>
        <member name="M:KeepCoding.BigInteger.op_Equality(KeepCoding.BigInteger,System.Object)">
            <summary>
            Equals operator; determines if both integers contain the same value. The <see cref="T:System.Object"/> is casted as a <see cref="T:KeepCoding.BigInteger"/>.
            </summary>
            <param name="bigInteger">The left-hand side operator</param>
            <param name="value">The right-hand side operator.</param>
            <exception cref="T:KeepCoding.Internal.NullIteratorException"></exception>
            <exception cref="T:System.NullReferenceException"></exception>
            <exception cref="T:KeepCoding.Internal.ConstructorArgumentException"></exception>
            <exception cref="T:KeepCoding.Internal.UnrecognizedValueException"></exception>
            <returns>True if both are the same number.</returns>
        </member>
        <member name="M:KeepCoding.BigInteger.op_Equality(System.Object,KeepCoding.BigInteger)">
            <summary>
            Equals operator; determines if both integers contain the same value. The <see cref="T:System.Object"/> is casted as a <see cref="T:KeepCoding.BigInteger"/>.
            </summary>
            <param name="value">The left-hand side operator.</param>
            <param name="bigInteger">The right-hand side operator</param>
            <exception cref="T:KeepCoding.Internal.NullIteratorException"></exception>
            <exception cref="T:System.NullReferenceException"></exception>
            <exception cref="T:KeepCoding.Internal.ConstructorArgumentException"></exception>
            <exception cref="T:KeepCoding.Internal.UnrecognizedValueException"></exception>
            <returns>True if both are the same number.</returns>
        </member>
        <member name="M:KeepCoding.BigInteger.op_Inequality(KeepCoding.BigInteger,KeepCoding.BigInteger)">
            <summary>
            Not equals operator; determines if both integers do not contain the same value.
            </summary>
            <param name="bigIntegerA">The left-hand side operator</param>
            <param name="bigIntegerB">The right-hand side operator.</param>
            <returns>True if both are not the same number.</returns>
        </member>
        <member name="M:KeepCoding.BigInteger.op_Inequality(KeepCoding.BigInteger,System.Object)">
            <summary>
            Not equals operator; determines if both integers do not contain the same value. The <see cref="T:System.Object"/> is casted as a <see cref="T:KeepCoding.BigInteger"/>.
            </summary>
            <param name="bigInteger">The left-hand side operator</param>
            <param name="value">The right-hand side operator.</param>
            <exception cref="T:KeepCoding.Internal.NullIteratorException"></exception>
            <exception cref="T:System.NullReferenceException"></exception>
            <exception cref="T:KeepCoding.Internal.ConstructorArgumentException"></exception>
            <exception cref="T:KeepCoding.Internal.UnrecognizedValueException"></exception>
            <returns>True if both are not the same number.</returns>
        </member>
        <member name="M:KeepCoding.BigInteger.op_Inequality(System.Object,KeepCoding.BigInteger)">
            <summary>
            Not equals operator; determines if both integers do not contain the same value. The <see cref="T:System.Object"/> is casted as a <see cref="T:KeepCoding.BigInteger"/>.
            </summary>
            <param name="value">The left-hand side operator</param>
            <param name="bigInteger">The right-hand side operator.</param>
            <exception cref="T:KeepCoding.Internal.NullIteratorException"></exception>
            <exception cref="T:System.NullReferenceException"></exception>
            <exception cref="T:KeepCoding.Internal.ConstructorArgumentException"></exception>
            <exception cref="T:KeepCoding.Internal.UnrecognizedValueException"></exception>
            <returns>True if both are not the same number.</returns>
        </member>
        <member name="M:KeepCoding.BigInteger.op_GreaterThan(KeepCoding.BigInteger,KeepCoding.BigInteger)">
            <summary>
            More than operator; determines if left-hand side has a greater value than right-hand side.
            </summary>
            <param name="bigIntegerA">The left-hand side operator.</param>
            <param name="bigIntegerB">The right-hand side operator</param>
            <returns>True if <paramref name="bigIntegerA"/> is more than <paramref name="bigIntegerB"/>.</returns>
        </member>
        <member name="M:KeepCoding.BigInteger.op_GreaterThan(KeepCoding.BigInteger,System.Object)">
            <summary>
            More than operator; determines if left-hand side has a greater value than right-hand side.
            </summary>
            <param name="bigInteger">The left-hand side operator.</param>
            <param name="value">The right-hand side operator</param>
            <exception cref="T:KeepCoding.Internal.NullIteratorException"></exception>
            <exception cref="T:System.NullReferenceException"></exception>
            <exception cref="T:KeepCoding.Internal.ConstructorArgumentException"></exception>
            <exception cref="T:KeepCoding.Internal.UnrecognizedValueException"></exception>
            <returns>True if <paramref name="bigInteger"/> is more than <paramref name="value"/>.</returns>
        </member>
        <member name="M:KeepCoding.BigInteger.op_GreaterThan(System.Object,KeepCoding.BigInteger)">
            <summary>
            More than operator; determines if left-hand side has a greater value than right-hand side.
            </summary>
            <param name="value">The left-hand side operator.</param>
            <param name="bigInteger">The right-hand side operator</param>
            <exception cref="T:KeepCoding.Internal.NullIteratorException"></exception>
            <exception cref="T:System.NullReferenceException"></exception>
            <exception cref="T:KeepCoding.Internal.ConstructorArgumentException"></exception>
            <exception cref="T:KeepCoding.Internal.UnrecognizedValueException"></exception>
            <returns>True if <paramref name="value"/> is more than <paramref name="bigInteger"/>.</returns>
        </member>
        <member name="M:KeepCoding.BigInteger.op_LessThan(KeepCoding.BigInteger,KeepCoding.BigInteger)">
            <summary>
            Less than operator; determines if left-hand side has a lesser value than right-hand side.
            </summary>
            <param name="bigIntegerA">The left-hand side operator.</param>
            <param name="bigIntegerB">The right-hand side operator</param>
            <returns>True if <paramref name="bigIntegerA"/> is less than <paramref name="bigIntegerB"/>.</returns>
        </member>
        <member name="M:KeepCoding.BigInteger.op_LessThan(KeepCoding.BigInteger,System.Object)">
            <summary>
            Less than operator; determines if left-hand side has a lesser value than right-hand side.
            </summary>
            <param name="bigInteger">The left-hand side operator.</param>
            <param name="value">The right-hand side operator</param>
            <exception cref="T:KeepCoding.Internal.NullIteratorException"></exception>
            <exception cref="T:System.NullReferenceException"></exception>
            <exception cref="T:KeepCoding.Internal.ConstructorArgumentException"></exception>
            <exception cref="T:KeepCoding.Internal.UnrecognizedValueException"></exception>
            <returns>True if <paramref name="bigInteger"/> is less than <paramref name="value"/>.</returns>
        </member>
        <member name="M:KeepCoding.BigInteger.op_LessThan(System.Object,KeepCoding.BigInteger)">
            <summary>
            Less than operator; determines if left-hand side has a lesser value than right-hand side.
            </summary>
            <param name="value">The left-hand side operator.</param>
            <param name="bigInteger">The right-hand side operator</param>
            <exception cref="T:KeepCoding.Internal.NullIteratorException"></exception>
            <exception cref="T:System.NullReferenceException"></exception>
            <exception cref="T:KeepCoding.Internal.ConstructorArgumentException"></exception>
            <exception cref="T:KeepCoding.Internal.UnrecognizedValueException"></exception>
            <returns>True if <paramref name="value"/> is less than <paramref name="bigInteger"/>.</returns>
        </member>
        <member name="M:KeepCoding.BigInteger.op_GreaterThanOrEqual(KeepCoding.BigInteger,KeepCoding.BigInteger)">
            <summary>
            More than or equals operator; determines if left-hand side has a greater value or is equal to the right-hand side.
            </summary>
            <param name="bigIntegerA">The left-hand side operator.</param>
            <param name="bigIntegerB">The right-hand side operator</param>
            <returns>True if <paramref name="bigIntegerA"/> is more than or equal <paramref name="bigIntegerB"/>.</returns>
        </member>
        <member name="M:KeepCoding.BigInteger.op_GreaterThanOrEqual(KeepCoding.BigInteger,System.Object)">
            <summary>
            More than or equals operator; determines if left-hand side has a greater value or is equal to the right-hand side.
            </summary>
            <param name="bigInteger">The left-hand side operator.</param>
            <param name="value">The right-hand side operator</param>
            <exception cref="T:KeepCoding.Internal.NullIteratorException"></exception>
            <exception cref="T:System.NullReferenceException"></exception>
            <exception cref="T:KeepCoding.Internal.ConstructorArgumentException"></exception>
            <exception cref="T:KeepCoding.Internal.UnrecognizedValueException"></exception>
            <returns>True if <paramref name="bigInteger"/> is more than or equal <paramref name="value"/>.</returns>
        </member>
        <member name="M:KeepCoding.BigInteger.op_GreaterThanOrEqual(System.Object,KeepCoding.BigInteger)">
            <summary>
            More than or equals operator; determines if left-hand side has a greater value or is equal to the right-hand side.
            </summary>
            <param name="value">The left-hand side operator.</param>
            <param name="bigInteger">The right-hand side operator</param>
            <exception cref="T:KeepCoding.Internal.NullIteratorException"></exception>
            <exception cref="T:System.NullReferenceException"></exception>
            <exception cref="T:KeepCoding.Internal.ConstructorArgumentException"></exception>
            <exception cref="T:KeepCoding.Internal.UnrecognizedValueException"></exception>
            <returns>True if <paramref name="value"/> is more than or equal <paramref name="bigInteger"/>.</returns>
        </member>
        <member name="M:KeepCoding.BigInteger.op_LessThanOrEqual(KeepCoding.BigInteger,KeepCoding.BigInteger)">
            <summary>
            Less than or equals operator; determines if left-hand side has a lesser value or is equal to the right-hand side.
            </summary>
            <param name="bigIntegerA">The left-hand side operator.</param>
            <param name="bigIntegerB">The right-hand side operator</param>
            <returns>True if <paramref name="bigIntegerA"/> is less than or equal <paramref name="bigIntegerB"/>.</returns>
        </member>
        <member name="M:KeepCoding.BigInteger.op_LessThanOrEqual(KeepCoding.BigInteger,System.Object)">
            <summary>
            Less than or equals operator; determines if left-hand side has a lesser value or is equal to the right-hand side.
            </summary>
            <param name="bigInteger">The left-hand side operator.</param>
            <param name="value">The right-hand side operator</param>
            <exception cref="T:KeepCoding.Internal.NullIteratorException"></exception>
            <exception cref="T:System.NullReferenceException"></exception>
            <exception cref="T:KeepCoding.Internal.ConstructorArgumentException"></exception>
            <exception cref="T:KeepCoding.Internal.UnrecognizedValueException"></exception>
            <returns>True if <paramref name="bigInteger"/> is less than or equal <paramref name="value"/>.</returns>
        </member>
        <member name="M:KeepCoding.BigInteger.op_LessThanOrEqual(System.Object,KeepCoding.BigInteger)">
            <summary>
            Less than or equals operator; determines if left-hand side has a lesser value or is equal to the right-hand side.
            </summary>
            <param name="value">The left-hand side operator.</param>
            <param name="bigInteger">The right-hand side operator</param>
            <exception cref="T:KeepCoding.Internal.NullIteratorException"></exception>
            <exception cref="T:System.NullReferenceException"></exception>
            <exception cref="T:KeepCoding.Internal.ConstructorArgumentException"></exception>
            <exception cref="T:KeepCoding.Internal.UnrecognizedValueException"></exception>
            <returns>True if <paramref name="value"/> is less than or equal <paramref name="bigInteger"/>.</returns>
        </member>
        <member name="M:KeepCoding.BigInteger.op_UnaryPlus(KeepCoding.BigInteger)">
            <summary>
            Positive operator; returns itself.
            </summary>
            <param name="bigInteger">The number.</param>
            <returns>The number.</returns>
        </member>
        <member name="M:KeepCoding.BigInteger.op_UnaryNegation(KeepCoding.BigInteger)">
            <summary>
            Negative operator; inverts <see cref="P:KeepCoding.BigInteger.IsNegative"/>.
            </summary>
            <param name="bigInteger">The number.</param>
            <returns>The number, inverting <see cref="P:KeepCoding.BigInteger.IsNegative"/>.</returns>
        </member>
        <member name="M:KeepCoding.BigInteger.op_Increment(KeepCoding.BigInteger)">
            <summary>
            Addition operator; adds 1.
            </summary>
            <param name="bigInteger">The number.</param>
            <returns>The number + 1.</returns>
        </member>
        <member name="M:KeepCoding.BigInteger.op_Decrement(KeepCoding.BigInteger)">
            <summary>
            Subtraction operator; subtracts 1.
            </summary>
            <param name="bigInteger">The number.</param>
            <returns>The number - 1.</returns>
        </member>
        <member name="M:KeepCoding.BigInteger.op_Addition(KeepCoding.BigInteger,KeepCoding.BigInteger)">
            <summary>
            Add operator; gets the sum of 2 numbers.
            </summary>
            <param name="bigIntegerA">The left-hand side operator.</param>
            <param name="bigIntegerB">The right-hand side operator</param>
            <returns>The sum of both sides.</returns>
        </member>
        <member name="M:KeepCoding.BigInteger.op_Addition(KeepCoding.BigInteger,System.Object)">
            <summary>
            Add operator; gets the sum of 2 numbers.
            </summary>
            <param name="bigInteger">The left-hand side operator.</param>
            <param name="value">The right-hand side operator</param>
            <exception cref="T:KeepCoding.Internal.NullIteratorException"></exception>
            <exception cref="T:System.NullReferenceException"></exception>
            <exception cref="T:KeepCoding.Internal.ConstructorArgumentException"></exception>
            <exception cref="T:KeepCoding.Internal.UnrecognizedValueException"></exception>
            <returns>The sum of both sides.</returns>
        </member>
        <member name="M:KeepCoding.BigInteger.op_Addition(System.Object,KeepCoding.BigInteger)">
            <summary>
            Addition operator; gets the sum of 2 numbers.
            </summary>
            <param name="value">The left-hand side operator.</param>
            <param name="bigInteger">The right-hand side operator</param>
            <exception cref="T:KeepCoding.Internal.NullIteratorException"></exception>
            <exception cref="T:System.NullReferenceException"></exception>
            <exception cref="T:KeepCoding.Internal.ConstructorArgumentException"></exception>
            <exception cref="T:KeepCoding.Internal.UnrecognizedValueException"></exception>
            <returns>The sum of both sides.</returns>
        </member>
        <member name="M:KeepCoding.BigInteger.op_Subtraction(KeepCoding.BigInteger,KeepCoding.BigInteger)">
            <summary>
            Subtraction operator; gets the difference of 2 numbers.
            </summary>
            <param name="bigIntegerA">The left-hand side operator.</param>
            <param name="bigIntegerB">The right-hand side operator</param>
            <returns>The difference of both sides.</returns>
        </member>
        <member name="M:KeepCoding.BigInteger.op_Subtraction(KeepCoding.BigInteger,System.Object)">
            <summary>
            Subtraction operator; gets the difference of 2 numbers.
            </summary>
            <param name="bigInteger">The left-hand side operator.</param>
            <param name="value">The right-hand side operator</param>
            <exception cref="T:KeepCoding.Internal.NullIteratorException"></exception>
            <exception cref="T:System.NullReferenceException"></exception>
            <exception cref="T:KeepCoding.Internal.ConstructorArgumentException"></exception>
            <exception cref="T:KeepCoding.Internal.UnrecognizedValueException"></exception>
            <returns>The difference of both sides.</returns>
        </member>
        <member name="M:KeepCoding.BigInteger.op_Subtraction(System.Object,KeepCoding.BigInteger)">
            <summary>
            Subtraction operator; gets the difference of 2 numbers.
            </summary>
            <param name="value">The left-hand side operator.</param>
            <param name="bigInteger">The right-hand side operator</param>
            <exception cref="T:KeepCoding.Internal.NullIteratorException"></exception>
            <exception cref="T:System.NullReferenceException"></exception>
            <exception cref="T:KeepCoding.Internal.ConstructorArgumentException"></exception>
            <exception cref="T:KeepCoding.Internal.UnrecognizedValueException"></exception>
            <returns>The difference of both sides.</returns>
        </member>
        <member name="M:KeepCoding.BigInteger.op_Multiply(KeepCoding.BigInteger,KeepCoding.BigInteger)">
            <summary>
            Multiplication operator; gets the product of 2 numbers.
            </summary>
            <param name="bigIntegerA">The left-hand side operator.</param>
            <param name="bigIntegerB">The right-hand side operator</param>
            <returns>The product of both sides.</returns>
        </member>
        <member name="M:KeepCoding.BigInteger.op_Multiply(KeepCoding.BigInteger,System.Object)">
            <summary>
            Multiplication operator; gets the product of 2 numbers.
            </summary>
            <param name="bigInteger">The left-hand side operator.</param>
            <param name="value">The right-hand side operator</param>
            <exception cref="T:KeepCoding.Internal.NullIteratorException"></exception>
            <exception cref="T:System.NullReferenceException"></exception>
            <exception cref="T:KeepCoding.Internal.ConstructorArgumentException"></exception>
            <exception cref="T:KeepCoding.Internal.UnrecognizedValueException"></exception>
            <returns>The product of both sides.</returns>
        </member>
        <member name="M:KeepCoding.BigInteger.op_Multiply(System.Object,KeepCoding.BigInteger)">
            <summary>
            Multiplication operator; gets the product of 2 numbers.
            </summary>
            <param name="value">The left-hand side operator.</param>
            <param name="bigInteger">The right-hand side operator</param>
            <exception cref="T:KeepCoding.Internal.NullIteratorException"></exception>
            <exception cref="T:System.NullReferenceException"></exception>
            <exception cref="T:KeepCoding.Internal.ConstructorArgumentException"></exception>
            <exception cref="T:KeepCoding.Internal.UnrecognizedValueException"></exception>
            <returns>The product of both sides.</returns>
        </member>
        <member name="M:KeepCoding.BigInteger.op_Division(KeepCoding.BigInteger,KeepCoding.BigInteger)">
            <summary>
            Division operator; gets the quotient of 2 numbers.
            </summary>
            <param name="bigIntegerA">The left-hand side operator.</param>
            <param name="bigIntegerB">The right-hand side operator</param>
            <returns>The quotient of both sides.</returns>
        </member>
        <member name="M:KeepCoding.BigInteger.op_Division(KeepCoding.BigInteger,System.Object)">
            <summary>
            Division operator; gets the quotient of 2 numbers.
            </summary>
            <param name="bigInteger">The left-hand side operator.</param>
            <param name="value">The right-hand side operator</param>
            <exception cref="T:KeepCoding.Internal.NullIteratorException"></exception>
            <exception cref="T:System.NullReferenceException"></exception>
            <exception cref="T:KeepCoding.Internal.ConstructorArgumentException"></exception>
            <exception cref="T:KeepCoding.Internal.UnrecognizedValueException"></exception>
            <returns>The quotient of both sides.</returns>
        </member>
        <member name="M:KeepCoding.BigInteger.op_Division(System.Object,KeepCoding.BigInteger)">
            <summary>
            Division operator; gets the quotient of 2 numbers.
            </summary>
            <param name="value">The left-hand side operator.</param>
            <param name="bigInteger">The right-hand side operator</param>
            <exception cref="T:KeepCoding.Internal.NullIteratorException"></exception>
            <exception cref="T:System.NullReferenceException"></exception>
            <exception cref="T:KeepCoding.Internal.ConstructorArgumentException"></exception>
            <exception cref="T:KeepCoding.Internal.UnrecognizedValueException"></exception>
            <returns>The quotient of both sides.</returns>
        </member>
        <member name="M:KeepCoding.BigInteger.op_Modulus(KeepCoding.BigInteger,KeepCoding.BigInteger)">
            <summary>
            Modulo operator; gets the modulo of 2 numbers.
            </summary>
            <param name="bigIntegerA">The left-hand side operator.</param>
            <param name="bigIntegerB">The right-hand side operator</param>
            <returns>The modulo of both sides.</returns>
        </member>
        <member name="M:KeepCoding.BigInteger.op_Modulus(KeepCoding.BigInteger,System.Object)">
            <summary>
            Modulo operator; gets the modulo of 2 numbers.
            </summary>
            <param name="bigInteger">The left-hand side operator.</param>
            <param name="value">The right-hand side operator</param>
            <exception cref="T:KeepCoding.Internal.NullIteratorException"></exception>
            <exception cref="T:System.NullReferenceException"></exception>
            <exception cref="T:KeepCoding.Internal.ConstructorArgumentException"></exception>
            <exception cref="T:KeepCoding.Internal.UnrecognizedValueException"></exception>
            <returns>The modulo of both sides.</returns>
        </member>
        <member name="M:KeepCoding.BigInteger.op_Modulus(System.Object,KeepCoding.BigInteger)">
            <summary>
            Modulo operator; gets the modulo of 2 numbers.
            </summary>
            <param name="value">The left-hand side operator.</param>
            <param name="bigInteger">The right-hand side operator</param>
            <exception cref="T:KeepCoding.Internal.NullIteratorException"></exception>
            <exception cref="T:System.NullReferenceException"></exception>
            <exception cref="T:KeepCoding.Internal.ConstructorArgumentException"></exception>
            <exception cref="T:KeepCoding.Internal.UnrecognizedValueException"></exception>
            <returns>The modulo of both sides.</returns>
        </member>
        <member name="M:KeepCoding.BigInteger.op_Explicit(KeepCoding.BigInteger)~KeepCoding.Number">
            <summary>
            Converts the <see cref="T:KeepCoding.BigInteger"/> to a <see cref="T:KeepCoding.Number"/>.
            </summary>
            <exception cref="T:System.InvalidCastException"></exception>
            <param name="bigInteger">The instance of <see cref="T:KeepCoding.BigInteger"/> to convert.</param>
            <returns>Itself as <see cref="T:KeepCoding.Number"/>.</returns>
        </member>
        <member name="M:KeepCoding.BigInteger.op_Implicit(KeepCoding.Number)~KeepCoding.BigInteger">
            <summary>
            Converts the <see cref="T:KeepCoding.Number"/> to a <see cref="T:KeepCoding.BigInteger"/>.
            </summary>
            <param name="value">The value to convert into <see cref="T:KeepCoding.BigInteger"/>.</param>
            <returns><see cref="T:KeepCoding.BigInteger"/> with value <paramref name="value"/>.</returns>
        </member>
        <member name="M:KeepCoding.BigInteger.Equals(System.Object)">
            <summary>
            Determins if both values are equal.
            </summary>
            <param name="obj">The comparison.</param>
            <exception cref="T:KeepCoding.Internal.NullIteratorException"></exception>
            <exception cref="T:System.NullReferenceException"></exception>
            <exception cref="T:KeepCoding.Internal.ConstructorArgumentException"></exception>
            <exception cref="T:KeepCoding.Internal.UnrecognizedValueException"></exception>
            <returns>True if both values are equal.</returns>
        </member>
        <member name="M:KeepCoding.BigInteger.GetHashCode">
            <summary>
            Gets the hash code of the current values.
            </summary>
            <returns>The hash code.</returns>
        </member>
        <member name="M:KeepCoding.BigInteger.ToString">
            <summary>
            Converts the current array it stores as a string.
            </summary>
            <returns>The value of itself.</returns>
        </member>
        <member name="M:KeepCoding.BigInteger.Equals(KeepCoding.BigInteger)">
            <summary>
            Determins if both values are equal.
            </summary>
            <param name="other">The comparison.</param>
            <returns>True if both values are equal.</returns>
        </member>
        <member name="M:KeepCoding.BigInteger.IsBetween(KeepCoding.BigInteger,KeepCoding.BigInteger)">
            <summary>
            Determines if it is between 2 other <see cref="T:KeepCoding.BigInteger"/> variables. Equality will count as true.
            </summary>
            <param name="min">The minimum value accepted.</param>
            <param name="max">The maximum value accepted.</param>
            <returns>True if <paramref name="min"/> is smaller or equal itself and <paramref name="max"/> is greater or equal itself.</returns>
        </member>
        <member name="M:KeepCoding.BigInteger.IsBetween``1(``0,``0)">
            <summary>
            Determines if it is between 2 other variables. Equality will count as true.
            </summary>
            <param name="min">The minimum value accepted.</param>
            <param name="max">The maximum value accepted.</param>
            <exception cref="T:KeepCoding.Internal.NullIteratorException"></exception>
            <exception cref="T:System.NullReferenceException"></exception>
            <exception cref="T:KeepCoding.Internal.ConstructorArgumentException"></exception>
            <exception cref="T:KeepCoding.Internal.UnrecognizedValueException"></exception>
            <returns>True if <paramref name="min"/> is smaller or equal itself and <paramref name="max"/> is greater or equal itself.</returns>
        </member>
        <member name="M:KeepCoding.BigInteger.ToNumber">
            <summary>
            Converts the BigInteger to a <see cref="T:KeepCoding.Number"/>.
            </summary>
            <exception cref="T:System.InvalidCastException"></exception>
            <returns>Itself as <see cref="T:KeepCoding.Number"/>.</returns>
        </member>
        <member name="M:KeepCoding.BigInteger.Clone">
            <summary>
            Makes a new instance/deep clone of <see cref="T:KeepCoding.BigInteger"/> with the same value.
            </summary>
            <returns>A deep clone of itself.</returns>
        </member>
        <member name="M:KeepCoding.BigInteger.Clone(KeepCoding.BigInteger)">
            <summary>
            Makes a new instance/deep clone of <see cref="T:KeepCoding.BigInteger"/> with the same value.
            </summary>
            <param name="bigInteger">The <see cref="T:KeepCoding.BigInteger"/> to clone.</param>
            <returns>A deep clone of itself.</returns>
        </member>
        <member name="M:KeepCoding.BigInteger.Modulo(KeepCoding.BigInteger)">
            <summary>
            Calculates the rem-euclid modulo, which allows negative numbers to be properly calculated.
            </summary>
            <param name="bigInteger">The right-hand side operator.</param>
            <returns>Itself mod <paramref name="bigInteger"/>.</returns>
        </member>
        <member name="M:KeepCoding.BigInteger.Modulo``1(``0)">
            <summary>
            Calculates the rem-euclid modulo, which allows negative numbers to be properly calculated.
            </summary>
            <exception cref="T:System.DivideByZeroException"></exception>
            <exception cref="T:KeepCoding.Internal.NegativeNumberException"></exception>
            <exception cref="T:KeepCoding.Internal.NullIteratorException"></exception>
            <exception cref="T:System.NullReferenceException"></exception>
            <exception cref="T:KeepCoding.Internal.ConstructorArgumentException"></exception>
            <exception cref="T:KeepCoding.Internal.UnrecognizedValueException"></exception>
            <param name="obj">The right-hand side operator.</param>
            <returns>Itself mod <paramref name="obj"/>.</returns>
        </member>
        <member name="M:KeepCoding.BigInteger.GetEnumerator">
            <summary>
            Gets the enumerator of the <see cref="T:KeepCoding.BigInteger"/>, using <see cref="P:KeepCoding.BigInteger.Value"/>.
            </summary>
            <returns>The current number of this <see cref="T:KeepCoding.BigInteger"/>.</returns>
        </member>
        <member name="T:KeepCoding.ColorblindInfo">
            <summary>
            Contains information about the colorblind mod's info, this class can be used to deserialize "ColorblindMode.json".
            </summary>
        </member>
        <member name="M:KeepCoding.ColorblindInfo.#ctor(System.String)">
            <summary>
            Creates a <see cref="T:KeepCoding.ColorblindInfo"/> while read/writing the file.
            </summary>
            <param name="moduleId">The module's id to grab information from.</param>
        </member>
        <member name="P:KeepCoding.ColorblindInfo.IsEnabled">
            <summary>
            Determines whether colorblind mode is on.
            </summary>
        </member>
        <member name="P:KeepCoding.ColorblindInfo.IsModuleEnabled">
            <summary>
            Determines whether colorblind mode for the module is on.
            </summary>
        </member>
        <member name="P:KeepCoding.ColorblindInfo.File">
            <summary>
            The directory of the mod settings file.
            </summary>
        </member>
        <member name="P:KeepCoding.ColorblindInfo.Modules">
            <summary>
            Contains module ids and their colorblind states.
            </summary>
        </member>
        <member name="M:KeepCoding.ColorblindInfo.Equals(System.Object)">
            <summary>
            Determines if both objects are equal.
            </summary>
            <param name="obj">The comparison.</param>
            <returns>True if both of them are <see cref="T:KeepCoding.ColorblindInfo"/> and contain the same <see cref="P:KeepCoding.ColorblindInfo.IsEnabled"/> and <see cref="P:KeepCoding.ColorblindInfo.Modules"/>.</returns>
        </member>
        <member name="M:KeepCoding.ColorblindInfo.GetHashCode">
            <summary>
            Gets the hash code.
            </summary>
            <returns>The hash code.</returns>
        </member>
        <member name="M:KeepCoding.ColorblindInfo.ToString">
            <summary>
            Converts the object to a string.
            </summary>
            <returns><see cref="P:KeepCoding.ColorblindInfo.Modules"/> unwrapped with <see cref="M:KeepCoding.Helper.UnwrapToString``1(``0,System.Boolean,System.String)"/>.</returns>
        </member>
        <member name="M:KeepCoding.ColorblindInfo.Deserialize(System.String,Newtonsoft.Json.JsonSerializerSettings)">
            <summary>
            Deserializes a ColorblindMode.json file.
            </summary>
            <exception cref="T:System.ArgumentException"></exception>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:System.IO.DirectoryNotFoundException"></exception>
            <exception cref="T:System.IO.FileNotFoundException"></exception>
            <exception cref="T:System.IO.IOException"></exception>
            <exception cref="T:System.NotSupportedException"></exception>
            <exception cref="T:KeepCoding.Internal.NullIteratorException"></exception>
            <exception cref="T:System.NullReferenceException"></exception>
            <exception cref="T:System.IO.PathTooLongException"></exception>
            <exception cref="T:System.Security.SecurityException"></exception>
            <exception cref="T:System.UnauthorizedAccessException"></exception>
            <param name="path">The path of the file to deserialize.</param>
            <param name="settings">The settings for the serialization.</param>
            <returns><paramref name="path"/> deserialized as <see cref="T:KeepCoding.ColorblindInfo"/>.</returns>
        </member>
        <member name="T:KeepCoding.ComponentPool">
            <summary>
            A ComponentPool is a collection of Module Types. The generator will pick Count times from this list and instantiate a component of the chosen type.
            </summary>
        </member>
        <member name="T:KeepCoding.ComponentPool.ComponentSource">
            <summary>
            Controls where this pool will draw from (e.g. the base game modules, modules from mods, or both).
            </summary>
        </member>
        <member name="F:KeepCoding.ComponentPool.ComponentSource.Base">
            <summary>
            Indicates that the module is from the base game.
            </summary>
        </member>
        <member name="F:KeepCoding.ComponentPool.ComponentSource.Mods">
            <summary>
            Indicates that the module is from mods.
            </summary>
        </member>
        <member name="T:KeepCoding.ComponentPool.SpecialComponentTypeEnum">
            <summary>
            Controls whether the modules will be chosen dynamically at runtime from whatever modules are loaded (based on the ComponentSource). Set to "None" to select specific module types.
            </summary>
        </member>
        <member name="F:KeepCoding.ComponentPool.SpecialComponentTypeEnum.None">
            <summary>
            Indicates that the mission will choose a set of modules that are self-defined.
            </summary>
        </member>
        <member name="F:KeepCoding.ComponentPool.SpecialComponentTypeEnum.ALL_SOLVABLE">
            <summary>
            Indicates that the mission will randomly pull any of the game's loaded solvable modules.
            </summary>
        </member>
        <member name="F:KeepCoding.ComponentPool.SpecialComponentTypeEnum.ALL_NEEDY">
            <summary>
            Indicates that the mission will randomly pull any of the game's loaded needy modules.
            </summary>
        </member>
        <member name="T:KeepCoding.ComponentPool.ComponentTypeEnum">
            <summary>
            The module types in the base game.
            </summary>
        </member>
        <member name="F:KeepCoding.ComponentPool.ComponentTypeEnum.Empty">
            <summary>
            No module. Uses the bomb backing.
            </summary>
        </member>
        <member name="F:KeepCoding.ComponentPool.ComponentTypeEnum.Timer">
            <summary>
            The timer component.
            </summary>
        </member>
        <member name="F:KeepCoding.ComponentPool.ComponentTypeEnum.Wires">
            <summary>
            On the Subject of Wires.
            </summary>
            <remarks><seealso href="https://ktane.timwi.de/HTML/Wires.html"/></remarks>
        </member>
        <member name="F:KeepCoding.ComponentPool.ComponentTypeEnum.BigButton">
            <summary>
            On the Subject of The Button.
            </summary>
            <remarks><seealso href="https://ktane.timwi.de/HTML/The%20Button.html"/></remarks>
        </member>
        <member name="F:KeepCoding.ComponentPool.ComponentTypeEnum.Keypad">
            <summary>
            On the Subject of Keypads.
            </summary>
            <remarks><seealso href="https://ktane.timwi.de/HTML/Keypad.html"/></remarks>
        </member>
        <member name="F:KeepCoding.ComponentPool.ComponentTypeEnum.Simon">
            <summary>
            On the Subject of Simon Says. 
            </summary>
            <remarks><seealso href="https://ktane.timwi.de/HTML/Simon%20Says.html"/></remarks>
        </member>
        <member name="F:KeepCoding.ComponentPool.ComponentTypeEnum.WhosOnFirst">
            <summary>
            On the Subject of Who's on First.
            </summary>
            <remarks><seealso href="https://ktane.timwi.de/HTML/Who's%20On%20First.html"/></remarks>
        </member>
        <member name="F:KeepCoding.ComponentPool.ComponentTypeEnum.Memory">
            <summary>
            On the Subject of Memory.
            </summary>
            <remarks><seealso href="https://ktane.timwi.de/HTML/Memory.html"/></remarks>
        </member>
        <member name="F:KeepCoding.ComponentPool.ComponentTypeEnum.Morse">
            <summary>
            On the Subject of Morse Code.
            </summary>
            <remarks><seealso href="https://ktane.timwi.de/HTML/Morse%20Code.html"/></remarks>
        </member>
        <member name="F:KeepCoding.ComponentPool.ComponentTypeEnum.Venn">
            <summary>
            On the Subject of Complicated Wires.
            </summary>
            <remarks><seealso href="https://ktane.timwi.de/HTML/Complicated%20Wires.html"/></remarks>
        </member>
        <member name="F:KeepCoding.ComponentPool.ComponentTypeEnum.WireSequence">
            <summary>
            On the Subject of Wire Sequences.
            </summary>
            <remarks><seealso href="https://ktane.timwi.de/HTML/Wire%20Sequence.html"/></remarks>
        </member>
        <member name="F:KeepCoding.ComponentPool.ComponentTypeEnum.Maze">
            <summary>
            On the Subject of Mazes.
            </summary>
            <remarks><seealso href="https://ktane.timwi.de/HTML/Maze.html"/></remarks>
        </member>
        <member name="F:KeepCoding.ComponentPool.ComponentTypeEnum.Password">
            <summary>
            On the Subject of Passwords.
            </summary>
            <remarks><seealso href="https://ktane.timwi.de/HTML/Password.html"/></remarks>
        </member>
        <member name="F:KeepCoding.ComponentPool.ComponentTypeEnum.NeedyVentGas">
            <summary>
            On the Subject of Venting Gas.
            </summary>
            <remarks><seealso href="https://ktane.timwi.de/HTML/Venting%20Gas.html"/></remarks>
        </member>
        <member name="F:KeepCoding.ComponentPool.ComponentTypeEnum.NeedyCapacitor">
            <summary>
            On the Subject of Capacitor Discharge.
            </summary>
            <remarks><seealso href="https://ktane.timwi.de/HTML/Capacitor%20Discharge.html"/></remarks>
        </member>
        <member name="F:KeepCoding.ComponentPool.ComponentTypeEnum.NeedyKnob">
            <summary>
            On the Subject of Knobs.
            </summary>
            <remarks><seealso href="https://ktane.timwi.de/HTML/Knob.html"/></remarks>
        </member>
        <member name="F:KeepCoding.ComponentPool.ComponentTypeEnum.Mod">
            <summary>
            Any solvable modded module.
            </summary>
        </member>
        <member name="F:KeepCoding.ComponentPool.ComponentTypeEnum.NeedyMod">
            <summary>
            Any needy modded module.
            </summary>
        </member>
        <member name="P:KeepCoding.ComponentPool.Count">
            <summary>
            How many components from this pool should be selected.
            </summary>
        </member>
        <member name="P:KeepCoding.ComponentPool.AllowedSources">
            <summary>
            Controls where components can come from (either the base game, mods, or both).
            </summary>
        </member>
        <member name="P:KeepCoding.ComponentPool.SpecialComponentType">
            <summary>
            Special types which are calculated at runtime, such as <see cref="F:KeepCoding.ComponentPool.SpecialComponentTypeEnum.ALL_SOLVABLE"/>.
            </summary>
        </member>
        <member name="P:KeepCoding.ComponentPool.ModTypes">
            <summary>
            A list of mod types to be included in the pool, if they exist.
            </summary>
        </member>
        <member name="P:KeepCoding.ComponentPool.ComponentTypes">
            <summary>
            The list of component types, not including any calculated at runtime special types, like ALL_SOLVABLE. Use GetComponentTypes to get the calculated list.
            </summary>
        </member>
        <member name="M:KeepCoding.ComponentPool.ToString">
            <summary>
            Converts itself to a string.
            </summary>
            <returns>The list of mod types with a count at the end.</returns>
        </member>
        <member name="T:KeepCoding.GeneratorSetting">
            <summary>
            Everything needed to generate a single bomb.
            </summary>
        </member>
        <member name="M:KeepCoding.GeneratorSetting.#ctor">
            <summary>
            Creates a generator setting with the default parameters.
            </summary>
        </member>
        <member name="M:KeepCoding.GeneratorSetting.#ctor(System.Boolean,System.Int32,System.Int32,System.Int32,System.Single,System.Collections.Generic.List{KeepCoding.ComponentPool})">
            <summary>
            Creates a generator setting based on the provided parameters.
            </summary>
            <param name="frontFaceOnly">Force modules to be placed only on the front face. By default this will limit the module count to 5 (+1 for the timer). Useful in rare circumstances where you wish to generate a bomb with a few modules and guarantee that they will all be visibile simultaneously.</param>
            <param name="optionalWidgetCount">Set how many optional widgets (widgets other than serial number) that should be placed on the bomb.</param>
            <param name="numStrikes">The number of strikes at which the bomb explodes. Hardcore is 1. More forgiving is 3.</param>
            <param name="timeBeforeNeedyActivation">Time, in seconds, which must elapse before any unactivated Needy modules are automatically activated.</param>
            <param name="timeLimit">Initial value for the timer when the bomb is activated, in seconds.</param>
            <param name="componentPools">The pools of modules that will be used when generating a bomb.</param>
        </member>
        <member name="P:KeepCoding.GeneratorSetting.FrontFaceOnly">
            <summary>
            Force modules to be placed only on the front face. By default this will limit the module count to 5 (+1 for the timer). Useful in rare circumstances where you wish to generate a bomb with a few modules and guarantee that they will all be visibile simultaneously.
            </summary>
        </member>
        <member name="P:KeepCoding.GeneratorSetting.OptionalWidgetCount">
            <summary>
            Set how many optional widgets (widgets other than serial number) that should be placed on the bomb.
            </summary>
        </member>
        <member name="P:KeepCoding.GeneratorSetting.NumStrikes">
            <summary>
            The number of strikes at which the bomb explodes. Hardcore is 1. More forgiving is 3.
            </summary>
        </member>
        <member name="P:KeepCoding.GeneratorSetting.TimeBeforeNeedyActivation">
            <summary>
            Time, in seconds, which must elapse before any unactivated Needy modules are automatically activated.
            </summary>
        </member>
        <member name="P:KeepCoding.GeneratorSetting.TimeLimit">
            <summary>
            Initial value for the timer when the bomb is activated, in seconds.
            </summary>
        </member>
        <member name="P:KeepCoding.GeneratorSetting.ComponentPools">
            <summary>
            The pools of modules that will be used when generating a bomb.
            </summary>
        </member>
        <member name="M:KeepCoding.GeneratorSetting.GetComponentCount">
            <summary>
            The total count of modules that will be added according to the component pools.
            </summary>
            <returns>The amount of components.</returns>
        </member>
        <member name="M:KeepCoding.GeneratorSetting.ToString">
            <summary>
            Converts itself to a string.
            </summary>
            <returns>Time, number of strikes, and the pools converted to a string.</returns>
        </member>
        <member name="T:KeepCoding.Logger">
            <summary>
            A class to allow logging with a specific format.
            </summary>
        </member>
        <member name="M:KeepCoding.Logger.#ctor(System.String,System.Boolean,System.Boolean)">
            <summary>
            The string constructor. The string determines the name.
            </summary>
            <exception cref="T:KeepCoding.Internal.NullIteratorException"></exception>
            <exception cref="T:System.FormatException"></exception>
            <param name="name">The name of the value.</param>
            <param name="showId">Determines whether to show the unique identifier when logging.</param>
            <param name="showInLfa">Determines whether to format such that the Logfile Analyzer would use.</param>
        </member>
        <member name="M:KeepCoding.Logger.#ctor(System.Type,System.Boolean,System.Boolean)">
            <summary>
            The type constructor. The type's name determines the name.
            </summary>
            <param name="type">The name of the value, using <see cref="P:System.Reflection.MemberInfo.Name"/>.</param>
            <param name="showId">Determines whether to show the unique identifier when logging.</param>
            <param name="showInLfa">Determines whether to format such that the Logfile Analyzer would use.</param>
        </member>
        <member name="P:KeepCoding.Logger.Id">
            <summary>
            The unique identifier of the current name.
            </summary>
        </member>
        <member name="P:KeepCoding.Logger.Name">
            <summary>
            The name of the logger.
            </summary>
        </member>
        <member name="M:KeepCoding.Logger.Dump``1(``0,System.Boolean)">
            <summary>
            Dumps all information that it can find of the type using reflection. This should only be used to debug.
            </summary>
            <typeparam name="T">The type of component to reflect on.</typeparam>
            <param name="obj">The object to reflect on.</param>
            <param name="getVariables">Whether it should search recursively for the elements within the elements.</param>
        </member>
        <member name="M:KeepCoding.Logger.Dump(System.Boolean,System.Linq.Expressions.Expression{System.Func{System.Object}}[])">
            <summary>
            Dumps all information about the variables specified. Each element uses the syntax () => varName. This should only be used to debug.
            </summary>
            <param name="getVariables">Whether it should search recursively for the elements within the elements.</param>
            <param name="logs">All of the variables to throughly log.</param>
        </member>
        <member name="M:KeepCoding.Logger.Dump(System.Linq.Expressions.Expression{System.Func{System.Object}}[])">
            <summary>
            Dumps all information about the variables specified. Each element uses the syntax () => varName. This should only be used to debug.
            </summary>
            <param name="logs">All of the variables to throughly log.</param>
        </member>
        <member name="M:KeepCoding.Logger.Log``1(``0,UnityEngine.LogType)">
            <summary>
            Logs message, but formats it to be compliant with the Logfile Analyzer.
            </summary>
            <exception cref="T:KeepCoding.Internal.UnrecognizedValueException"></exception>
            <param name="message">The message to log.</param>
            <param name="logType">The type of logging. Different logging types have different icons within the editor.</param>
        </member>
        <member name="M:KeepCoding.Logger.Log``1(``0,System.Object[])">
            <summary>
            Logs multiple entries, but formats it to be compliant with the Logfile Analyzer.
            </summary>
            <exception cref="T:KeepCoding.Internal.UnrecognizedValueException"></exception>
            <param name="message">The message to log.</param>
            <param name="args">All of the arguments to embed into <paramref name="message"/>.</param>
        </member>
        <member name="M:KeepCoding.Logger.LogMultiple(System.String[])">
            <summary>
            Logs multiple entries to the console.
            </summary>
            <param name="logs">The array of logs to individual output into the console.</param>
        </member>
        <member name="M:KeepCoding.Logger.Equals(System.Object)">
            <summary>
            Determines if both objects are equal.
            </summary>
            <param name="obj">The comparison.</param>
            <returns>Whether both objects are equal.</returns>
        </member>
        <member name="M:KeepCoding.Logger.GetHashCode">
            <summary>
            Gets the hash code of the object.
            </summary>
            <returns>The hash code.</returns>
        </member>
        <member name="T:KeepCoding.ModInfo">
            <summary>
            Contains information about the mod's info, this class can be used to deserialize every mod's "modInfo.json".
            </summary>
        </member>
        <member name="P:KeepCoding.ModInfo.Author">
            <summary>
            Contains the author of the mod.
            </summary>
        </member>
        <member name="P:KeepCoding.ModInfo.Description">
            <summary>
            Contains the description of the mod.
            </summary>
        </member>
        <member name="P:KeepCoding.ModInfo.Id">
            <summary>
            Contains the ID of the mod, not to be mistaken with <see cref="P:KeepCoding.ModuleScript.Id"/>.
            </summary>
        </member>
        <member name="P:KeepCoding.ModInfo.Title">
            <summary>
            Contains the title of the mod.
            </summary>
        </member>
        <member name="P:KeepCoding.ModInfo.UnityVersion">
            <summary>
            Contains the current unity version of the mod.
            </summary>
        </member>
        <member name="P:KeepCoding.ModInfo.Version">
            <summary>
            Contains the current version of the mod.
            </summary>
        </member>
        <member name="P:KeepCoding.ModInfo.Values">
            <summary>
            Returns the current values of this <see cref="T:KeepCoding.ModInfo"/> as a dictionary, where the key is the variable name and the value is the variable value.
            </summary>
        </member>
        <member name="M:KeepCoding.ModInfo.Equals(System.Object)">
            <summary>
            Determines if both objects are equal.
            </summary>
            <param name="obj">The comparison.</param>
            <returns>True if both of them are <see cref="T:KeepCoding.ModInfo"/> and contain the same <see cref="P:KeepCoding.ModInfo.Values"/>.</returns>
        </member>
        <member name="M:KeepCoding.ModInfo.GetHashCode">
            <summary>
            Gets the hash code.
            </summary>
            <returns>The hash code.</returns>
        </member>
        <member name="M:KeepCoding.ModInfo.ToString">
            <summary>
            Converts the object to a string.
            </summary>
            <returns><see cref="P:KeepCoding.ModInfo.Values"/> unwrapped with <see cref="M:KeepCoding.Helper.UnwrapToString``1(``0,System.Boolean,System.String)"/>.</returns>
        </member>
        <member name="M:KeepCoding.ModInfo.Deserialize(System.String,Newtonsoft.Json.JsonSerializerSettings)">
            <summary>
            Deserializes a modInfo.json file.
            </summary>
            <exception cref="T:System.ArgumentException"></exception>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:System.IO.DirectoryNotFoundException"></exception>
            <exception cref="T:System.IO.FileNotFoundException"></exception>
            <exception cref="T:System.IO.IOException"></exception>
            <exception cref="T:System.NotSupportedException"></exception>
            <exception cref="T:KeepCoding.Internal.NullIteratorException"></exception>
            <exception cref="T:System.NullReferenceException"></exception>
            <exception cref="T:System.IO.PathTooLongException"></exception>
            <exception cref="T:System.Security.SecurityException"></exception>
            <exception cref="T:System.UnauthorizedAccessException"></exception>
            <param name="path">The path of the file to deserialize.</param>
            <param name="settings">The settings for the serialization.</param>
            <returns><paramref name="path"/> deserialized as <see cref="T:KeepCoding.ModInfo"/>.</returns>
        </member>
        <member name="T:KeepCoding.ModuleContainer">
            <summary>
            Container for both solvable and needy modules.
            </summary>
        </member>
        <member name="M:KeepCoding.ModuleContainer.#ctor(KeepCoding.CacheableBehaviour)">
            <summary>
            Encapsulates either a solvable or needy module. Uses <see cref="M:KeepCoding.CacheableBehaviour.Get``1(System.Boolean)"/>.
            </summary>
            <param name="behaviour">The component to get the modules from.</param>
        </member>
        <member name="M:KeepCoding.ModuleContainer.#ctor(UnityEngine.Component)">
            <summary>
            Encapsulates either a solvable or needy module. Uses <see cref="M:UnityEngine.Component.GetComponent``1"/>.
            </summary>
            <param name="component">The component to get the modules from.</param>
        </member>
        <member name="M:KeepCoding.ModuleContainer.#ctor(KMBombModule)">
            <summary>
            Encapsulates either a solvable module.
            </summary>
            <param name="solvable">The instance of a normal module.</param>
        </member>
        <member name="M:KeepCoding.ModuleContainer.#ctor(KMNeedyModule)">
            <summary>
            Encapsulates either a solvable module.
            </summary>
            <param name="needy">The instance of a needy module.</param>
        </member>
        <member name="M:KeepCoding.ModuleContainer.#ctor(KMBombModule,KMNeedyModule)">
            <summary>
            Encapsulates either a solvable or needy module.
            </summary>
            <exception cref="T:KeepCoding.Internal.ConstructorArgumentException"></exception>
            <param name="solvable">The instance of a normal module.</param>
            <param name="needy">The instance of a needy module.</param>
        </member>
        <member name="P:KeepCoding.ModuleContainer.RequiresTimerVisibility">
            <summary>
            Set to true to only allow this module to be placed on the same face as the timer. Useful when the rules involve the timer in some way (like the Big Button), but should be used sparingly as it limits generation possibilities.
            </summary>
            <exception cref="T:KeepCoding.Internal.UnrecognizedTypeException"></exception>
        </member>
        <member name="P:KeepCoding.ModuleContainer.Name">
            <summary>
            The nice display name shown to players. e.g. "The Button"
            </summary>
            <exception cref="T:KeepCoding.Internal.UnrecognizedTypeException"></exception>
        </member>
        <member name="P:KeepCoding.ModuleContainer.Id">
            <summary>
            The identifier for the module as referenced in missions. e.g. "BigButton" Also known as a "Module ID".
            </summary>
            <exception cref="T:KeepCoding.Internal.UnrecognizedTypeException"></exception>
        </member>
        <member name="P:KeepCoding.ModuleContainer.Solve">
            <summary>
            Call this when the entire module has been solved.
            </summary>
            <exception cref="T:KeepCoding.Internal.UnrecognizedTypeException"></exception>
        </member>
        <member name="P:KeepCoding.ModuleContainer.Strike">
            <summary>
            Call this on any mistake that you want to cause a bomb strike.
            </summary>
            <exception cref="T:KeepCoding.Internal.UnrecognizedTypeException"></exception>
        </member>
        <member name="P:KeepCoding.ModuleContainer.RuleGeneration">
            <summary>
            Returns the random seed used to generate the rules for this game. Not currently used.
            </summary>
            <exception cref="T:KeepCoding.Internal.UnrecognizedTypeException"></exception>
        </member>
        <member name="P:KeepCoding.ModuleContainer.Solvable">
            <summary>
            Returns <see cref="T:KMBombModule"/>, or if null, throws a <see cref="T:System.NullReferenceException"/>.
            </summary>
            <exception cref="T:System.NullReferenceException"></exception>
        </member>
        <member name="P:KeepCoding.ModuleContainer.Needy">
            <summary>
            Returns <see cref="T:KMNeedyModule"/>, or if null, throws a <see cref="T:System.NullReferenceException"/>.
            </summary>
            <exception cref="T:System.NullReferenceException"></exception>
        </member>
        <member name="P:KeepCoding.ModuleContainer.Module">
            <summary>
            Returns <see cref="T:KMBombModule"/>, or if null, <see cref="T:KMNeedyModule"/>.
            </summary>
        </member>
        <member name="M:KeepCoding.ModuleContainer.op_Implicit(KMBombModule)~KeepCoding.ModuleContainer">
            <summary>
            Creates a new instance of <see cref="T:KeepCoding.ModuleContainer"/> where <see cref="P:KeepCoding.ModuleContainer.Solvable"/> is defined.
            </summary>
            <param name="solvable">The solvable module to create a new <see cref="T:KeepCoding.ModuleContainer"/> of.</param>
            <returns>A <see cref="T:KeepCoding.ModuleContainer"/> with parameter <paramref name="solvable"/>.</returns>
        </member>
        <member name="M:KeepCoding.ModuleContainer.op_Implicit(KMNeedyModule)~KeepCoding.ModuleContainer">
            <summary>
            Creates a new instance of <see cref="T:KeepCoding.ModuleContainer"/> where <see cref="P:KeepCoding.ModuleContainer.Needy"/> is defined.
            </summary>
            <param name="needy">The needy module to create a new <see cref="T:KeepCoding.ModuleContainer"/> of.</param>
            <returns>A <see cref="T:KeepCoding.ModuleContainer"/> with parameter <paramref name="needy"/>.</returns>
        </member>
        <member name="M:KeepCoding.ModuleContainer.op_Explicit(KeepCoding.ModuleContainer)~KMBombModule">
            <summary>
            Returns the instance of <see cref="T:KMBombModule"/> from <see cref="P:KeepCoding.ModuleContainer.Solvable"/>.
            </summary>
            <param name="container">The <see cref="T:KeepCoding.ModuleContainer"/> to get the <see cref="T:KMBombModule"/> from.</param>
            <returns>A <see cref="T:KMBombModule"/> from <see cref="P:KeepCoding.ModuleContainer.Solvable"/>.</returns>
        </member>
        <member name="M:KeepCoding.ModuleContainer.op_Explicit(KeepCoding.ModuleContainer)~KMNeedyModule">
            <summary>
            Returns the instance of <see cref="T:KMNeedyModule"/> from <see cref="P:KeepCoding.ModuleContainer.Needy"/>.
            </summary>
            <param name="container">The <see cref="T:KeepCoding.ModuleContainer"/> to get the <see cref="T:KMNeedyModule"/> from.</param>
            <returns>A <see cref="T:KMBombModule"/> from <see cref="P:KeepCoding.ModuleContainer.Needy"/>.</returns>
        </member>
        <member name="M:KeepCoding.ModuleContainer.Assign(System.Action,System.Action,System.Action,System.Action,System.Action,System.Action)">
            <summary>
            Assigns events to a module container, replacing their values.
            </summary>
            <param name="onActivate">Called when the lights turn on.</param>
            <param name="onNeedyActivation">Called when the needy activates.</param>
            <param name="onNeedyDeactivation">Called when the needy deactivates.</param>
            <param name="onPass">Called when the needy is solved.</param>
            <param name="onStrike">Called when the needy strikes.</param>
            <param name="onTimerExpired">Called when the timer runs out of time.</param>
        </member>
        <member name="M:KeepCoding.ModuleContainer.OnActivate(System.Action)">
            <summary>
            Sets the action of OnActivate.
            </summary>
            <param name="action">The delegate to set.</param>
        </member>
        <member name="M:KeepCoding.ModuleContainer.Equals(System.Object)">
            <summary>
            Determines if both <see cref="T:KeepCoding.ModuleContainer"/> variables are equal.
            </summary>
            <param name="obj">The comparison.</param>
            <returns>True if both contain the same instance of <see cref="T:KMBombModule"/>, <c>null</c>, <see cref="T:KMNeedyModule"/></returns>
        </member>
        <member name="M:KeepCoding.ModuleContainer.Equals(KeepCoding.ModuleContainer)">
            <summary>
            Determines if both <see cref="T:KeepCoding.ModuleContainer"/> variables are equal.
            </summary>
            <param name="other">The comparison.</param>
            <returns>True if both contain the same instance of <see cref="T:KMBombModule"/>, <c>null</c>, <see cref="T:KMNeedyModule"/></returns>
        </member>
        <member name="M:KeepCoding.ModuleContainer.GetHashCode">
            <summary>
            Gets the current hash code.
            </summary>
            <returns>The <see cref="P:KeepCoding.ModuleContainer.Module"/>'s hash code.</returns>
        </member>
        <member name="T:KeepCoding.Number">
            <summary>
            Class meant to encapsulate a primitive numeric value.
            </summary>
        </member>
        <member name="M:KeepCoding.Number.#ctor(System.SByte)">
            <summary>
            Creates a <see cref="T:KeepCoding.Number"/> with the inner type <see cref="T:System.SByte"/>.
            </summary>
            <param name="value">The inner value stored.</param>
        </member>
        <member name="M:KeepCoding.Number.#ctor(System.Byte)">
            <summary>
            Creates a <see cref="T:KeepCoding.Number"/> with the inner type <see cref="T:System.Byte"/>.
            </summary>
            <param name="value">The inner value stored.</param>
        </member>
        <member name="M:KeepCoding.Number.#ctor(System.Int16)">
            <summary>
            Creates a <see cref="T:KeepCoding.Number"/> with the inner type <see cref="T:System.Int16"/>.
            </summary>
            <param name="value">The inner value stored.</param>
        </member>
        <member name="M:KeepCoding.Number.#ctor(System.UInt16)">
            <summary>
            Creates a <see cref="T:KeepCoding.Number"/> with the inner type <see cref="T:System.UInt16"/>.
            </summary>
            <param name="value">The inner value stored.</param>
        </member>
        <member name="M:KeepCoding.Number.#ctor(System.Int32)">
            <summary>
            Creates a <see cref="T:KeepCoding.Number"/> with the inner type <see cref="T:System.Int32"/>.
            </summary>
            <param name="value">The inner value stored.</param>
        </member>
        <member name="M:KeepCoding.Number.#ctor(System.UInt32)">
            <summary>
            Creates a <see cref="T:KeepCoding.Number"/> with the inner type <see cref="T:System.UInt32"/>.
            </summary>
            <param name="value">The inner value stored.</param>
        </member>
        <member name="M:KeepCoding.Number.#ctor(System.Int64)">
            <summary>
            Creates a <see cref="T:KeepCoding.Number"/> with the inner type <see cref="T:System.Int64"/>.
            </summary>
            <param name="value">The inner value stored.</param>
        </member>
        <member name="M:KeepCoding.Number.#ctor(System.UInt64)">
            <summary>
            Creates a <see cref="T:KeepCoding.Number"/> with the inner type <see cref="T:System.UInt64"/>.
            </summary>
            <param name="value">The inner value stored.</param>
        </member>
        <member name="M:KeepCoding.Number.#ctor(System.Single)">
            <summary>
            Creates a <see cref="T:KeepCoding.Number"/> with the inner type <see cref="T:System.Single"/>.
            </summary>
            <param name="value">The inner value stored.</param>
        </member>
        <member name="M:KeepCoding.Number.#ctor(System.Double)">
            <summary>
            Creates a <see cref="T:KeepCoding.Number"/> with the inner type <see cref="T:System.Double"/>.
            </summary>
            <param name="value">The inner value stored.</param>
        </member>
        <member name="M:KeepCoding.Number.#ctor(System.Decimal)">
            <summary>
            Creates a <see cref="T:KeepCoding.Number"/> with the inner type <see cref="T:System.Decimal"/>.
            </summary>
            <param name="value">The inner value stored.</param>
        </member>
        <member name="P:KeepCoding.Number.Epsilon">
            <summary>
            Returns the epsilon constant with precision based on the current type of the value.
            </summary>
            <remarks>
            Calling this will assume that the value is either <see cref="T:System.Single"/>, <see cref="T:System.Double"/>, or <see cref="T:System.Decimal"/>. An exception is thrown otherwise.
            </remarks>
        </member>
        <member name="P:KeepCoding.Number.MaxValue">
            <summary>
            Returns the biggest value of the current type of the value.
            </summary>
        </member>
        <member name="P:KeepCoding.Number.MinValue">
            <summary>
            Returns the smallest value of the current type of the value.
            </summary>
        </member>
        <member name="P:KeepCoding.Number.NaN">
            <summary>
            Returns the "not-a-number" constant.
            </summary>
            <remarks>
            Calling this will assume that the value is either <see cref="T:System.Single"/> or <see cref="T:System.Double"/>. An exception is thrown otherwise.
            </remarks>
        </member>
        <member name="P:KeepCoding.Number.NegativeInfinity">
            <summary>
            Returns the negative infinity constant.
            </summary>
            <remarks>
            Calling this will assume that the value is either <see cref="T:System.Single"/> or <see cref="T:System.Double"/>. An exception is thrown otherwise.
            </remarks>
        </member>
        <member name="P:KeepCoding.Number.PositiveInfinity">
            <summary>
            Returns the positive infinity constant.
            </summary>
            <remarks>
            Calling this will assume that the value is either <see cref="T:System.Single"/> or <see cref="T:System.Double"/>. An exception is thrown otherwise.
            </remarks>
        </member>
        <member name="M:KeepCoding.Number.op_UnaryPlus(KeepCoding.Number)">
            <summary>
            Plus operator.
            </summary>
            <remarks>
            <see cref="T:System.SByte"/>, <see cref="T:System.Byte"/>, <see cref="T:System.Int16"/>, and <see cref="T:System.UInt16"/> implicitly converts to <see cref="T:System.Int32"/>.
            </remarks>
            <param name="number">The number to apply the operator to.</param>
            <returns>The number with the operator applied to it.</returns>
        </member>
        <member name="M:KeepCoding.Number.op_UnaryNegation(KeepCoding.Number)">
            <summary>
            Minus operator.
            </summary>
            <remarks>
            <see cref="T:System.SByte"/>, <see cref="T:System.Byte"/>, <see cref="T:System.Int16"/>, and <see cref="T:System.UInt16"/> implicitly converts to <see cref="T:System.Int32"/>. <see cref="T:System.UInt32"/> implicitly converts to <see cref="T:System.Int64"/>. Calling this will assume that the value is not <see cref="T:System.UInt64"/>. An exception is thrown otherwise.
            </remarks>
            <param name="number">The number to apply the operator to.</param>
            <returns>The number with the operator applied to it.</returns>
        </member>
        <member name="M:KeepCoding.Number.op_OnesComplement(KeepCoding.Number)">
            <summary>
            Tilde operator.
            </summary>
            <remarks>
            <see cref="T:System.SByte"/>, <see cref="T:System.Byte"/>, <see cref="T:System.Int16"/>, and <see cref="T:System.UInt16"/> implicitly converts to <see cref="T:System.Int32"/>. <see cref="T:System.UInt32"/> implicitly converts to <see cref="T:System.Int64"/>. Calling this will assume that the value is not <see cref="T:System.Single"/>, <see cref="T:System.Double"/>, or <see cref="T:System.Decimal"/>. An exception is thrown otherwise.
            </remarks>
            <param name="number">The number to apply the operator to.</param>
            <returns>The number with the operator applied to it.</returns>
        </member>
        <member name="M:KeepCoding.Number.op_Increment(KeepCoding.Number)">
            <summary>
            Increment operator.
            </summary>
            <param name="number">The number to apply the operator to.</param>
            <returns>The number with the operator applied to it.</returns>
        </member>
        <member name="M:KeepCoding.Number.op_Decrement(KeepCoding.Number)">
            <summary>
            Decrement operator.
            </summary>
            <param name="number">The number to apply the operator to.</param>
            <returns>The number with the operator applied to it.</returns>
        </member>
        <member name="M:KeepCoding.Number.op_True(KeepCoding.Number)">
            <summary>
            True operator.
            </summary>
            <remarks>
            True if the number is strictly larger than zero.
            </remarks>
            <param name="number">The number to apply the operator to.</param>
            <returns>The number with the operator applied to it.</returns>
        </member>
        <member name="M:KeepCoding.Number.op_False(KeepCoding.Number)">
            <summary>
            False operator.
            </summary>
            <remarks>
            False if the operator is zero or less.
            </remarks>
            <param name="number">The number to apply the operator to.</param>
            <returns>The number with the operator applied to it.</returns>
        </member>
        <member name="M:KeepCoding.Number.op_Addition(KeepCoding.Number,KeepCoding.Number)">
            <summary>
            Add operator.
            </summary>
            <remarks>
            <see cref="T:System.SByte"/>, <see cref="T:System.Byte"/>, <see cref="T:System.Int16"/>, and <see cref="T:System.UInt16"/> implicitly converts to <see cref="T:System.Int32"/>.
            </remarks>
            <param name="number">The left-hand side of the operator.</param>
            <param name="other">The right-hand side of the operator.</param>
            <returns>A number representing the result of the two numbers applied with the operator.</returns>
        </member>
        <member name="M:KeepCoding.Number.op_Subtraction(KeepCoding.Number,KeepCoding.Number)">
            <summary>
            Subtract operator.
            </summary>
            <remarks>
            <see cref="T:System.SByte"/>, <see cref="T:System.Byte"/>, <see cref="T:System.Int16"/>, and <see cref="T:System.UInt16"/> implicitly converts to <see cref="T:System.Int32"/>.
            </remarks>
            <param name="number">The left-hand side of the operator.</param>
            <param name="other">The right-hand side of the operator.</param>
            <returns>A number representing the result of the two numbers applied with the operator.</returns>
        </member>
        <member name="M:KeepCoding.Number.op_Multiply(KeepCoding.Number,KeepCoding.Number)">
            <summary>
            Multiply operator.
            </summary>
            <remarks>
            <see cref="T:System.SByte"/>, <see cref="T:System.Byte"/>, <see cref="T:System.Int16"/>, and <see cref="T:System.UInt16"/> implicitly converts to <see cref="T:System.Int32"/>.
            </remarks>
            <param name="number">The left-hand side of the operator.</param>
            <param name="other">The right-hand side of the operator.</param>
            <returns>A number representing the result of the two numbers applied with the operator.</returns>
        </member>
        <member name="M:KeepCoding.Number.op_Division(KeepCoding.Number,KeepCoding.Number)">
            <summary>
            Divide operator.
            </summary>
            <remarks>
            <see cref="T:System.SByte"/>, <see cref="T:System.Byte"/>, <see cref="T:System.Int16"/>, and <see cref="T:System.UInt16"/> implicitly converts to <see cref="T:System.Int32"/>.
            </remarks>
            <param name="number">The left-hand side of the operator.</param>
            <param name="other">The right-hand side of the operator.</param>
            <returns>A number representing the result of the two numbers applied with the operator.</returns>
        </member>
        <member name="M:KeepCoding.Number.op_Modulus(KeepCoding.Number,KeepCoding.Number)">
            <summary>
            Modulo operator.
            </summary>
            <remarks>
            <see cref="T:System.SByte"/>, <see cref="T:System.Byte"/>, <see cref="T:System.Int16"/>, and <see cref="T:System.UInt16"/> implicitly converts to <see cref="T:System.Int32"/>.
            </remarks>
            <param name="number">The left-hand side of the operator.</param>
            <param name="other">The right-hand side of the operator.</param>
            <returns>A number representing the result of the two numbers applied with the operator.</returns>
        </member>
        <member name="M:KeepCoding.Number.op_BitwiseAnd(KeepCoding.Number,KeepCoding.Number)">
            <summary>
            And operator.
            </summary>
            <remarks>
            <see cref="T:System.SByte"/>, <see cref="T:System.Byte"/>, <see cref="T:System.Int16"/>, and <see cref="T:System.UInt16"/> implicitly converts to <see cref="T:System.Int32"/>. Calling this will assume that the value is not <see cref="T:System.Single"/>, <see cref="T:System.Double"/>, or <see cref="T:System.Decimal"/>. An exception is thrown otherwise.
            </remarks>
            <param name="number">The left-hand side of the operator.</param>
            <param name="other">The right-hand side of the operator.</param>
            <returns>A number representing the result of the two numbers applied with the operator.</returns>
        </member>
        <member name="M:KeepCoding.Number.op_BitwiseOr(KeepCoding.Number,KeepCoding.Number)">
            <summary>
            Or operator.
            </summary>
            <remarks>
            <see cref="T:System.SByte"/>, <see cref="T:System.Byte"/>, <see cref="T:System.Int16"/>, and <see cref="T:System.UInt16"/> implicitly converts to <see cref="T:System.Int32"/>. Calling this will assume that the value is not <see cref="T:System.Single"/>, <see cref="T:System.Double"/>, or <see cref="T:System.Decimal"/>. An exception is thrown otherwise.
            </remarks>
            <param name="number">The left-hand side of the operator.</param>
            <param name="other">The right-hand side of the operator.</param>
            <returns>A number representing the result of the two numbers applied with the operator.</returns>
        </member>
        <member name="M:KeepCoding.Number.op_ExclusiveOr(KeepCoding.Number,KeepCoding.Number)">
            <summary>
            Xor operator.
            </summary>
            <remarks>
            <see cref="T:System.SByte"/>, <see cref="T:System.Byte"/>, <see cref="T:System.Int16"/>, and <see cref="T:System.UInt16"/> implicitly converts to <see cref="T:System.Int32"/>. Calling this will assume that the value is not <see cref="T:System.Single"/>, <see cref="T:System.Double"/>, or <see cref="T:System.Decimal"/>. An exception is thrown otherwise.
            </remarks>
            <param name="number">The left-hand side of the operator.</param>
            <param name="other">The right-hand side of the operator.</param>
            <returns>A number representing the result of the two numbers applied with the operator.</returns>
        </member>
        <member name="M:KeepCoding.Number.op_LeftShift(KeepCoding.Number,System.Int32)">
            <summary>
            Left shift operator.
            </summary>
            <remarks>
            <see cref="T:System.SByte"/>, <see cref="T:System.Byte"/>, <see cref="T:System.Int16"/>, and <see cref="T:System.UInt16"/> implicitly converts to <see cref="T:System.Int32"/>. Calling this will assume that the value is <see cref="T:System.SByte"/>, <see cref="T:System.Byte"/>, <see cref="T:System.Int16"/>, <see cref="T:System.UInt16"/>, or <see cref="T:System.Int32"/>. An exception is thrown otherwise.
            </remarks>
            <param name="number">The left-hand side of the operator.</param>
            <param name="other">The right-hand side of the operator.</param>
            <returns>A number representing the result of the two numbers applied with the operator.</returns>
        </member>
        <member name="M:KeepCoding.Number.op_RightShift(KeepCoding.Number,System.Int32)">
            <summary>
            Right shift operator.
            </summary>
            <remarks>
            <see cref="T:System.SByte"/>, <see cref="T:System.Byte"/>, <see cref="T:System.Int16"/>, and <see cref="T:System.UInt16"/> implicitly converts to <see cref="T:System.Int32"/>. Calling this will assume that the value is <see cref="T:System.SByte"/>, <see cref="T:System.Byte"/>, <see cref="T:System.Int16"/>, <see cref="T:System.UInt16"/>, or <see cref="T:System.Int32"/>. An exception is thrown otherwise.
            </remarks>
            <param name="number">The left-hand side of the operator.</param>
            <param name="other">The right-hand side of the operator.</param>
            <returns>A number representing the result of the two numbers applied with the operator.</returns>
        </member>
        <member name="M:KeepCoding.Number.op_Equality(KeepCoding.Number,KeepCoding.Number)">
            <summary>
            Equals operator.
            </summary>
            <param name="number">The left-hand side of the operator.</param>
            <param name="other">The right-hand side of the operator.</param>
            <returns>A number representing the result of the two numbers applied with the operator.</returns>
        </member>
        <member name="M:KeepCoding.Number.op_Inequality(KeepCoding.Number,KeepCoding.Number)">
            <summary>
            Equals operator.
            </summary>
            <param name="number">The left-hand side of the operator.</param>
            <param name="other">The right-hand side of the operator.</param>
            <returns>A number representing the result of the two numbers applied with the operator.</returns>
        </member>
        <member name="M:KeepCoding.Number.op_LessThan(KeepCoding.Number,KeepCoding.Number)">
            <summary>
            Less than operator.
            </summary>
            <param name="number">The left-hand side of the operator.</param>
            <param name="other">The right-hand side of the operator.</param>
            <returns>A number representing the result of the two numbers applied with the operator.</returns>
        </member>
        <member name="M:KeepCoding.Number.op_LessThanOrEqual(KeepCoding.Number,KeepCoding.Number)">
            <summary>
            Less than or equal operator.
            </summary>
            <param name="number">The left-hand side of the operator.</param>
            <param name="other">The right-hand side of the operator.</param>
            <returns>A number representing the result of the two numbers applied with the operator.</returns>
        </member>
        <member name="M:KeepCoding.Number.op_GreaterThan(KeepCoding.Number,KeepCoding.Number)">
            <summary>
            More than operator.
            </summary>
            <param name="number">The left-hand side of the operator.</param>
            <param name="other">The right-hand side of the operator.</param>
            <returns>A number representing the result of the two numbers applied with the operator.</returns>
        </member>
        <member name="M:KeepCoding.Number.op_GreaterThanOrEqual(KeepCoding.Number,KeepCoding.Number)">
            <summary>
            More than or equal operator.
            </summary>
            <param name="number">The left-hand side of the operator.</param>
            <param name="other">The right-hand side of the operator.</param>
            <returns>A number representing the result of the two numbers applied with the operator.</returns>
        </member>
        <member name="M:KeepCoding.Number.op_Equality(KeepCoding.Number,System.ValueType)">
            <summary>
            Equals operator.
            </summary>
            <param name="number">The left-hand side of the operator.</param>
            <param name="other">The right-hand side of the operator.</param>
            <returns>A number representing the result of the two numbers applied with the operator.</returns>
        </member>
        <member name="M:KeepCoding.Number.op_Inequality(KeepCoding.Number,System.ValueType)">
            <summary>
            Equals operator.
            </summary>
            <param name="number">The left-hand side of the operator.</param>
            <param name="other">The right-hand side of the operator.</param>
            <returns>A number representing the result of the two numbers applied with the operator.</returns>
        </member>
        <member name="M:KeepCoding.Number.op_LessThan(KeepCoding.Number,System.ValueType)">
            <summary>
            Less than operator.
            </summary>
            <param name="number">The left-hand side of the operator.</param>
            <param name="other">The right-hand side of the operator.</param>
            <returns>A number representing the result of the two numbers applied with the operator.</returns>
        </member>
        <member name="M:KeepCoding.Number.op_LessThanOrEqual(KeepCoding.Number,System.ValueType)">
            <summary>
            Less than or equal operator.
            </summary>
            <param name="number">The left-hand side of the operator.</param>
            <param name="other">The right-hand side of the operator.</param>
            <returns>A number representing the result of the two numbers applied with the operator.</returns>
        </member>
        <member name="M:KeepCoding.Number.op_GreaterThan(KeepCoding.Number,System.ValueType)">
            <summary>
            More than operator.
            </summary>
            <param name="number">The left-hand side of the operator.</param>
            <param name="other">The right-hand side of the operator.</param>
            <returns>A number representing the result of the two numbers applied with the operator.</returns>
        </member>
        <member name="M:KeepCoding.Number.op_GreaterThanOrEqual(KeepCoding.Number,System.ValueType)">
            <summary>
            More than or equals operator.
            </summary>
            <param name="number">The left-hand side of the operator.</param>
            <param name="other">The right-hand side of the operator.</param>
            <returns>A number representing the result of the two numbers applied with the operator.</returns>
        </member>
        <member name="M:KeepCoding.Number.op_Explicit(KeepCoding.Number)~System.Boolean">
            <summary>
            Explicitly converts the value to a <see cref="T:System.Boolean"/>.
            </summary>
            <remarks>
            True if the number is strictly larger than zero, otherwise false.
            </remarks>
            <param name="number">The number to cast.</param>
        </member>
        <member name="M:KeepCoding.Number.op_Implicit(KeepCoding.Number)~System.SByte">
            <summary>
            Implicitly converts the value to a <see cref="T:System.SByte"/>.
            </summary>
            <remarks>
            Calling this will assume that the value is in inclusively between <see cref="F:System.SByte.MinValue"/> and <see cref="F:System.SByte.MaxValue"/>.
            </remarks>
            <param name="number">The number to cast.</param>
        </member>
        <member name="M:KeepCoding.Number.op_Implicit(KeepCoding.Number)~System.Byte">
            <summary>
            Implicitly converts the value to a <see cref="T:System.Byte"/>.
            </summary>
            <remarks>
            Calling this will assume that the value is in inclusively between <see cref="F:System.Byte.MinValue"/> and <see cref="F:System.Byte.MaxValue"/>.
            </remarks>
            <param name="number">The number to cast.</param>
        </member>
        <member name="M:KeepCoding.Number.op_Implicit(KeepCoding.Number)~System.Int16">
            <summary>
            Implicitly converts the value to a <see cref="T:System.Int16"/>.
            </summary>
            <remarks>
            Calling this will assume that the value is in inclusively between <see cref="F:System.Int16.MinValue"/> and <see cref="F:System.Int16.MaxValue"/>.
            </remarks>
            <param name="number">The number to cast.</param>
        </member>
        <member name="M:KeepCoding.Number.op_Implicit(KeepCoding.Number)~System.UInt16">
            <summary>
            Implicitly converts the value to a <see cref="T:System.UInt16"/>.
            </summary>
            <remarks>
            Calling this will assume that the value is in inclusively between <see cref="F:System.UInt16.MinValue"/> and <see cref="F:System.UInt16.MaxValue"/>.
            </remarks>
            <param name="number">The number to cast.</param>
        </member>
        <member name="M:KeepCoding.Number.op_Implicit(KeepCoding.Number)~System.Int32">
            <summary>
            Implicitly converts the value to a <see cref="T:System.Int32"/>.
            </summary>
            <remarks>
            Calling this will assume that the value is in inclusively between <see cref="F:System.Int32.MinValue"/> and <see cref="F:System.Int32.MaxValue"/>.
            </remarks>
            <param name="number">The number to cast.</param>
        </member>
        <member name="M:KeepCoding.Number.op_Implicit(KeepCoding.Number)~System.UInt32">
            <summary>
            Implicitly converts the value to a <see cref="T:System.UInt32"/>.
            </summary>
            <remarks>
            Calling this will assume that the value is in inclusively between <see cref="F:System.UInt32.MinValue"/> and <see cref="F:System.UInt32.MaxValue"/>.
            </remarks>
            <param name="number">The number to cast.</param>
        </member>
        <member name="M:KeepCoding.Number.op_Implicit(KeepCoding.Number)~System.Int64">
            <summary>
            Implicitly converts the value to a <see cref="T:System.Int64"/>.
            </summary>
            <remarks>
            Calling this will assume that the value is in inclusively between <see cref="F:System.Int64.MinValue"/> and <see cref="F:System.Int64.MaxValue"/>.
            </remarks>
            <param name="number">The number to cast.</param>
        </member>
        <member name="M:KeepCoding.Number.op_Implicit(KeepCoding.Number)~System.UInt64">
            <summary>
            Implicitly converts the value to a <see cref="T:System.UInt64"/>.
            </summary>
            <remarks>
            Calling this will assume that the value is in inclusively between <see cref="F:System.UInt64.MinValue"/> and <see cref="F:System.UInt64.MaxValue"/>.
            </remarks>
            <param name="number">The number to cast.</param>
        </member>
        <member name="M:KeepCoding.Number.op_Implicit(KeepCoding.Number)~System.Single">
            <summary>
            Implicitly converts the value to a <see cref="T:System.Single"/>.
            </summary>
            <param name="number">The number to cast.</param>
        </member>
        <member name="M:KeepCoding.Number.op_Implicit(KeepCoding.Number)~System.Double">
            <summary>
            Implicitly converts the value to a <see cref="T:System.Double"/>.
            </summary>
            <param name="number">The number to cast.</param>
        </member>
        <member name="M:KeepCoding.Number.op_Implicit(KeepCoding.Number)~System.Decimal">
            <summary>
            Implicitly converts the value to a <see cref="T:System.Decimal"/>.
            </summary>
            <param name="number">The number to cast.</param>
        </member>
        <member name="M:KeepCoding.Number.op_Implicit(KeepCoding.Number)~System.ValueType">
            <summary>
            Implicitly converts the value to a <see cref="T:System.ValueType"/>.
            </summary>
            <param name="number">The number to cast.</param>
        </member>
        <member name="M:KeepCoding.Number.op_Implicit(System.SByte)~KeepCoding.Number">
            <summary>
            Implicitly converts the value to a <see cref="T:KeepCoding.Number"/>.
            </summary>
            <param name="value">The value to use in the constructor.</param>
        </member>
        <member name="M:KeepCoding.Number.op_Implicit(System.Byte)~KeepCoding.Number">
            <summary>
            Implicitly converts the value to a <see cref="T:KeepCoding.Number"/>.
            </summary>
            <param name="value">The value to use in the constructor.</param>
        </member>
        <member name="M:KeepCoding.Number.op_Implicit(System.Int16)~KeepCoding.Number">
            <summary>
            Implicitly converts the value to a <see cref="T:KeepCoding.Number"/>.
            </summary>
            <param name="value">The value to use in the constructor.</param>
        </member>
        <member name="M:KeepCoding.Number.op_Implicit(System.UInt16)~KeepCoding.Number">
            <summary>
            Implicitly converts the value to a <see cref="T:KeepCoding.Number"/>.
            </summary>
            <param name="value">The value to use in the constructor.</param>
        </member>
        <member name="M:KeepCoding.Number.op_Implicit(System.Int32)~KeepCoding.Number">
            <summary>
            Implicitly converts the value to a <see cref="T:KeepCoding.Number"/>.
            </summary>
            <param name="value">The value to use in the constructor.</param>
        </member>
        <member name="M:KeepCoding.Number.op_Implicit(System.UInt32)~KeepCoding.Number">
            <summary>
            Implicitly converts the value to a <see cref="T:KeepCoding.Number"/>.
            </summary>
            <param name="value">The value to use in the constructor.</param>
        </member>
        <member name="M:KeepCoding.Number.op_Implicit(System.Int64)~KeepCoding.Number">
            <summary>
            Implicitly converts the value to a <see cref="T:KeepCoding.Number"/>.
            </summary>
            <param name="value">The value to use in the constructor.</param>
        </member>
        <member name="M:KeepCoding.Number.op_Implicit(System.UInt64)~KeepCoding.Number">
            <summary>
            Implicitly converts the value to a <see cref="T:KeepCoding.Number"/>.
            </summary>
            <param name="value">The value to use in the constructor.</param>
        </member>
        <member name="M:KeepCoding.Number.op_Implicit(System.Single)~KeepCoding.Number">
            <summary>
            Implicitly converts the value to a <see cref="T:KeepCoding.Number"/>.
            </summary>
            <param name="value">The value to use in the constructor.</param>
        </member>
        <member name="M:KeepCoding.Number.op_Implicit(System.Double)~KeepCoding.Number">
            <summary>
            Implicitly converts the value to a <see cref="T:KeepCoding.Number"/>.
            </summary>
            <param name="value">The value to use in the constructor.</param>
        </member>
        <member name="M:KeepCoding.Number.op_Implicit(System.Decimal)~KeepCoding.Number">
            <summary>
            Implicitly converts the value to a <see cref="T:KeepCoding.Number"/>.
            </summary>
            <param name="value">The value to use in the constructor.</param>
        </member>
        <member name="M:KeepCoding.Number.Equals(System.Object)">
            <summary>
            Determines if both items are equal in value.
            </summary>
            <param name="obj">The comparison.</param>
            <returns>True if both items share the same value.</returns>
        </member>
        <member name="M:KeepCoding.Number.Equals(KeepCoding.Number)">
            <summary>
            Determines if both items are equal in value.
            </summary>
            <param name="other">The comparison.</param>
            <returns>True if both items share the same value.</returns>
        </member>
        <member name="M:KeepCoding.Number.Equals(System.ValueType)">
            <summary>
            Determines if both items are equal in value.
            </summary>
            <param name="other">The comparison.</param>
            <returns>True if both items share the same value.</returns>
        </member>
        <member name="M:KeepCoding.Number.IsNaN">
            <summary>
            Determines if the value is not a number.
            </summary>
            <remarks>
            Calling this will assume that the value is either <see cref="T:System.Single"/> or <see cref="T:System.Double"/>. An exception is thrown otherwise.
            </remarks>
            <returns>True if the value is not a number.</returns>
        </member>
        <member name="M:KeepCoding.Number.TryParse(System.String,KeepCoding.Number@)">
            <summary>
            Attempts to parse a <see cref="T:System.String"/> as <see cref="T:KeepCoding.Number"/>.
            </summary>
            <remarks>
            The smallest possible type is used. The order of types from first-to-last are: <see cref="T:System.SByte"/>, <see cref="T:System.Byte"/>, <see cref="T:System.Int16"/>, <see cref="T:System.UInt16"/>, <see cref="T:System.Int32"/>, <see cref="T:System.UInt32"/>, <see cref="T:System.Int64"/>, <see cref="T:System.UInt64"/>, <see cref="T:System.Single"/>, <see cref="T:System.Double"/>, <see cref="T:System.Decimal"/>.
            </remarks>
            <param name="s">The <see cref="T:System.String"/> to parse.</param>
            <param name="number">The number to store the result in. An instance is returned if it is able to be casted successfully, and <see langword="null"/> otherwise.</param>
            <returns>True if it was able to successfully parse the string as a <see cref="T:KeepCoding.Number"/>.</returns>
        </member>
        <member name="M:KeepCoding.Number.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,KeepCoding.Number@)">
            <summary>
            Attempts to parse a <see cref="T:System.String"/> as <see cref="T:KeepCoding.Number"/>.
            </summary>
            <remarks>
            The smallest possible type is used. The order of types from first-to-last are: <see cref="T:System.SByte"/>, <see cref="T:System.Byte"/>, <see cref="T:System.Int16"/>, <see cref="T:System.UInt16"/>, <see cref="T:System.Int32"/>, <see cref="T:System.UInt32"/>, <see cref="T:System.Int64"/>, <see cref="T:System.UInt64"/>, <see cref="T:System.Single"/>, <see cref="T:System.Double"/>, <see cref="T:System.Decimal"/>.
            </remarks>
            <param name="s">The <see cref="T:System.String"/> to parse.</param>
            <param name="style">The <see cref="T:System.Globalization.NumberStyles"/> used for parsing.</param>
            <param name="provider">The <see cref="T:System.IFormatProvider"/> used for parsing.</param>
            <param name="number">The number to store the result in. An instance is returned if it is able to be casted successfully, and <see langword="null"/> otherwise.</param>
            <returns>True if it was able to successfully parse the string as a <see cref="T:KeepCoding.Number"/>.</returns>
        </member>
        <member name="M:KeepCoding.Number.TryParse(System.String,System.Globalization.NumberStyles,System.Globalization.NumberFormatInfo,KeepCoding.Number@)">
            <summary>
            Attempts to parse a <see cref="T:System.String"/> as <see cref="T:KeepCoding.Number"/>.
            </summary>
            <remarks>
            The smallest possible type is used. The order of types from first-to-last are: <see cref="T:System.SByte"/>, <see cref="T:System.Byte"/>, <see cref="T:System.Int16"/>, <see cref="T:System.UInt16"/>, <see cref="T:System.Int32"/>, <see cref="T:System.UInt32"/>, <see cref="T:System.Int64"/>, <see cref="T:System.UInt64"/>, <see cref="T:System.Single"/>, <see cref="T:System.Double"/>, <see cref="T:System.Decimal"/>.
            </remarks>
            <param name="s">The <see cref="T:System.String"/> to parse.</param>
            <param name="style">The <see cref="T:System.Globalization.NumberStyles"/> used for parsing.</param>
            <param name="info">The <see cref="T:System.Globalization.NumberFormatInfo"/> used for parsing.</param>
            <param name="number">The number to store the result in. An instance is returned if it is able to be casted successfully, and <see langword="null"/> otherwise.</param>
            <returns>True if it was able to successfully parse the string as a <see cref="T:KeepCoding.Number"/>.</returns>
        </member>
        <member name="M:KeepCoding.Number.CompareTo(System.Object)">
            <summary>
            Compares and determines the difference between both items.
            </summary>
            <param name="obj">The comparison.</param>
            <returns>The difference between both items.</returns>
        </member>
        <member name="M:KeepCoding.Number.CompareTo(KeepCoding.Number)">
            <summary>
            Compares and determines the difference between both items.
            </summary>
            <param name="other">The comparison.</param>
            <returns>The difference between both items.</returns>
        </member>
        <member name="M:KeepCoding.Number.CompareTo(System.ValueType)">
            <summary>
            Compares and determines the difference between both items.
            </summary>
            <param name="other">The comparison.</param>
            <returns>The difference between both items.</returns>
        </member>
        <member name="M:KeepCoding.Number.GetHashCode">
            <summary>
            Determines the hash code of the item, based on the value.
            </summary>
            <returns>The hash code.</returns>
        </member>
        <member name="M:KeepCoding.Number.ToString">
            <summary>
            Converts the value to a <see cref="T:System.String"/>.
            </summary>
            <returns>The value as <see cref="T:System.String"/>.</returns>
        </member>
        <member name="M:KeepCoding.Number.ToString(System.String)">
            <summary>
            Converts the value to a <see cref="T:System.String"/>.
            </summary>
            <param name="format">The <see cref="T:System.String"/> format of the <see cref="T:System.String"/>.</param>
            <returns>The value as <see cref="T:System.String"/>.</returns>
        </member>
        <member name="M:KeepCoding.Number.ToString(System.IFormatProvider)">
            <summary>
            Converts the value to a <see cref="T:System.String"/>.
            </summary>
            <param name="provider">The <see cref="T:System.IFormatProvider"/> format of the <see cref="T:System.String"/>.</param>
            <returns>The value as <see cref="T:System.String"/>.</returns>
        </member>
        <member name="M:KeepCoding.Number.ToString(System.String,System.IFormatProvider)">
            <summary>
            Converts the value to a <see cref="T:System.String"/>.
            </summary>
            <param name="format">The <see cref="T:System.String"/> format of the <see cref="T:System.String"/>.</param>
            <param name="provider">The <see cref="T:System.IFormatProvider"/> format of the <see cref="T:System.String"/>.</param>
            <returns>The value as <see cref="T:System.String"/>.</returns>
        </member>
        <member name="M:KeepCoding.Number.ToString(System.String,System.Globalization.NumberFormatInfo)">
            <summary>
            Converts the value to a <see cref="T:System.String"/>.
            </summary>
            <param name="format">The <see cref="T:System.String"/> format of the <see cref="T:System.String"/>.</param>
            <param name="info">The <see cref="T:System.Globalization.NumberFormatInfo"/> format of the <see cref="T:System.String"/>.</param>
            <returns>The value as <see cref="T:System.String"/>.</returns>
        </member>
        <member name="M:KeepCoding.Number.GetTypeCode">
            <summary>
            Determines the type of value it currently is within the <see cref="T:System.TypeCode"/> enum.
            </summary>
            <returns>The current type.</returns>
        </member>
        <member name="M:KeepCoding.Number.Modulo(KeepCoding.Number)">
            <summary>
            Calculates the rem-euclid modulo, which allows negative numbers to be properly calculated.
            </summary>
            <param name="other">The right-hand side operator.</param>
            <returns>Itself mod <paramref name="other"/>.</returns>
        </member>
        <member name="M:KeepCoding.Number.New``1(``0)">
            <summary>
            Creates a new <see cref="T:KeepCoding.Number"/> with the inner type being the type specified.
            </summary>
            <remarks>
            Calling this will assume that the value is <see cref="T:System.SByte"/>, <see cref="T:System.Byte"/>, <see cref="T:System.Int16"/>, and <see cref="T:System.UInt16"/>, <see cref="T:System.Int32"/>, <see cref="T:System.UInt32"/>, <see cref="T:System.Int64"/>, <see cref="T:System.UInt64"/>, <see cref="T:System.Single"/>, <see cref="T:System.Double"/>, or <see cref="T:System.Decimal"/>. An exception is thrown outherwise.
            </remarks>
            <exception cref="T:KeepCoding.Internal.UnrecognizedTypeException"></exception>
            <typeparam name="T">The inner type of the <see cref="T:KeepCoding.Number"/>.</typeparam>
            <returns>A <see cref="T:KeepCoding.Number"/> with inner <typeparamref name="T"/>.</returns>
        </member>
        <member name="M:KeepCoding.Number.Parse(System.String)">
            <summary>
            Parses a <see cref="T:System.String"/> as <see cref="T:KeepCoding.Number"/>. An exception is thrown if it fails.
            </summary>
            <remarks>
            The smallest possible type is used. The order of types from first-to-last are: <see cref="T:System.SByte"/>, <see cref="T:System.Byte"/>, <see cref="T:System.Int16"/>, <see cref="T:System.UInt16"/>, <see cref="T:System.Int32"/>, <see cref="T:System.UInt32"/>, <see cref="T:System.Int64"/>, <see cref="T:System.UInt64"/>, <see cref="T:System.Single"/>, <see cref="T:System.Double"/>, <see cref="T:System.Decimal"/>.
            </remarks>
            <param name="s">The <see cref="T:System.String"/> to parse.</param>
            <returns>The <see cref="T:System.String"/> as <see cref="T:KeepCoding.Number"/>.</returns>
        </member>
        <member name="M:KeepCoding.Number.Parse(System.String,System.Globalization.NumberStyles)">
            <summary>
            Parses a <see cref="T:System.String"/> as <see cref="T:KeepCoding.Number"/>. An exception is thrown if it fails.
            </summary>
            <param name="s">The <see cref="T:System.String"/> to parse.</param>
            <param name="style">The <see cref="T:System.Globalization.NumberStyles"/> used for parsing.</param>
            <returns>The <see cref="T:System.String"/> as <see cref="T:KeepCoding.Number"/>.</returns>
        </member>
        <member name="M:KeepCoding.Number.Parse(System.String,System.IFormatProvider)">
            <summary>
            Parses a <see cref="T:System.String"/> as <see cref="T:KeepCoding.Number"/>. An exception is thrown if it fails.
            </summary>
            <param name="s">The <see cref="T:System.String"/> to parse.</param>
            <param name="provider">The <see cref="T:System.IFormatProvider"/> used for parsing.</param>
            <returns>The <see cref="T:System.String"/> as <see cref="T:KeepCoding.Number"/>.</returns>
        </member>
        <member name="M:KeepCoding.Number.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
            <summary>
            Parses a <see cref="T:System.String"/> as <see cref="T:KeepCoding.Number"/>. An exception is thrown if it fails.
            </summary>
            <param name="s">The <see cref="T:System.String"/> to parse.</param>
            <param name="style">The <see cref="T:System.Globalization.NumberStyles"/> used for parsing.</param>
            <param name="provider">The <see cref="T:System.IFormatProvider"/> used for parsing.</param>
            <returns>The <see cref="T:System.String"/> as <see cref="T:KeepCoding.Number"/>.</returns>
        </member>
        <member name="M:KeepCoding.Number.Parse(System.String,System.Globalization.NumberStyles,System.Globalization.NumberFormatInfo)">
            <summary>
            Parses a <see cref="T:System.String"/> as <see cref="T:KeepCoding.Number"/>. An exception is thrown if it fails.
            </summary>
            <param name="s">The <see cref="T:System.String"/> to parse.</param>
            <param name="style">The <see cref="T:System.Globalization.NumberStyles"/> used for parsing.</param>
            <param name="info">The <see cref="T:System.Globalization.NumberFormatInfo"/> used for parsing.</param>
            <returns>The <see cref="T:System.String"/> as <see cref="T:KeepCoding.Number"/>.</returns>
        </member>
        <member name="M:KeepCoding.Number.Cast``1">
            <summary>
            Casts the <see cref="T:KeepCoding.Number"/> into the numeric type. Unlike implicit casting, the value will trim the bytes that cannot occupy the new datatype, such as a number being too large or decimals.
            </summary>
            <returns>Itself as <typeparamref name="T"/>.</returns>
        </member>
        <member name="T:KeepCoding.Routine">
            <summary>
            Advanced coroutine handler.
            </summary>
        </member>
        <member name="M:KeepCoding.Routine.#ctor(System.Func{System.Collections.IEnumerator},UnityEngine.MonoBehaviour)">
            <summary>
            Creates a list of coroutines so that you can start, restart, or stop any coroutine running inside this class.
            </summary>
            <param name="enumerator">The enumerator to call when initiated.</param>
            <param name="monoBehaviour">The MonoBehaviour to reference when calling the method.</param>
        </member>
        <member name="M:KeepCoding.Routine.Start(System.Boolean,System.Boolean)">
            <summary>
            Starts the coroutine. Unless specified by <paramref name="allowMultiple"/>, it will not be called if this class is in the middle of running the coroutine.
            </summary>
            <param name="allowMultiple">Determines whether it should be allowed to create another instance of the coroutine even if it's running another one.</param>
            <param name="oneByOne">If called multiple times, waits until the others are finished.</param>
        </member>
        <member name="M:KeepCoding.Routine.StartOrRestart(System.Boolean,System.Boolean)">
            <summary>
            Starts a coroutine if no coroutines are running, otherwise restarts.
            </summary>
            <param name="allowMultiple">Determines whether it should be allowed to create another instance of the coroutine even if it's running another one.</param>
            <param name="oneByOne">If called multiple times, waits until the others are finished.</param>
        </member>
        <member name="M:KeepCoding.Routine.Restart(System.Boolean)">
            <summary>
            Stops and restarts the first coroutine that was run.
            </summary>
            <exception cref="T:KeepCoding.Internal.EmptyIteratorException"></exception>
            <param name="oneByOne">If called multiple times, waits until the others are finished.</param>
        </member>
        <member name="M:KeepCoding.Routine.RestartAll(System.Boolean)">
            <summary>
            Restarts all coroutines currently running.
            </summary>
            <exception cref="T:KeepCoding.Internal.EmptyIteratorException"></exception>
            <param name="oneByOne">If called multiple times, waits until the others are finished.</param>
        </member>
        <member name="T:KeepCoding.Routine`1">
            <summary>
            Advanced coroutine handler. 
            </summary>
        </member>
        <member name="M:KeepCoding.Routine`1.#ctor(System.Func{`0,System.Collections.IEnumerator},UnityEngine.MonoBehaviour)">
            <summary>
            Creates a list of coroutines so that you can start, restart, or stop any coroutine running inside this class.
            </summary>
            <param name="enumerator">The enumerator to call when initiated.</param>
            <param name="monoBehaviour">The MonoBehaviour to reference when calling the method.</param>
        </member>
        <member name="M:KeepCoding.Routine`1.Start(`0,System.Boolean,System.Boolean)">
            <summary>
            Starts the coroutine. Unless specified by <paramref name="allowMultiple"/>, it will not be called if this class is in the middle of running the coroutine.
            </summary>
            <param name="t">The first argument to pass into the coroutine.</param>
            <param name="allowMultiple">Determines whether it should be allowed to create another instance of the coroutine even if it's running another one.</param>
            <param name="oneByOne">If called multiple times, waits until the others are finished.</param>
        </member>
        <member name="M:KeepCoding.Routine`1.StartOrRestart(`0,System.Boolean,System.Boolean)">
            <summary>
            Starts a coroutine if no coroutines are running, otherwise restarts.
            </summary>
            <param name="t">The first argument to pass into the coroutine.</param>
            <param name="allowMultiple">Determines whether it should be allowed to create another instance of the coroutine even if it's running another one.</param>
            <param name="oneByOne">If called multiple times, waits until the others are finished.</param>
        </member>
        <member name="M:KeepCoding.Routine`1.Restart(`0,System.Boolean)">
            <summary>
            Stops and restarts the first coroutine that was run.
            </summary>
            <param name="t">The first argument to pass into the coroutine.</param>
            <exception cref="T:KeepCoding.Internal.EmptyIteratorException"></exception>
            <param name="oneByOne">If called multiple times, waits until the others are finished.</param>
        </member>
        <member name="M:KeepCoding.Routine`1.RestartAll(`0,System.Boolean)">
            <summary>
            Restarts all coroutines currently running.
            </summary>
            <param name="t">The first argument to pass into the coroutine.</param>
            <exception cref="T:KeepCoding.Internal.EmptyIteratorException"></exception>
            <param name="oneByOne">If called multiple times, waits until the others are finished.</param>
        </member>
        <member name="T:KeepCoding.Routine`2">
            <summary>
            Advanced coroutine handler. 
            </summary>
        </member>
        <member name="M:KeepCoding.Routine`2.#ctor(System.Func{`0,`1,System.Collections.IEnumerator},UnityEngine.MonoBehaviour)">
            <summary>
            Creates a list of coroutines so that you can start, restart, or stop any coroutine running inside this class.
            </summary>
            <param name="enumerator">The enumerator to call when initiated.</param>
            <param name="monoBehaviour">The MonoBehaviour to reference when calling the method.</param>
        </member>
        <member name="M:KeepCoding.Routine`2.Start(`0,`1,System.Boolean,System.Boolean)">
            <summary>
            Starts the coroutine. Unless specified by <paramref name="allowMultiple"/>, it will not be called if this class is in the middle of running the coroutine.
            </summary>
            <param name="t1">The first argument to pass into the coroutine.</param>
            <param name="t2">The second argument to pass into the coroutine.</param>
            <param name="allowMultiple">Determines whether it should be allowed to create another instance of the coroutine even if it's running another one.</param>
            <param name="oneByOne">If called multiple times, waits until the others are finished.</param>
        </member>
        <member name="M:KeepCoding.Routine`2.StartOrRestart(`0,`1,System.Boolean,System.Boolean)">
            <summary>
            Starts a coroutine if no coroutines are running, otherwise restarts.
            </summary>
            <param name="t1">The first argument to pass into the coroutine.</param>
            <param name="t2">The second argument to pass into the coroutine.</param>
            <param name="allowMultiple">Determines whether it should be allowed to create another instance of the coroutine even if it's running another one.</param>
            <param name="oneByOne">If called multiple times, waits until the others are finished.</param>
        </member>
        <member name="M:KeepCoding.Routine`2.Restart(`0,`1,System.Boolean)">
            <summary>
            Stops and restarts the first coroutine that was run.
            </summary>
            <exception cref="T:KeepCoding.Internal.EmptyIteratorException"></exception>
            <param name="t1">The first argument to pass into the coroutine.</param>
            <param name="t2">The second argument to pass into the coroutine.</param>
            <param name="oneByOne">If called multiple times, waits until the others are finished.</param>
        </member>
        <member name="M:KeepCoding.Routine`2.RestartAll(`0,`1,System.Boolean)">
            <summary>
            Restarts all coroutines currently running.
            </summary>
            <exception cref="T:KeepCoding.Internal.EmptyIteratorException"></exception>
            <param name="t1">The first argument to pass into the coroutine.</param>
            <param name="t2">The second argument to pass into the coroutine.</param>
            <param name="oneByOne">If called multiple times, waits until the others are finished.</param>
        </member>
        <member name="T:KeepCoding.Routine`3">
            <summary>
            Advanced coroutine handler. 
            </summary>
        </member>
        <member name="M:KeepCoding.Routine`3.#ctor(System.Func{`0,`1,`2,System.Collections.IEnumerator},UnityEngine.MonoBehaviour)">
            <summary>
            Creates a list of coroutines so that you can start, restart, or stop any coroutine running inside this class.
            </summary>
            <param name="enumerator">The enumerator to call when initiated.</param>
            <param name="monoBehaviour">The MonoBehaviour to reference when calling the method.</param>
        </member>
        <member name="M:KeepCoding.Routine`3.Start(`0,`1,`2,System.Boolean,System.Boolean)">
            <summary>
            Starts the coroutine. Unless specified by <paramref name="allowMultiple"/>, it will not be called if this class is in the middle of running the coroutine.
            </summary>
            <param name="t1">The first argument to pass into the coroutine.</param>
            <param name="t2">The second argument to pass into the coroutine.</param>
            <param name="t3">The third argument to pass into the coroutine.</param>
            <param name="allowMultiple">Determines whether it should be allowed to create another instance of the coroutine even if it's running another one.</param>
            <param name="oneByOne">If called multiple times, waits until the others are finished.</param>
        </member>
        <member name="M:KeepCoding.Routine`3.StartOrRestart(`0,`1,`2,System.Boolean,System.Boolean)">
            <summary>
            Starts a coroutine if no coroutines are running, otherwise restarts.
            </summary>
            <param name="t1">The first argument to pass into the coroutine.</param>
            <param name="t2">The second argument to pass into the coroutine.</param>
            <param name="t3">The third argument to pass into the coroutine.</param>
            <param name="allowMultiple">Determines whether it should be allowed to create another instance of the coroutine even if it's running another one.</param>
            <param name="oneByOne">If called multiple times, waits until the others are finished.</param>
        </member>
        <member name="M:KeepCoding.Routine`3.Restart(`0,`1,`2,System.Boolean)">
            <summary>
            Stops and restarts the first coroutine that was run.
            </summary>
            <param name="t1">The first argument to pass into the coroutine.</param>
            <param name="t2">The second argument to pass into the coroutine.</param>
            <param name="t3">The third argument to pass into the coroutine.</param>
            <exception cref="T:KeepCoding.Internal.EmptyIteratorException"></exception>
            <param name="oneByOne">If called multiple times, waits until the others are finished.</param>
        </member>
        <member name="M:KeepCoding.Routine`3.RestartAll(`0,`1,`2,System.Boolean)">
            <summary>
            Restarts all coroutines currently running.
            </summary>
            <param name="t1">The first argument to pass into the coroutine.</param>
            <param name="t2">The second argument to pass into the coroutine.</param>
            <param name="t3">The third argument to pass into the coroutine.</param>
            <exception cref="T:KeepCoding.Internal.EmptyIteratorException"></exception>
            <param name="oneByOne">If called multiple times, waits until the others are finished.</param>
        </member>
        <member name="T:KeepCoding.Routine`4">
            <summary>
            Advanced coroutine handler. 
            </summary>
        </member>
        <member name="M:KeepCoding.Routine`4.#ctor(System.Func{`0,`1,`2,`3,System.Collections.IEnumerator},UnityEngine.MonoBehaviour)">
            <summary>
            Creates a list of coroutines so that you can start, restart, or stop any coroutine running inside this class.
            </summary>
            <param name="enumerator">The enumerator to call when initiated.</param>
            <param name="monoBehaviour">The MonoBehaviour to reference when calling the method.</param>
        </member>
        <member name="M:KeepCoding.Routine`4.Start(`0,`1,`2,`3,System.Boolean,System.Boolean)">
            <summary>
            Starts the coroutine. Unless specified by <paramref name="allowMultiple"/>, it will not be called if this class is in the middle of running the coroutine.
            </summary>
            <param name="t1">The first argument to pass into the coroutine.</param>
            <param name="t2">The second argument to pass into the coroutine.</param>
            <param name="t3">The third argument to pass into the coroutine.</param>
            <param name="t4">The fourth argument to pass into the coroutine.</param>
            <param name="allowMultiple">Determines whether it should be allowed to create another instance of the coroutine even if it's running another one.</param>
            <param name="oneByOne">If called multiple times, waits until the others are finished.</param>
        </member>
        <member name="M:KeepCoding.Routine`4.StartOrRestart(`0,`1,`2,`3,System.Boolean,System.Boolean)">
            <summary>
            Starts a coroutine if no coroutines are running, otherwise restarts.
            </summary>
            <param name="t1">The first argument to pass into the coroutine.</param>
            <param name="t2">The second argument to pass into the coroutine.</param>
            <param name="t3">The third argument to pass into the coroutine.</param>
            <param name="t4">The fourth argument to pass into the coroutine.</param>
            <param name="allowMultiple">Determines whether it should be allowed to create another instance of the coroutine even if it's running another one.</param>
            <param name="oneByOne">If called multiple times, waits until the others are finished.</param>
        </member>
        <member name="M:KeepCoding.Routine`4.Restart(`0,`1,`2,`3,System.Boolean)">
            <summary>
            Stops and restarts the first coroutine that was run.
            </summary>
            <param name="t1">The first argument to pass into the coroutine.</param>
            <param name="t2">The second argument to pass into the coroutine.</param>
            <param name="t3">The third argument to pass into the coroutine.</param>
            <param name="t4">The fourth argument to pass into the coroutine.</param>
            <exception cref="T:KeepCoding.Internal.EmptyIteratorException"></exception>
            <param name="oneByOne">If called multiple times, waits until the others are finished.</param>
        </member>
        <member name="M:KeepCoding.Routine`4.RestartAll(`0,`1,`2,`3,System.Boolean)">
            <summary>
            Restarts all coroutines currently running.
            </summary>
            <param name="t1">The first argument to pass into the coroutine.</param>
            <param name="t2">The second argument to pass into the coroutine.</param>
            <param name="t3">The third argument to pass into the coroutine.</param>
            <param name="t4">The fourth argument to pass into the coroutine.</param>
            <exception cref="T:KeepCoding.Internal.EmptyIteratorException"></exception>
            <param name="oneByOne">If called multiple times, waits until the others are finished.</param>
        </member>
        <member name="T:KeepCoding.Sound">
            <summary>
            Class meant to encapsulate all types of sound effects <see cref="T:KMAudio"/> uses. Currently used in <see cref="T:KeepCoding.ModuleScript"/>.
            </summary>
        </member>
        <member name="M:KeepCoding.Sound.#ctor(System.String)">
            <summary>
            An instance of Sound where <see cref="P:KeepCoding.Sound.Custom"/> is defined.
            </summary>
            <param name="sound">The sound to insert.</param>
        </member>
        <member name="M:KeepCoding.Sound.#ctor(UnityEngine.AudioClip)">
            <summary>
            An instance of Sound where <see cref="P:KeepCoding.Sound.Custom"/> is defined.
            </summary>
            <param name="sound">The sound to insert.</param>
        </member>
        <member name="M:KeepCoding.Sound.#ctor(KMSoundOverride.SoundEffect)">
            <summary>
            An instance of sound where <see cref="P:KeepCoding.Sound.Game"/> is defined.
            </summary>
            <param name="sound">The sound to insert.</param>
        </member>
        <member name="P:KeepCoding.Sound.Custom">
            <summary>
            The custom sound, written out by name.
            </summary>
        </member>
        <member name="P:KeepCoding.Sound.Game">
            <summary>
            The in-game sound.
            </summary>
        </member>
        <member name="P:KeepCoding.Sound.Reference">
            <summary>
            The audio reference that is playing the sound.
            </summary>
        </member>
        <member name="P:KeepCoding.Sound.AlarmClockBeep">
            <summary>
            Plays when the alarm clock goes off. This sound loops.
            </summary>
        </member>
        <member name="P:KeepCoding.Sound.AlarmClockSnooze">
            <summary>
            Plays when you hit snooze button on the alarm clock.
            </summary>
        </member>
        <member name="P:KeepCoding.Sound.BigButtonPress">
            <summary>
            Plays when pressing down the button on the Big Button vanilla module.
            </summary>
        </member>
        <member name="P:KeepCoding.Sound.BigButtonRelease">
            <summary>
            Plays when releasing the button on the Big Button vanilla module.
            </summary>
        </member>
        <member name="P:KeepCoding.Sound.BinderDrop">
            <summary>
            Plays as the mission binder hits the desk.
            </summary>
        </member>
        <member name="P:KeepCoding.Sound.BombDefused">
            <summary>
            Plays immediately after a bomb is defused. Plays before <see cref="F:KMSoundOverride.SoundEffect.GameOverFanfare"/>.
            </summary>
        </member>
        <member name="P:KeepCoding.Sound.BombDrop">
            <summary>
            Plays when the bomb is set down on the desk.
            </summary>
        </member>
        <member name="P:KeepCoding.Sound.BombExplode">
            <summary>
            Plays when the bomb explodes.
            </summary>
        </member>
        <member name="P:KeepCoding.Sound.BriefcaseClose">
            <summary>
            Plays when the freeplay briefcase is closed.
            </summary>
        </member>
        <member name="P:KeepCoding.Sound.BriefcaseOpen">
            <summary>
            Plays when the freeplay briefcase is opened.
            </summary>
        </member>
        <member name="P:KeepCoding.Sound.ButtonPress">
            <summary>
            Plays when pressing down a button.
            </summary>
        </member>
        <member name="P:KeepCoding.Sound.ButtonRelease">
            <summary>
            Plays when releasing a button.
            </summary>
        </member>
        <member name="P:KeepCoding.Sound.CapacitorPop">
            <summary>
            Plays when Capacitor Discharge fills up completely.
            </summary>
        </member>
        <member name="P:KeepCoding.Sound.CorrectChime">
            <summary>
            Plays in the tutorial for completing a step correctly.
            </summary>
        </member>
        <member name="P:KeepCoding.Sound.DossierOptionPressed">
            <summary>
            Plays when you change a setting in the menu folder.
            </summary>
        </member>
        <member name="P:KeepCoding.Sound.EmergencyAlarm">
            <summary>
            Plays when there is less than a minute left on the bomb, this sound loops.
            </summary>
        </member>
        <member name="P:KeepCoding.Sound.FastestTimerBeep">
            <summary>
            Plays when the bomb has at least 2 or more strikes.
            </summary>
        </member>
        <member name="P:KeepCoding.Sound.FastTimerBeep">
            <summary>
            Plays when the bomb has 1 strike.
            </summary>
        </member>
        <member name="P:KeepCoding.Sound.FreeplayDeviceDrop">
            <summary>
            Plays as the freeplay briefcase hits the desk.
            </summary>
        </member>
        <member name="P:KeepCoding.Sound.GameOverFanfare">
            <summary>
            Plays when all bombs are defused. Finishes before the post game screen.
            </summary>
        </member>
        <member name="P:KeepCoding.Sound.LightBuzz">
            <summary>
            Plays when the lights go out.
            </summary>
        </member>
        <member name="P:KeepCoding.Sound.LightBuzzShort">
            <summary>
            Plays when the lights start to come back on.
            </summary>
        </member>
        <member name="P:KeepCoding.Sound.MenuButtonPressed">
            <summary>
            Plays when you start a mission from the mission binder.
            </summary>
        </member>
        <member name="P:KeepCoding.Sound.MenuDrop">
            <summary>
            Plays as the mission folder hits the desk.
            </summary>
        </member>
        <member name="P:KeepCoding.Sound.NeedyActivated">
            <summary>
            Plays when a needy gets activated.
            </summary>
        </member>
        <member name="P:KeepCoding.Sound.NeedyWarning">
            <summary>
            Plays when a needy is running out of time. This sound loops.
            </summary>
        </member>
        <member name="P:KeepCoding.Sound.NormalTimerBeep">
            <summary>
            Plays when the bomb has no strikes.
            </summary>
        </member>
        <member name="P:KeepCoding.Sound.PageTurn">
            <summary>
            Plays when a page is turned in the Missions binder.
            </summary>
        </member>
        <member name="P:KeepCoding.Sound.SelectionTick">
            <summary>
            Plays as you hover over something interactable.
            </summary>
        </member>
        <member name="P:KeepCoding.Sound.Stamp">
            <summary>
            Plays during the post game screen, when either the defused or exploded text is stamped onto the binder.
            </summary>
        </member>
        <member name="P:KeepCoding.Sound.Strike">
            <summary>
            Plays when you get a strike.
            </summary>
        </member>
        <member name="P:KeepCoding.Sound.Switch">
            <summary>
            Plays when a switch is toggled.
            </summary>
        </member>
        <member name="P:KeepCoding.Sound.TitleMenuPressed">
            <summary>
            Plays when pressing a button in one of the tutorials.
            </summary>
        </member>
        <member name="P:KeepCoding.Sound.TypewriterKey">
            <summary>
            Plays during the post game screen as the mission information gets typed out.
            </summary>
        </member>
        <member name="P:KeepCoding.Sound.WireSequenceMechanism">
            <summary>
            Plays when switching between sets of wires in Wire Sequence.
            </summary>
        </member>
        <member name="P:KeepCoding.Sound.WireSnip">
            <summary>
            Played when a wire is cut on a module like Complicated Wires.
            </summary>
        </member>
        <member name="M:KeepCoding.Sound.op_Explicit(KeepCoding.Sound)~System.String">
            <summary>
            Returns <see cref="P:KeepCoding.Sound.Custom"/> for the current variable.
            </summary>
            <param name="sound">The variable to grab the property from.</param>
            <returns><paramref name="sound"/>'s <see cref="P:KeepCoding.Sound.Custom"/>.</returns>
        </member>
        <member name="M:KeepCoding.Sound.op_Explicit(KeepCoding.Sound)~System.Nullable{KMSoundOverride.SoundEffect}">
            <summary>
            Returns <see cref="P:KeepCoding.Sound.Game"/> for the current variable.
            </summary>
            <param name="sound">The variable to grab the property from.</param>
            <returns><paramref name="sound"/>'s <see cref="P:KeepCoding.Sound.Game"/>.</returns>
        </member>
        <member name="M:KeepCoding.Sound.op_Explicit(KeepCoding.Sound)~KMSoundOverride.SoundEffect">
            <summary>
            Returns <see cref="P:KeepCoding.Sound.Game"/> for the current variable.
            </summary>
            <exception cref="T:System.InvalidOperationException"></exception>
            <param name="sound">The variable to grab the property from.</param>
            <returns><paramref name="sound"/>'s <see cref="P:KeepCoding.Sound.Game"/>.</returns>
        </member>
        <member name="M:KeepCoding.Sound.op_Implicit(System.String)~KeepCoding.Sound">
            <summary>
            An instance of Sound where <see cref="P:KeepCoding.Sound.Custom"/> is defined.
            </summary>
            <param name="sound">The sound to insert.</param>
            <returns><see cref="T:KeepCoding.Sound"/> with argument <paramref name="sound"/>.</returns>
        </member>
        <member name="M:KeepCoding.Sound.op_Implicit(UnityEngine.AudioClip)~KeepCoding.Sound">
            <summary>
            An instance of Sound where <see cref="P:KeepCoding.Sound.Custom"/> is defined.
            </summary>
            <param name="sound">The sound to insert.</param>
            <returns><see cref="T:KeepCoding.Sound"/> with argument <paramref name="sound"/>.</returns>
        </member>
        <member name="M:KeepCoding.Sound.op_Implicit(KMSoundOverride.SoundEffect)~KeepCoding.Sound">
            <summary>
            An instance of Sound where <see cref="P:KeepCoding.Sound.Game"/> is defined.
            </summary>
            <param name="sound">The sound to insert.</param>
            <returns><see cref="T:KeepCoding.Sound"/> with argument <paramref name="sound"/>.</returns>
        </member>
        <member name="M:KeepCoding.Sound.StopSound">
            <summary>
            Stops the <see cref="P:KeepCoding.Sound.Reference"/>'s sound.
            </summary>
        </member>
        <member name="M:KeepCoding.Sound.Equals(System.Object)">
            <summary>
            Determines if both <see cref="T:KeepCoding.Sound"/> variables are equal.
            </summary>
            <param name="obj">The comparison.</param>
            <returns>True if <see cref="P:KeepCoding.Sound.Custom"/>, <see cref="P:KeepCoding.Sound.Reference"/>, and <see cref="P:KeepCoding.Sound.Game"/> are equal.</returns>
        </member>
        <member name="M:KeepCoding.Sound.Equals(KeepCoding.Sound)">
            <summary>
            Determines if both <see cref="T:KeepCoding.Sound"/> variables are equal.
            </summary>
            <param name="other">The comparison.</param>
            <returns>True if <see cref="P:KeepCoding.Sound.Custom"/>, <see cref="P:KeepCoding.Sound.Reference"/>, and <see cref="P:KeepCoding.Sound.Game"/> are equal.</returns>
        </member>
        <member name="M:KeepCoding.Sound.GetHashCode">
            <summary>
            Gets the current hash code.
            </summary>
            <returns>The hash code of <see cref="P:KeepCoding.Sound.Custom"/>, <see cref="P:KeepCoding.Sound.Reference"/>, and <see cref="P:KeepCoding.Sound.Game"/>.</returns>
        </member>
        <member name="M:KeepCoding.Sound.ToString">
            <summary>
            Converts the current sound to a string, returning the current sound.
            </summary>
            <returns><see cref="P:KeepCoding.Sound.Game"/>, or if null, <see cref="P:KeepCoding.Sound.Custom"/>.</returns>
        </member>
        <member name="M:KeepCoding.Sound.Method(KMAudio)">
            <summary>
            Gets the corresponding sound method matching the arguments of this instance of <see cref="T:KeepCoding.Sound"/>.
            </summary>
            <param name="audio">The instance of <see cref="T:KMAudio"/> to play from.</param>
            <returns>A method that when called, will play the sound and return the <see cref="T:KMAudio.KMAudioRef"/> instance.</returns>
        </member>
        <member name="T:KeepCoding.Tuple`1">
            <summary>
            A basic tuple data type for C# 4.
            </summary>
        </member>
        <member name="M:KeepCoding.Tuple`1.#ctor(`0)">
            <summary>
            Creates a singleton tuple.
            </summary>
            <param name="item1">The item to pass into the first property.</param>
        </member>
        <member name="M:KeepCoding.Tuple`1.#ctor">
            <summary>
            Creates a singleton tuple of default values.
            </summary>
        </member>
        <member name="P:KeepCoding.Tuple`1.Item(System.Byte)">
            <summary>
            Indexable tuple. Be careful when using this as the compiler will not notice if you are using the wrong type.
            </summary>
            <exception cref="T:System.IndexOutOfRangeException"></exception>
            <exception cref="T:KeepCoding.Internal.UnrecognizedTypeException"></exception>
            <param name="i">The index to use.</param>
            <returns>The item indexed into.</returns>
        </member>
        <member name="P:KeepCoding.Tuple`1.ToArray">
            <summary>
            All of the tuple's items as an array, ordered by item number.
            </summary>
        </member>
        <member name="P:KeepCoding.Tuple`1.Item1">
            <summary>
            The first item of the tuple.
            </summary>
        </member>
        <member name="M:KeepCoding.Tuple`1.Destruct(`0@)">
            <summary>
            Destructs the tuple.
            </summary>
            <param name="item">The variable to assign the first element of the tuple.</param>
        </member>
        <member name="T:KeepCoding.Tuple`2">
            <summary>
            A basic tuple data type for C# 4. 
            </summary>
        </member>
        <member name="M:KeepCoding.Tuple`2.#ctor(`0,`1)">
            <summary>
            Creates a tuple of size 2.
            </summary>
            <param name="item1">The item to pass into the first property.</param>
            <param name="item2">The item to pass into the second property.</param>
        </member>
        <member name="M:KeepCoding.Tuple`2.#ctor">
            <summary>
            Creates a singleton tuple of default values.
            </summary>
        </member>
        <member name="P:KeepCoding.Tuple`2.Item(System.Byte)">
            <summary>
            Indexable tuple. Be careful when using this as the compiler will not notice if you are using the wrong type.
            </summary>
            <exception cref="T:System.IndexOutOfRangeException"></exception>
            <exception cref="T:KeepCoding.Internal.UnrecognizedTypeException"></exception>
            <param name="i">The index to use.</param>
            <returns>The item indexed into.</returns>
        </member>
        <member name="P:KeepCoding.Tuple`2.ToArray">
            <summary>
            All of the tuple's items as an array, ordered by item number.
            </summary>
        </member>
        <member name="P:KeepCoding.Tuple`2.Item2">
            <summary>
            The second item of the tuple.
            </summary>
        </member>
        <member name="M:KeepCoding.Tuple`2.Destruct(`0@,`1@)">
            <summary>
            Destructs the tuple.
            </summary>
            <param name="item1">The variable to assign the first element of the tuple.</param>
            <param name="item2">The variable to assign the second element of the tuple.</param>
        </member>
        <member name="T:KeepCoding.Tuple`3">
            <summary>
            A basic tuple data type for C# 4. 
            </summary>
        </member>
        <member name="M:KeepCoding.Tuple`3.#ctor(`0,`1,`2)">
            <summary>
            Creates a tuple of size 3.
            </summary>
            <param name="item1">The item to pass into the first property.</param>
            <param name="item2">The item to pass into the second property.</param>
            <param name="item3">The item to pass into the third property.</param>
        </member>
        <member name="M:KeepCoding.Tuple`3.#ctor">
            <summary>
            Creates a singleton tuple of default values.
            </summary>
        </member>
        <member name="P:KeepCoding.Tuple`3.Item(System.Byte)">
            <summary>
            Indexable tuple. Be careful when using this as the compiler will not notice if you are using the wrong type.
            </summary>
            <exception cref="T:System.IndexOutOfRangeException"></exception>
            <exception cref="T:KeepCoding.Internal.UnrecognizedTypeException"></exception>
            <param name="i">The index to use.</param>
            <returns>The item indexed into.</returns>
        </member>
        <member name="P:KeepCoding.Tuple`3.ToArray">
            <summary>
            All of the tuple's items as an array, ordered by item number.
            </summary>
        </member>
        <member name="P:KeepCoding.Tuple`3.Item3">
            <summary>
            The third item of the tuple.
            </summary>
        </member>
        <member name="M:KeepCoding.Tuple`3.Destruct(`0@,`1@,`2@)">
            <summary>
            Destructs the tuple.
            </summary>
            <param name="item1">The variable to assign the first element of the tuple.</param>
            <param name="item2">The variable to assign the second element of the tuple.</param>
            <param name="item3">The variable to assign the third element of the tuple.</param>
        </member>
        <member name="T:KeepCoding.Tuple`4">
            <summary>
            A basic tuple data type for C# 4. 
            </summary>
        </member>
        <member name="M:KeepCoding.Tuple`4.#ctor(`0,`1,`2,`3)">
            <summary>
            Creates a tuple of size 4.
            </summary>
            <param name="item1">The item to pass into the first property.</param>
            <param name="item2">The item to pass into the second property.</param>
            <param name="item3">The item to pass into the third property.</param>
            <param name="item4">The item to pass into the fourth property.</param>
        </member>
        <member name="M:KeepCoding.Tuple`4.#ctor">
            <summary>
            Creates a singleton tuple of default values.
            </summary>
        </member>
        <member name="P:KeepCoding.Tuple`4.Item(System.Byte)">
            <summary>
            Indexable tuple. Be careful when using this as the compiler will not notice if you are using the wrong type.
            </summary>
            <exception cref="T:System.IndexOutOfRangeException"></exception>
            <exception cref="T:KeepCoding.Internal.UnrecognizedTypeException"></exception>
            <param name="i">The index to use.</param>
            <returns>The item indexed into.</returns>
        </member>
        <member name="P:KeepCoding.Tuple`4.ToArray">
            <summary>
            All of the tuple's items as an array, ordered by item number.
            </summary>
        </member>
        <member name="P:KeepCoding.Tuple`4.Item4">
            <summary>
            The fourth item of the tuple.
            </summary>
        </member>
        <member name="M:KeepCoding.Tuple`4.Destruct(`0@,`1@,`2@,`3@)">
            <summary>
            Destructs the tuple.
            </summary>
            <param name="item1">The variable to assign the first element of the tuple.</param>
            <param name="item2">The variable to assign the second element of the tuple.</param>
            <param name="item3">The variable to assign the third element of the tuple.</param>
            <param name="item4">The variable to assign the fourth element of the tuple.</param>
        </member>
        <member name="T:KeepCoding.Work">
            <summary>
            Advanced multi-threading handler.
            </summary>
        </member>
        <member name="M:KeepCoding.Work.#ctor(System.Action)">
            <summary>
            Stores the method so that it can later be called when a new thread starts. Multiple simultaneous threads are allowed, but are queued and limited to one at-a-time.
            </summary>
            <param name="work">The method to call when thread starts.</param>
        </member>
        <member name="M:KeepCoding.Work.#ctor(System.Action,System.Boolean,System.UInt32)">
            <summary>
            Stores the method so that it can later be called when a new thread starts.
            </summary>
            <param name="work">The method to call when thread starts.</param>
            <param name="allowSimultaneousActive">Whether it should allow multiple of itself to be running at once.</param>
            <param name="maximumThreadsActive">The amount of threads this class, and all of its overloads can run at once.</param>
        </member>
        <member name="M:KeepCoding.Work.Start">
            <summary>
            Starts a new thread, and waits until it is finished before halting.
            </summary>
            <returns><see cref="T:UnityEngine.WaitWhile"/> in various places until the thread has been finished.</returns>
        </member>
        <member name="T:KeepCoding.Work`1">
            <summary>
            Advanced multi-threading handler.
            </summary>
        </member>
        <member name="M:KeepCoding.Work`1.#ctor(System.Func{`0})">
            <summary>
            Stores the method so that it can later be called when a new thread starts. Multiple simultaneous threads are allowed, but are queued and limited to one at-a-time.
            </summary>
            <param name="work">The method to call when thread starts.</param>
        </member>
        <member name="M:KeepCoding.Work`1.#ctor(System.Func{`0},System.Boolean,System.UInt32)">
            <summary>
            Stores the method so that it can later be called when a new thread starts.
            </summary>
            <param name="work">The method to call when thread starts.</param>
            <param name="allowSimultaneousActive">Whether it should allow multiple of itself to be running at once.</param>
            <param name="maximumThreadsActive">The amount of threads this class, and all of its overloads can run at once.</param>
        </member>
        <member name="P:KeepCoding.Work`1.Result">
            <summary>
            The returned value of the thread.
            </summary>
        </member>
        <member name="M:KeepCoding.Work`1.Start">
            <summary>
            Starts a new thread, and waits until it is finished before halting.
            </summary>
            <returns><see cref="T:UnityEngine.WaitWhile"/> in various places until the thread has been finished.</returns>
        </member>
        <member name="T:KeepCoding.Work`2">
            <summary>
            Advanced multi-threading handler.
            </summary>
        </member>
        <member name="M:KeepCoding.Work`2.#ctor(System.Func{`0,`1})">
            <summary>
            Stores the method so that it can later be called when a new thread starts. Multiple simultaneous threads are allowed, but are queued and limited to one at-a-time.
            </summary>
            <param name="work">The method to call when thread starts.</param>
        </member>
        <member name="M:KeepCoding.Work`2.#ctor(System.Func{`0,`1},System.Boolean,System.UInt32)">
            <summary>
            Stores the method so that it can later be called when a new thread starts.
            </summary>
            <param name="work">The method to call when thread starts.</param>
            <param name="allowSimultaneousActive">Whether it should allow multiple of itself to be running at once.</param>
            <param name="maximumThreadsActive">The amount of threads this class, and all of its overloads can run at once.</param>
        </member>
        <member name="P:KeepCoding.Work`2.Result">
            <summary>
            The returned value of the thread.
            </summary>
        </member>
        <member name="M:KeepCoding.Work`2.Start(`0)">
            <summary>
            Starts a new thread, and waits until it is finished before halting.
            </summary>
            <returns><see cref="T:UnityEngine.WaitWhile"/> in various places until the thread has been finished.</returns>
        </member>
        <member name="T:KeepCoding.Work`3">
            <summary>
            Advanced multi-threading handler.
            </summary>
        </member>
        <member name="M:KeepCoding.Work`3.#ctor(System.Func{`0,`1,`2})">
            <summary>
            Stores the method so that it can later be called when a new thread starts. Multiple simultaneous threads are allowed, but are queued and limited to one at-a-time.
            </summary>
            <param name="work">The method to call when thread starts.</param>
        </member>
        <member name="M:KeepCoding.Work`3.#ctor(System.Func{`0,`1,`2},System.Boolean,System.UInt32)">
            <summary>
            Stores the method so that it can later be called when a new thread starts.
            </summary>
            <param name="work">The method to call when thread starts.</param>
            <param name="allowSimultaneousActive">Whether it should allow multiple of itself to be running at once.</param>
            <param name="maximumThreadsActive">The amount of threads this class, and all of its overloads can run at once.</param>
        </member>
        <member name="P:KeepCoding.Work`3.Result">
            <summary>
            The returned value of the thread.
            </summary>
        </member>
        <member name="M:KeepCoding.Work`3.Start(`0,`1)">
            <summary>
            Starts a new thread, and waits until it is finished before halting.
            </summary>
            <returns><see cref="T:UnityEngine.WaitWhile"/> in various places until the thread has been finished.</returns>
        </member>
        <member name="T:KeepCoding.Work`4">
            <summary>
            Advanced multi-threading handler.
            </summary>
        </member>
        <member name="M:KeepCoding.Work`4.#ctor(System.Func{`0,`1,`2,`3})">
            <summary>
            Stores the method so that it can later be called when a new thread starts. Multiple simultaneous threads are allowed, but are queued and limited to one at-a-time.
            </summary>
            <param name="work">The method to call when thread starts.</param>
        </member>
        <member name="M:KeepCoding.Work`4.#ctor(System.Func{`0,`1,`2,`3},System.Boolean,System.UInt32)">
            <summary>
            Stores the method so that it can later be called when a new thread starts.
            </summary>
            <param name="work">The method to call when thread starts.</param>
            <param name="allowSimultaneousActive">Whether it should allow multiple of itself to be running at once.</param>
            <param name="maximumThreadsActive">The amount of threads this class, and all of its overloads can run at once.</param>
        </member>
        <member name="P:KeepCoding.Work`4.Result">
            <summary>
            The returned value of the thread.
            </summary>
        </member>
        <member name="M:KeepCoding.Work`4.Start(`0,`1,`2)">
            <summary>
            Starts a new thread, and waits until it is finished before halting.
            </summary>
            <returns><see cref="T:UnityEngine.WaitWhile"/> in various places until the thread has been finished.</returns>
        </member>
        <member name="T:KeepCoding.Work`5">
            <summary>
            Advanced multi-threading handler.
            </summary>
        </member>
        <member name="M:KeepCoding.Work`5.#ctor(System.Func{`0,`1,`2,`3,`4})">
            <summary>
            Stores the method so that it can later be called when a new thread starts. Multiple simultaneous threads are allowed, but are queued and limited to one at-a-time.
            </summary>
            <param name="work">The method to call when thread starts.</param>
        </member>
        <member name="M:KeepCoding.Work`5.#ctor(System.Func{`0,`1,`2,`3,`4},System.Boolean,System.UInt32)">
            <summary>
            Stores the method so that it can later be called when a new thread starts.
            </summary>
            <param name="work">The method to call when thread starts.</param>
            <param name="allowSimultaneousActive">Whether it should allow multiple of itself to be running at once.</param>
            <param name="maximumThreadsActive">The amount of threads this class, and all of its overloads can run at once.</param>
        </member>
        <member name="P:KeepCoding.Work`5.Result">
            <summary>
            The returned value of the thread.
            </summary>
        </member>
        <member name="M:KeepCoding.Work`5.Start(`0,`1,`2,`3)">
            <summary>
            Starts a new thread, and waits until it is finished before halting.
            </summary>
            <returns><see cref="T:UnityEngine.WaitWhile"/> in various places until the thread has been finished.</returns>
        </member>
        <member name="T:KeepCoding.IDump">
            <summary>
            An interface to implement dump methods. Make each method return the same method in your <see cref="T:KeepCoding.Logger"/> instance. 
            </summary>
        </member>
        <member name="M:KeepCoding.IDump.Dump``1(``0,System.Boolean)">
            <summary>
            Dumps all information that it can find of the type using reflection. This should only be used to debug.
            </summary>
            <param name="obj">The object to reflect on.</param>
            <param name="getVariables">Whether it should search recursively for the elements within the elements.</param>
        </member>
        <member name="M:KeepCoding.IDump.Dump(System.Boolean,System.Linq.Expressions.Expression{System.Func{System.Object}}[])">
            <summary>
            Dumps all information about the variables specified. Each element uses the syntax () => varName. This should only be used to debug.
            </summary>
            <param name="getVariables">Whether it should search recursively for the elements within the elements.</param>
            <param name="logs">All of the variables to throughly log.</param>
        </member>
        <member name="M:KeepCoding.IDump.Dump(System.Linq.Expressions.Expression{System.Func{System.Object}}[])">
            <summary>
            Dumps all information about the variables specified. Each element uses the syntax () => varName. This should only be used to debug.
            </summary>
            <param name="logs">All of the variables to throughly log.</param>
        </member>
        <member name="T:KeepCoding.ILog">
            <summary>
            An interface to implement log methods. Make each method return the same method in your <see cref="T:KeepCoding.Logger"/> instance.  
            </summary>
        </member>
        <member name="M:KeepCoding.ILog.Log``1(``0,UnityEngine.LogType)">
            <summary>
            Logs message, but formats it to be compliant with the Logfile Analyzer.
            </summary>
            <exception cref="T:KeepCoding.Internal.UnrecognizedValueException"></exception>
            <param name="message">The message to log.</param>
            <param name="logType">The type of logging. Different logging types have different icons within the editor.</param>
        </member>
        <member name="M:KeepCoding.ILog.Log``1(``0,System.Object[])">
            <summary>
            Logs multiple entries, but formats it to be compliant with the Logfile Analyzer.
            </summary>
            <exception cref="T:KeepCoding.Internal.UnrecognizedValueException"></exception>
            <param name="message">The message to log.</param>
            <param name="args">All of the arguments to embed into <paramref name="message"/>.</param>
        </member>
        <member name="M:KeepCoding.ILog.LogMultiple(System.String[])">
            <summary>
            Logs multiple entries to the console.
            </summary>
            <param name="logs">The array of logs to individual output into the console.</param>
        </member>
        <member name="T:KeepCoding.ITP">
            <summary>
            Interface for Twitch Plays support. 
            </summary>
        </member>
        <member name="P:KeepCoding.ITP.IsCancelCommand">
            <summary>
            Determines if it should cancel command processing. If this returns true, then stop processing the command, clean up, then do a <c>yield return Cancelled;</c> to acknowledge the cancel.
            </summary>
            <remarks>
            These values are set by the Twitch Plays mod using reflection. This field is set in <c>Start()</c>, therefore there's no guarantee that it'll be available there, the field must be first accessed in a delegate in <see cref="F:KMBombModule.OnActivate"/> or <see cref="F:KMNeedyModule.OnActivate"/> or later.
            </remarks>
        </member>
        <member name="P:KeepCoding.ITP.IsTime">
            <summary>
            Determines if it is in Time Mode, where solves change the timer. This is useful for modules that use the timer's value.
            </summary>
            <remarks>
            These values are set by the Twitch Plays mod using reflection. This field is set in <c>Start()</c>, therefore there's no guarantee that it'll be available there, the field must be first accessed in a delegate in <see cref="F:KMBombModule.OnActivate"/> or <see cref="F:KMNeedyModule.OnActivate"/> or later.
            </remarks>
        </member>
        <member name="P:KeepCoding.ITP.IsTimeSkippable">
            <summary>
            Determines if it should allow for the timer to be skipped when the module it is in, as well as any other modules that would like to skip time, are the only unsolved modules left on the bomb. 
            </summary>
            <remarks>
            These values are set by the Twitch Plays mod using reflection. This field is set in <c>Start()</c>, therefore there's no guarantee that it'll be available there, the field must be first accessed in a delegate in <see cref="F:KMBombModule.OnActivate"/> or <see cref="F:KMNeedyModule.OnActivate"/> or later.
            </remarks>
        </member>
        <member name="P:KeepCoding.ITP.IsTP">
            <summary>
            Determines if Twitch Plays is currently active. This is for modules that need to display different items, or use different rules if Twitch Plays is active.
            </summary>
            <remarks>
            These values are set by the Twitch Plays mod using reflection. This field is set in <c>Start()</c>, therefore there's no guarantee that it'll be available there, the field must be first accessed in a delegate in <see cref="F:KMBombModule.OnActivate"/> or <see cref="F:KMNeedyModule.OnActivate"/> or later.
            </remarks>
        </member>
        <member name="P:KeepCoding.ITP.IsZen">
            <summary>
            Determines if the timer is counting up instead of down, for special cases, such as controlling how to sort button release times, or whether there is a low timer event or not.
            </summary>
            <remarks>
            These values are set by the Twitch Plays mod using reflection. This field is set in <c>Start()</c>, therefore there's no guarantee that it'll be available there, the field must be first accessed in a delegate in <see cref="F:KMBombModule.OnActivate"/> or <see cref="F:KMNeedyModule.OnActivate"/> or later.
            </remarks>
        </member>
        <member name="P:KeepCoding.ITP.Help">
            <summary>
            The help message that gets sent when typing <c>!{id} help</c>.
            </summary>
        </member>
        <member name="P:KeepCoding.ITP.Manual">
            <summary>
            Specifies the manual that is looked up on The Manual Repository when <c>!{id} manual</c> is entered into chat.
            </summary>
        </member>
        <member name="P:KeepCoding.ITP.Abandons">
            <summary>
            Declaring this field allows for Twitch Plays to inform the module that the bomb is in Time Mode, where solves change the timer. This is useful for modules that use the timer's value.
            </summary>
            <remarks>
            These values are set by the Twitch Plays mod using reflection. This field is set in <c>Start()</c>, therefore there's no guarantee that it'll be available there, the field must be first accessed in a delegate in <see cref="F:KMBombModule.OnActivate"/> or <see cref="F:KMNeedyModule.OnActivate"/> or later.
            </remarks>
        </member>
        <member name="M:KeepCoding.ITP.ForceSolve">
            <summary>
            When the module runs into an exception or the module is forced to be solved, it calls this method.
            </summary>
            <remarks>
            Make sure that the module is solved before this method closes, otherwise it causes a forced-solve.
            </remarks>
            <returns>A series of instructions for the Twitch Plays mod to handle in order to guarantee a solve.</returns>
        </member>
        <member name="M:KeepCoding.ITP.Process(System.String)">
            <summary>
            When a command is typed into Twitch Plays with the Id of this module, it calls this method and passes in the exact command typed.
            </summary>
            <remarks>
            Anything that gets yield returned will be processed by Twitch Plays. This includes other <see cref="T:System.Collections.IEnumerable"/> methods, <see cref="T:KMSelectable"/>, an <see cref="T:System.Array"/> of <see cref="T:KMSelectable"/>, <see cref="T:System.String"/>, <c>true</c>, or <c>null</c>.
            </remarks>
            <param name="command">The user's command.</param>
            <returns>A series of instructions for the Twitch Plays mod to handle as requested by the user.</returns>
        </member>
        <member name="T:KeepCoding.CacheableBehaviour">
            <summary>
            A <see cref="T:UnityEngine.MonoBehaviour"/> with additional caching capabilities. 
            </summary>
        </member>
        <member name="M:KeepCoding.CacheableBehaviour.Clear">
            <summary>
            Clears the <see cref="T:UnityEngine.Component"/> and <see cref="T:UnityEngine.Object"/> caches.
            </summary>
        </member>
        <member name="M:KeepCoding.CacheableBehaviour.Cache(System.Type,System.Func{System.Type,UnityEngine.Component},System.Boolean)">
            <summary>
            Caches the result of a function call that returns a component array in a dictionary, and will return the cached result if called again. Use this to alleviate expensive function calls.
            </summary>
            <exception cref="T:System.ArgumentException"></exception>
            <exception cref="T:UnityEngine.MissingComponentException"></exception>
            <param name="type">The type of component to search for.</param>
            <param name="func">The expensive function to call, only if it hasn't ever been called by this method on the current instance before.</param>
            <param name="allowNull">Whether it should throw an exception if it sees <see langword="null"/>, if not it will return the default value. (Likely <see langword="null"/>)</param>
            <returns>The components specified by <paramref name="type"/>.</returns>
        </member>
        <member name="M:KeepCoding.CacheableBehaviour.Cache(System.Type,System.Func{System.Type,UnityEngine.Component[]},System.Boolean)">
            <summary>
            Caches the result of a function call that returns a component array in a dictionary, and will return the cached result if called again. Use this to alleviate expensive function calls.
            </summary>
            <exception cref="T:System.ArgumentException"></exception>
            <exception cref="T:UnityEngine.MissingComponentException"></exception>
            <param name="type">The type of component to search for.</param>
            <param name="func">The expensive function to call, only if it hasn't ever been called by this method on the current instance before.</param>
            <param name="allowNull">Whether it should throw an exception if it sees <see langword="null"/>, if not it will return the default value. (Likely <see langword="null"/>)</param>
            <returns>The components specified by <paramref name="type"/>.</returns>
        </member>
        <member name="M:KeepCoding.CacheableBehaviour.Find(System.Type,System.Boolean)">
            <summary>
            Similar to <see cref="M:UnityEngine.Object.FindObjectsOfType(System.Type)"/>, however it caches the result in a dictionary, and will return the cached result if called again.
            </summary>
            <exception cref="T:System.ArgumentException"></exception>
            <exception cref="T:UnityEngine.MissingComponentException"></exception>
            <param name="type">The type of component to search for.</param>
            <param name="allowNull">Whether it should throw an exception if it sees <see langword="null"/>, if not it will return the default value. (Likely <see langword="null"/>)</param>
            <returns>The component specified by <paramref name="type"/>.</returns>
        </member>
        <member name="M:KeepCoding.CacheableBehaviour.Get(System.Type,System.Boolean)">
            <summary>
            Similar to <see cref="M:UnityEngine.Component.GetComponent(System.Type)"/>, however it caches the result in a dictionary, and will return the cached result if called again.
            </summary>
            <exception cref="T:UnityEngine.MissingComponentException"></exception>
            <param name="type">The type of component to search for.</param>
            <param name="allowNull">Whether it should throw an exception if it sees <see langword="null"/>, if not it will return the default value. (Likely <see langword="null"/>)</param>
            <returns>The component specified by <paramref name="type"/>.</returns>
        </member>
        <member name="M:KeepCoding.CacheableBehaviour.GetChild(System.Type,System.Boolean)">
            <summary>
            Similar to <see cref="M:UnityEngine.Component.GetComponentInChildren(System.Type)"/>, however it caches the result in a dictionary, and will return the cached result if called again.
            </summary>
            <exception cref="T:System.ArgumentException"></exception>
            <exception cref="T:UnityEngine.MissingComponentException"></exception>
            <param name="type">The type of component to search for.</param>
            <param name="allowNull">Whether it should throw an exception if it sees <see langword="null"/>, if not it will return the default value. (Likely <see langword="null"/>)</param>
            <returns>The component specified by <paramref name="type"/>.</returns>
        </member>
        <member name="M:KeepCoding.CacheableBehaviour.GetParent(System.Type,System.Boolean)">
            <summary>
            Similar to <see cref="M:UnityEngine.Component.GetComponentInParent(System.Type)"/>, however it caches the result in a dictionary, and will return the cached result if called again.
            </summary>
            <exception cref="T:System.ArgumentException"></exception>
            <exception cref="T:UnityEngine.MissingComponentException"></exception>
            <param name="type">The type of component to search for.</param>
            <param name="allowNull">Whether it should throw an exception if it sees <see langword="null"/>, if not it will return the default value. (Likely <see langword="null"/>)</param>
            <returns>The component specified by <paramref name="type"/>.</returns>
        </member>
        <member name="M:KeepCoding.CacheableBehaviour.Finds(System.Type,System.Boolean)">
            <summary>
            Similar to <see cref="M:UnityEngine.Object.FindObjectsOfType(System.Type)"/>, however it caches the result in a dictionary, and will return the cached result if called again.
            </summary>
            <exception cref="T:System.ArgumentException"></exception>
            <exception cref="T:UnityEngine.MissingComponentException"></exception>
            <param name="type">The type of component to search for.</param>
            <param name="allowNull">Whether it should throw an exception if it sees <see langword="null"/>, if not it will return the default value. (Likely <see langword="null"/>)</param>
            <returns>The component specified by <paramref name="type"/>.</returns>
        </member>
        <member name="M:KeepCoding.CacheableBehaviour.Gets(System.Type,System.Boolean)">
            <summary>
            Similar to <see cref="M:UnityEngine.GameObject.GetComponents(System.Type)"/>, however it caches the result in a dictionary, and will return the cached result if called again.
            </summary>
            <exception cref="T:System.ArgumentException"></exception>
            <exception cref="T:UnityEngine.MissingComponentException"></exception>
            <param name="type">The type of component to search for.</param>
            <param name="allowNull">Whether it should throw an exception if it sees <see langword="null"/>, if not it will return the default value. (Likely <see langword="null"/>)</param>
            <returns>The component specified by <paramref name="type"/>.</returns>
        </member>
        <member name="M:KeepCoding.CacheableBehaviour.GetChildren(System.Type,System.Boolean)">
            <summary>
            Similar to <see cref="M:UnityEngine.GameObject.GetComponentsInChildren(System.Type)"/>, however it caches the result in a dictionary, and will return the cached result if called again.
            </summary>
            <exception cref="T:System.ArgumentException"></exception>
            <exception cref="T:UnityEngine.MissingComponentException"></exception>
            <param name="type">The type of component to search for.</param>
            <param name="allowNull">Whether it should throw an exception if it sees <see langword="null"/>, if not it will return the default value. (Likely <see langword="null"/>)</param>
            <returns>The component specified by <paramref name="type"/>.</returns>
        </member>
        <member name="M:KeepCoding.CacheableBehaviour.GetParents(System.Type,System.Boolean)">
            <summary>
            Similar to <see cref="M:UnityEngine.GameObject.GetComponentsInParent(System.Type)"/>, however it caches the result in a dictionary, and will return the cached result if called again.
            </summary>
            <exception cref="T:System.ArgumentException"></exception>
            <exception cref="T:UnityEngine.MissingComponentException"></exception>
            <param name="type">The type of component to search for.</param>
            <param name="allowNull">Whether it should throw an exception if it sees <see langword="null"/>, if not it will return the default value. (Likely <see langword="null"/>)</param>
            <returns>The component specified by <paramref name="type"/>.</returns>
        </member>
        <member name="M:KeepCoding.CacheableBehaviour.Cache``1(System.Func{``0},System.Boolean)">
            <summary>
            Caches the result of a function call that returns a component array in a dictionary, and will return the cached result if called again. Use this to alleviate expensive function calls.
            </summary>
            <exception cref="T:UnityEngine.MissingComponentException"></exception>
            <typeparam name="T">The type of component to search for.</typeparam>
            <param name="func">The expensive function to call, only if it hasn't ever been called by this method on the current instance before.</param>
            <param name="allowNull">Whether it should throw an exception if it sees <see langword="null"/>, if not it will return the default value. (Likely <see langword="null"/>)</param>
            <returns>The components specified by <typeparamref name="T"/>.</returns>
        </member>
        <member name="M:KeepCoding.CacheableBehaviour.Find``1(System.Boolean)">
            <summary>
            Similar to <see cref="M:UnityEngine.Object.FindObjectsOfType``1"/>, however it caches the result in a dictionary, and will return the cached result if called again.
            </summary>
            <exception cref="T:UnityEngine.MissingComponentException"></exception>
            <typeparam name="T">The type of component to search for.</typeparam>
            <param name="allowNull">Whether it should throw an exception if it sees <see langword="null"/>, if not it will return the default value. (Likely <see langword="null"/>)</param>
            <returns>The component specified by <typeparamref name="T"/>.</returns>
        </member>
        <member name="M:KeepCoding.CacheableBehaviour.Get``1(System.Boolean)">
            <summary>
            Similar to <see cref="M:UnityEngine.Component.GetComponent``1"/>, however it caches the result in a dictionary, and will return the cached result if called again.
            </summary>
            <exception cref="T:UnityEngine.MissingComponentException"></exception>
            <typeparam name="T">The type of component to search for.</typeparam>
            <param name="allowNull">Whether it should throw an exception if it sees <see langword="null"/>, if not it will return the default value. (Likely <see langword="null"/>)</param>
            <returns>The component specified by <typeparamref name="T"/>.</returns>
        </member>
        <member name="M:KeepCoding.CacheableBehaviour.GetChild``1(System.Boolean)">
            <summary>
            Similar to <see cref="M:UnityEngine.Component.GetComponentInChildren``1"/>, however it caches the result in a dictionary, and will return the cached result if called again.
            </summary>
            <exception cref="T:UnityEngine.MissingComponentException"></exception>
            <typeparam name="T">The type of component to search for.</typeparam>
            <param name="allowNull">Whether it should throw an exception if it sees <see langword="null"/>, if not it will return the default value. (Likely <see langword="null"/>)</param>
            <returns>The component specified by <typeparamref name="T"/>.</returns>
        </member>
        <member name="M:KeepCoding.CacheableBehaviour.GetParent``1(System.Boolean)">
            <summary>
            Similar to <see cref="M:UnityEngine.Component.GetComponentInParent``1"/>, however it caches the result in a dictionary, and will return the cached result if called again.
            </summary>
            <exception cref="T:UnityEngine.MissingComponentException"></exception>
            <typeparam name="T">The type of component to search for.</typeparam>
            <param name="allowNull">Whether it should throw an exception if it sees <see langword="null"/>, if not it will return the default value. (Likely <see langword="null"/>)</param>
            <returns>The component specified by <typeparamref name="T"/>.</returns>
        </member>
        <member name="M:KeepCoding.CacheableBehaviour.Cache``1(System.Func{``0[]},System.Boolean)">
            <summary>
            Caches the result of a function call that returns a component array in a dictionary, and will return the cached result if called again. Use this to alleviate expensive function calls.
            </summary>
            <exception cref="T:UnityEngine.MissingComponentException"></exception>
            <typeparam name="T">The type of component to search for.</typeparam>
            <param name="func">The expensive function to call, only if it hasn't ever been called by this method on the current instance before.</param>
            <param name="allowNull">Whether it should throw an exception if it sees <see langword="null"/>, if not it will return the default value. (Likely <see langword="null"/>)</param>
            <returns>The components specified by <typeparamref name="T"/>.</returns>
        </member>
        <member name="M:KeepCoding.CacheableBehaviour.Cache``1(System.Func{System.Boolean,``0[]},System.Boolean,System.Boolean)">
            <summary>
            Caches the result of a function call that returns a component array in a dictionary, and will return the cached result if called again. Use this to alleviate expensive function calls.
            </summary>
            <exception cref="T:UnityEngine.MissingComponentException"></exception>
            <typeparam name="T">The type of component to search for.</typeparam>
            <param name="func">The expensive function to call, only if it hasn't ever been called by this method on the current instance before.</param>
            <param name="parameter">The argument to put in the expensive method call.</param>
            <param name="allowNull">Whether it should throw an exception if it sees <see langword="null"/>, if not it will return the default value. (Likely <see langword="null"/>)</param>
            <returns>The components specified by <typeparamref name="T"/>.</returns>
        </member>
        <member name="M:KeepCoding.CacheableBehaviour.Finds``1(System.Boolean)">
            <summary>
            Similar to <see cref="M:UnityEngine.Object.FindObjectsOfType``1"/>, however it caches the result in a dictionary, and will return the cached result if called again.
            </summary>
            <exception cref="T:UnityEngine.MissingComponentException"></exception>
            <typeparam name="T">The type of component to search for.</typeparam>
            <param name="allowNull">Whether it should throw an exception if it sees <see langword="null"/>, if not it will return the default value. (Likely <see langword="null"/>)</param>
            <returns>The component specified by <typeparamref name="T"/>.</returns>
        </member>
        <member name="M:KeepCoding.CacheableBehaviour.Gets``1(System.Boolean)">
            <summary>
            Similar to <see cref="M:UnityEngine.GameObject.GetComponents``1"/>, however it caches the result in a dictionary, and will return the cached result if called again.
            </summary>
            <exception cref="T:UnityEngine.MissingComponentException"></exception>
            <typeparam name="T">The type of component to search for.</typeparam>
            <param name="allowNull">Whether it should throw an exception if it sees <see langword="null"/>, if not it will return the default value. (Likely <see langword="null"/>)</param>
            <returns>The component specified by <typeparamref name="T"/>.</returns>
        </member>
        <member name="M:KeepCoding.CacheableBehaviour.GetChildren``1(System.Boolean,System.Boolean)">
            <summary>
            Similar to <see cref="M:UnityEngine.GameObject.GetComponentsInChildren``1(System.Boolean)"/>, however it caches the result in a dictionary, and will return the cached result if called again.
            </summary>
            <exception cref="T:UnityEngine.MissingComponentException"></exception>
            <param name="includeInactive">Whether it should include inactive components.</param>
            <typeparam name="T">The type of component to search for.</typeparam>
            <param name="allowNull">Whether it should throw an exception if it sees <see langword="null"/>, if not it will return the default value. (Likely <see langword="null"/>)</param>
            <returns>The component specified by <typeparamref name="T"/>.</returns>
        </member>
        <member name="M:KeepCoding.CacheableBehaviour.GetParents``1(System.Boolean,System.Boolean)">
            <summary>
            Similar to <see cref="M:UnityEngine.GameObject.GetComponentsInParent``1(System.Boolean)"/>, however it caches the result in a dictionary, and will return the cached result if called again.
            </summary>
            <exception cref="T:UnityEngine.MissingComponentException"></exception>
            <typeparam name="T">The type of component to search for.</typeparam>
            <param name="includeInactive">Whether it should include inactive components.</param>
            <param name="allowNull">Whether it should throw an exception if it sees <see langword="null"/>, if not it will return the default value. (Likely <see langword="null"/>)</param>
            <returns>The component specified by <typeparamref name="T"/>.</returns>
        </member>
        <member name="T:KeepCoding.ModuleScript">
            <summary>
            Base class for solvable and needy modded modules in Keep Talking and Nobody Explodes.
            </summary>
        </member>
        <member name="P:KeepCoding.ModuleScript.HasStruck">
            <summary>
            Determines whether the module has been struck. <see cref="M:KeepCoding.TPScript`1.OnInteractSequence(KMSelectable[],System.Single,System.Int32[])"/> will set this to <see langword="false"/> when a command is interrupted.
            </summary>
        </member>
        <member name="P:KeepCoding.ModuleScript.IsActive">
            <summary>
            Determines whether the bomb is currently active, and the timer is ticking.
            </summary>
        </member>
        <member name="P:KeepCoding.ModuleScript.IsColorblind">
            <summary>
            Determines whether the module's colorblind mode is enabled.
            </summary>
            <exception cref="T:System.MissingMethodException"></exception>
        </member>
        <member name="P:KeepCoding.ModuleScript.IsEditor">
            <summary>
            Determines whether the application is running from inside unity.
            </summary>
        </member>
        <member name="P:KeepCoding.ModuleScript.IsLastInstantiated">
            <summary>
            Determines whether this module is the last instantiated instance.
            </summary>
        </member>
        <member name="P:KeepCoding.ModuleScript.IsNeedyActive">
            <summary>
            Determines whether the needy is active.
            </summary>
            <exception cref="T:UnityEngine.MissingComponentException"></exception>
        </member>
        <member name="P:KeepCoding.ModuleScript.IsSolved">
            <summary>
            Determines whether the module has been solved.
            </summary>
        </member>
        <member name="P:KeepCoding.ModuleScript.IsVR">
            <summary>
            Determines whether the game is being played in Virtual Reality. In the Editor, it always returns false.
            </summary>
        </member>
        <member name="P:KeepCoding.ModuleScript.Id">
            <summary>
            The Unique Id for the module of this type.
            </summary>
        </member>
        <member name="P:KeepCoding.ModuleScript.LastId">
            <summary>
            The last Id instantiation for the module of this type.
            </summary>
        </member>
        <member name="P:KeepCoding.ModuleScript.TimeLeft">
            <summary>
            The amount of time left on the bomb, in seconds, rounded down.
            </summary>
        </member>
        <member name="P:KeepCoding.ModuleScript.Version">
            <summary>
            The version number of the entire mod.
            </summary>
            <exception cref="T:System.OperationCanceledException"></exception>
            <exception cref="T:System.IO.FileNotFoundException"></exception>
        </member>
        <member name="P:KeepCoding.ModuleScript.TP">
            <summary>
            Gets the Twitch Plays <see cref="T:UnityEngine.Component"/> attached to this <see cref="T:UnityEngine.GameObject"/>.
            </summary>
            <remarks>
            Due to type ambiguity, a non-generic interface is returned.
            </remarks>
        </member>
        <member name="P:KeepCoding.ModuleScript.Bomb">
            <summary>
            The bomb that this module is in.
            </summary>
        </member>
        <member name="P:KeepCoding.ModuleScript.Module">
            <summary>
            Contains either <see cref="T:KMBombModule"/> or <see cref="T:KMNeedyModule"/>, and allows for running commands through context.
            </summary>
        </member>
        <member name="P:KeepCoding.ModuleScript.Sounds">
            <summary>
            Contains an instance for every <see cref="T:KeepCoding.Sound"/> played by this module using <see cref="M:KeepCoding.ModuleScript.PlaySound(UnityEngine.Transform,System.Boolean,KeepCoding.Sound[])"/> or any of its overloads.
            </summary>
        </member>
        <member name="P:KeepCoding.ModuleScript.Modules">
            <summary>
            Contains every modded module in <see cref="P:KeepCoding.ModuleScript.Bomb"/>, separated by type.
            </summary>
        </member>
        <member name="M:KeepCoding.ModuleScript.Assign(System.Action,System.Action,System.Action,System.Action,System.Action,System.Action)">
            <summary>
            Assigns events specified into <see cref="P:KeepCoding.ModuleScript.Module"/>. Reassigning them will replace their values.
            </summary>
            <remarks>
            An event that is null will be skipped. This extension method simplifies all of the KMFramework events into Actions or Functions.
            </remarks>
            <param name="onActivate">Called when the lights turn on.</param>
            <param name="onNeedyActivation">Called when the needy activates.</param>
            <param name="onNeedyDeactivation">Called when the needy deactivates.</param>
            <param name="onPass">Called when the needy is solved.</param>
            <param name="onStrike">Called when the needy strikes.</param>
            <param name="onTimerExpired">Called when the timer runs out of time.</param>
        </member>
        <member name="M:KeepCoding.ModuleScript.ButtonEffect(KMSelectable,System.Single,KeepCoding.Sound[])">
            <summary>
            Handles typical button <see cref="F:KMSelectable.OnInteract"/> behaviour.
            </summary>
            <exception cref="T:UnityEngine.UnassignedReferenceException"></exception>
            <exception cref="T:KeepCoding.Internal.UnrecognizedValueException"></exception>
            <param name="selectable">The selectable, which is used as a source for sound and bomb shake.</param>
            <param name="intensityModifier">The intensity of the bomb shaking.</param>
            <param name="sounds">The sounds, these can either be <see cref="T:System.String"/>, <see cref="T:UnityEngine.AudioClip"/>, or <see cref="T:KMSoundOverride.SoundEffect"/>.</param>
        </member>
        <member name="M:KeepCoding.ModuleScript.Dump``1(``0,System.Boolean)">
            <summary>
            Dumps all information that it can find of the type using reflection. This should only be used to debug.
            </summary>
            <param name="obj">The object to reflect on.</param>
            <param name="getVariables">Whether it should search recursively for the elements within the elements.</param>
        </member>
        <member name="M:KeepCoding.ModuleScript.Dump(System.Boolean,System.Linq.Expressions.Expression{System.Func{System.Object}}[])">
            <summary>
            Dumps all information about the variables specified. Each element uses the syntax () => varName. This should only be used to debug.
            </summary>
            <param name="getVariables">Whether it should search recursively for the elements within the elements.</param>
            <param name="logs">All of the variables to throughly log.</param>
        </member>
        <member name="M:KeepCoding.ModuleScript.Dump(System.Linq.Expressions.Expression{System.Func{System.Object}}[])">
            <summary>
            Dumps all information about the variables specified. Each element uses the syntax () => varName. This should only be used to debug.
            </summary>
            <param name="logs">All of the variables to throughly log.</param>
        </member>
        <member name="M:KeepCoding.ModuleScript.Log``1(``0,UnityEngine.LogType)">
            <summary>
            Logs message, but formats it to be compliant with the Logfile Analyzer.
            </summary>
            <exception cref="T:KeepCoding.Internal.UnrecognizedValueException"></exception>
            <param name="message">The message to log.</param>
            <param name="logType">The type of logging. Different logging types have different icons within the editor.</param>
        </member>
        <member name="M:KeepCoding.ModuleScript.Log``1(``0,System.Object[])">
            <summary>
            Logs multiple entries, but formats it to be compliant with the Logfile Analyzer.
            </summary>
            <exception cref="T:KeepCoding.Internal.UnrecognizedValueException"></exception>
            <param name="message">The message to log.</param>
            <param name="args">All of the arguments to embed into <paramref name="message"/>.</param>
        </member>
        <member name="M:KeepCoding.ModuleScript.LogMultiple(System.String[])">
            <summary>
            Logs multiple entries to the console.
            </summary>
            <param name="logs">The array of logs to individual output into the console.</param>
        </member>
        <member name="M:KeepCoding.ModuleScript.Solve(System.String[])">
            <summary>
            Solves the module, and logs all of the parameters.
            </summary>
            <param name="logs">All of the entries to log.</param>
        </member>
        <member name="M:KeepCoding.ModuleScript.Strike(System.String[])">
            <summary>
            Strikes the module, and logs all of the parameters.
            </summary>
            <param name="logs">All of the entries to log.</param>
        </member>
        <member name="M:KeepCoding.ModuleScript.OnAwake">
            <summary>
            Called when the module instantiates, well before the lights turn on.
            </summary>
        </member>
        <member name="M:KeepCoding.ModuleScript.OnActivate">
            <summary>
            Called when the lights turn on.
            </summary>
        </member>
        <member name="M:KeepCoding.ModuleScript.OnColorblindChanged(System.Boolean)">
            <summary>
            Called when colorblind support needs to be updated for the module.
            </summary>
            <param name="isEnabled">Whether colorblind support should be enabled.</param>
        </member>
        <member name="M:KeepCoding.ModuleScript.OnDestruct">
            <summary>
            Called when the module destroys itself, after the bomb unloads.
            </summary>
        </member>
        <member name="M:KeepCoding.ModuleScript.OnModuleStrike(System.String)">
            <summary>
            Called when any module on the current bomb has issued a strike.
            </summary>
            <remarks>
            Vanilla modules are an exception, they will not invoke this method.
            </remarks>
            <param name="moduleName">The sender's module name, which caused a strike.</param>
        </member>
        <member name="M:KeepCoding.ModuleScript.OnNeedySolved(System.String)">
            <summary>
            Called when any <see cref="T:KMNeedyModule"/> on the current bomb has been solved.
            </summary>
            <remarks>
            Vanilla modules are an exception, they will not invoke this method.
            </remarks>
            <param name="moduleName">The sender's module name, which was solved.</param>
        </member>
        <member name="M:KeepCoding.ModuleScript.OnSolvableSolved(System.String)">
            <summary>
            Called when any <see cref="T:KMBombModule"/> on the current bomb has been solved.
            </summary>
            <remarks>
            Vanilla modules are an exception, they will not invoke this method.
            </remarks>
            <param name="moduleName">The sender's module name, which was solved.</param>
        </member>
        <member name="M:KeepCoding.ModuleScript.OnTimerTick">
            <summary>
            Called when the timer's seconds-digit changes.
            </summary>
        </member>
        <member name="M:KeepCoding.ModuleScript.Write``1(System.String,``0)">
            <summary>
            Sends information to a static variable such that other modules can access it.
            </summary>
            <remarks>
            To ensure that this method works correctly, make sure that both modules have the same version of KeepCoding.
            </remarks>
            <typeparam name="T">The type of the expected input.</typeparam>
            <param name="key">The key of the variable, a lot like a variable name.</param>
            <param name="value">The value to store in the key.</param>
        </member>
        <member name="M:KeepCoding.ModuleScript.PlaySound(UnityEngine.Transform,System.Boolean,KeepCoding.Sound[])">
            <summary>
            Plays a sound. Requires <see cref="T:KMAudio"/> to be assigned.
            </summary>
            <exception cref="T:KeepCoding.Internal.EmptyIteratorException"></exception>
            <exception cref="T:System.InvalidOperationException"></exception>
            <exception cref="T:UnityEngine.MissingComponentException"></exception>
            <exception cref="T:KeepCoding.Internal.NullIteratorException"></exception>
            <exception cref="T:KeepCoding.Internal.UnrecognizedValueException"></exception>
            <param name="transform">The location or sound source of the sound.</param>
            <param name="loop">Whether all sounds listed should loop or not.</param>
            <param name="sounds">The sounds, these can either be <see cref="T:System.String"/>, <see cref="T:UnityEngine.AudioClip"/>, or <see cref="T:KMSoundOverride.SoundEffect"/>.</param>
            <returns>A <see cref="T:KMAudio.KMAudioRef"/> for each argument you provide.</returns>
        </member>
        <member name="M:KeepCoding.ModuleScript.PlaySound(UnityEngine.Transform,KeepCoding.Sound[])">
            <summary>
            Plays a sound. Requires <see cref="T:KMAudio"/> to be assigned.
            </summary>
            <exception cref="T:KeepCoding.Internal.UnrecognizedValueException"></exception>
            <param name="transform">The location or sound source of the sound.</param>
            <param name="sounds">The sounds, these can either be <see cref="T:System.String"/>, <see cref="T:UnityEngine.AudioClip"/>, or <see cref="T:KMSoundOverride.SoundEffect"/>.</param>
            <returns>A <see cref="T:KMAudio.KMAudioRef"/> for each argument you provide.</returns>
        </member>
        <member name="M:KeepCoding.ModuleScript.PlaySound(System.Boolean,KeepCoding.Sound[])">
            <summary>
            Plays a sound, the sound source is the game object it is attached to. Requires <see cref="T:KMAudio"/> to be assigned.
            </summary>
            <exception cref="T:KeepCoding.Internal.UnrecognizedValueException"></exception>
            <param name="loop">Whether all sounds listed should loop or not.</param>
            <param name="sounds">The sounds, these can either be <see cref="T:System.String"/>, <see cref="T:UnityEngine.AudioClip"/>, or <see cref="T:KMSoundOverride.SoundEffect"/>.</param>
            <returns>A <see cref="T:KMAudio.KMAudioRef"/> for each argument you provide.</returns>
        </member>
        <member name="M:KeepCoding.ModuleScript.PlaySound(KeepCoding.Sound[])">
            <summary>
            Plays a sound, the sound source is the game object it is attached to. Requires <see cref="T:KMAudio"/> to be assigned.
            </summary>
            <exception cref="T:KeepCoding.Internal.UnrecognizedValueException"></exception>
            <param name="sounds">The sounds, these can either be <see cref="T:System.String"/>, <see cref="T:UnityEngine.AudioClip"/>, or <see cref="T:KMSoundOverride.SoundEffect"/>.</param>
            <returns>A <see cref="T:KMAudio.KMAudioRef"/> for each argument you provide.</returns>
        </member>
        <member name="M:KeepCoding.ModuleScript.Read``1(System.String,System.String,System.Boolean)">
            <summary>
            Allows you to read a module's data that uses <see cref="M:KeepCoding.ModuleScript.Write``1(System.String,``0)"/>, even from a different assembly.
            </summary>
            <remarks>
            To ensure that this method works correctly, make sure that both modules have the same version of KeepCoding.
            </remarks>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException"></exception>
            <exception cref="T:KeepCoding.Internal.UnrecognizedTypeException"></exception>
            <typeparam name="T">The type of the expected output.</typeparam>
            <param name="module">The module to look into.</param>
            <param name="key">The key of the variable, a lot like a variable name.</param>
            <param name="allowDefault">Whether it should throw an exception if no value is found, or provide the default value instead.</param>
            <returns>Every instance of the value from the every instance of the module specified.</returns>
        </member>
        <member name="M:KeepCoding.ModuleScript.Awake">
            <summary>
            Sets up base functionality for the module. If you declare this method yourself, make sure to call <c>base.Awake()</c> to ensure that the module initializes correctly, or use <see cref="M:KeepCoding.ModuleScript.OnAwake"/> instead.
            </summary>
        </member>
        <member name="M:KeepCoding.ModuleScript.OnDestroy">
            <summary>
            Removes the module from <see cref="E:UnityEngine.Application.logMessageReceived"/>. If you declare this method, make sure to call <c>base.OnDestroy()</c> to ensure that the module cleans up correctly.
            </summary>
        </member>
        <member name="T:KeepCoding.TPScript`1">
            <summary>
            Base class for TwitchPlays support for solvable and needy modded modules in Keep Talking and Nobody Explodes. 
            </summary>
        </member>
        <member name="P:KeepCoding.TPScript`1.IsCancelCommand">
            <summary>
            Determines if it should cancel command processing. If this returns true, then stop processing the command, clean up, then do a <c>yield return Cancelled;</c> to acknowledge the cancel.
            </summary>
            <remarks>
            These values are set by the Twitch Plays mod using reflection. This field is set in <c>Start()</c>, therefore there's no guarantee that it'll be available there, the field must be first accessed in a delegate in <see cref="F:KMBombModule.OnActivate"/> or <see cref="F:KMNeedyModule.OnActivate"/> or later.
            </remarks>
        </member>
        <member name="P:KeepCoding.TPScript`1.IsTime">
            <summary>
            Determines if it is in Time Mode, where solves change the timer. This is useful for modules that use the timer's value.
            </summary>
            <remarks>
            These values are set by the Twitch Plays mod using reflection. This field is set in <c>Start()</c>, therefore there's no guarantee that it'll be available there, the field must be first accessed in a delegate in <see cref="F:KMBombModule.OnActivate"/> or <see cref="F:KMNeedyModule.OnActivate"/> or later.
            </remarks>
        </member>
        <member name="P:KeepCoding.TPScript`1.IsTimeSkippable">
            <summary>
            Determines if it should allow for the timer to be skipped when the module it is in, as well as any other modules that would like to skip time, are the only unsolved modules left on the bomb. 
            </summary>
            <remarks>
            These values are set by the Twitch Plays mod using reflection. This field is set in <c>Start()</c>, therefore there's no guarantee that it'll be available there, the field must be first accessed in a delegate in <see cref="F:KMBombModule.OnActivate"/> or <see cref="F:KMNeedyModule.OnActivate"/> or later.
            </remarks>
        </member>
        <member name="P:KeepCoding.TPScript`1.IsTP">
            <summary>
            Determines if Twitch Plays is currently active. This is for modules that need to display different items, or use different rules if Twitch Plays is active.
            </summary>
            <remarks>
            These values are set by the Twitch Plays mod using reflection. This field is set in <c>Start()</c>, therefore there's no guarantee that it'll be available there, the field must be first accessed in a delegate in <see cref="F:KMBombModule.OnActivate"/> or <see cref="F:KMNeedyModule.OnActivate"/> or later.
            </remarks>
        </member>
        <member name="P:KeepCoding.TPScript`1.IsZen">
            <summary>
            Determines if the timer is counting up instead of down, for special cases, such as controlling how to sort button release times, or whether there is a low timer event or not.
            </summary>
            <remarks>
            These values are set by the Twitch Plays mod using reflection. This field is set in <c>Start()</c>, therefore there's no guarantee that it'll be available there, the field must be first accessed in a delegate in <see cref="F:KMBombModule.OnActivate"/> or <see cref="F:KMNeedyModule.OnActivate"/> or later.
            </remarks>
        </member>
        <member name="P:KeepCoding.TPScript`1.Help">
            <summary>
            The help message that gets sent when typing <c>!{id} help</c>.
            </summary>
        </member>
        <member name="P:KeepCoding.TPScript`1.Manual">
            <summary>
            Specifies the manual that is looked up on The Manual Repository when <c>!{id} manual</c> is entered into chat.
            </summary>
        </member>
        <member name="P:KeepCoding.TPScript`1.Abandons">
            <summary>
            This list contains modules that it should stop processing. Currently, the only module that uses this capability is Souvenir.
            </summary>
            <remarks>
            These values are set by the Twitch Plays mod using reflection. This field is set in <c>Start()</c>, therefore there's no guarantee that it'll be available there, the field must be first accessed in a delegate in <see cref="F:KMBombModule.OnActivate"/> or <see cref="F:KMNeedyModule.OnActivate"/> or later.
            </remarks>
        </member>
        <member name="P:KeepCoding.TPScript`1.Module">
            <summary>
            The instance of the module.
            </summary>
        </member>
        <member name="F:KeepCoding.TPScript`1.AutoSolve">
            <summary>
            Yield return this to indicate automatically solving the module, as if it threw an exception while solving.
            </summary>
        </member>
        <member name="F:KeepCoding.TPScript`1.CancelDetonate">
            <summary>
            Yield return this to indicate cancelling a previously issued delayed detonation command on the same module.
            </summary>
        </member>
        <member name="F:KeepCoding.TPScript`1.Cancelled">
            <summary>
            Yield return this to indicate that you have stopped processing the command in response to the <see cref="F:KeepCoding.TPScript`1.TwitchShouldCancelCommand"/> bool being set to true.
            </summary>
        </member>
        <member name="F:KeepCoding.TPScript`1.EndMultipleStrikes">
            <summary>
            Yield return this to indicate that the strike tracker should be enabled. If any strikes were issued during the time it was disabled, they will be awarded and the routine stopped at that point, otherwise, it will just cancel the "VoteNay Module {id} got 0 strikes! +0 strike to {Nickname}" message that would otherwise be posted. Likewise, if the module was solved at the time this command is issued, the processing will be stopped as of that point as well.
            </summary>
        </member>
        <member name="F:KeepCoding.TPScript`1.EndWaitingMusic">
            <summary>
            Yield return this to indicate stopping the waiting music mid-command.
            </summary>
        </member>
        <member name="F:KeepCoding.TPScript`1.HideCamera">
            <summary>
            Yield return this to hide the heads-up display and cameras while doing quaternion rotations, if it is expected that the camera/hud will get in the way.
            </summary>
        </member>
        <member name="F:KeepCoding.TPScript`1.MultipleStrikes">
            <summary>
            Yield return this to indicate that the issued command is going to cause more than one strike, so should disable the internal strike tracker in order to avoid flooding the chat with "VoteNay Module {id} got a strike! +1 strike to {Nickname}" for as many strikes as will be awarded. This also disables the internal solve tracker as well. This allows for sending additional messages or continue processing commands regardless of the solve/strike state.
            </summary>
        </member>
        <member name="F:KeepCoding.TPScript`1.Solve">
            <summary>
            Yield return this to indicate that this command will solve the module at some later point; all this does is tell Twitch Plays to attribute the solve to the author of this command.
            </summary>
        </member>
        <member name="F:KeepCoding.TPScript`1.Strike">
            <summary>
            Yield return this to indicate that this command will cause a strike at some later point; all this does is tell Twitch Plays to attribute the strike to the author of this command.
            </summary>
        </member>
        <member name="F:KeepCoding.TPScript`1.ToggleWaitingMusic">
            <summary>
            Yield return this to toggle the waiting music on and off mid-command.
            </summary>
        </member>
        <member name="F:KeepCoding.TPScript`1.TryCancelSequence">
            <summary>
            Yield return this to indicate that the <c>KMSelectable[]</c> sequence that follows this command should be cancelled if a "!cancel" or "!stop" is issued mid-way through that sequence.
            </summary>
        </member>
        <member name="F:KeepCoding.TPScript`1.UnsubmittablePenalty">
            <summary>
            Yield return this to indicate that the command couldn't submit an answer and should only be used to prevent users from guessing the answer. This should not be used if an answer could never be submittable for a module.
            </summary>
        </member>
        <member name="F:KeepCoding.TPScript`1.WaitingMusic">
            <summary>
            Yield return this to indicate playing the waiting music if a command will take long to finish.
            </summary>
        </member>
        <member name="M:KeepCoding.TPScript`1.ForceSolve">
            <summary>
            When the module runs into an exception or the module is forced to be solved, it calls this method.
            </summary>
            <remarks>
            Make sure that the module is solved before this method closes, otherwise it causes a forced-solve.
            </remarks>
            <returns>A series of instructions for the Twitch Plays mod to handle in order to guarantee a solve.</returns>
        </member>
        <member name="M:KeepCoding.TPScript`1.Process(System.String)">
            <summary>
            When a command is typed into Twitch Plays with the Id of this module, it calls this method and passes in the exact command typed.
            </summary>
            <remarks>
            Anything that gets yield returned will be processed by Twitch Plays. This includes other <see cref="T:System.Collections.IEnumerable"/> methods, <see cref="T:KMSelectable"/>, an <see cref="T:System.Array"/> of <see cref="T:KMSelectable"/>, <see cref="T:System.String"/>, <c>true</c>, or <c>null</c>.
            </remarks>
            <param name="command">The user's command.</param>
            <returns>A series of instructions for the Twitch Plays mod to handle as requested by the user.</returns>
        </member>
        <member name="M:KeepCoding.TPScript`1.IsMatch(System.String,System.String,System.Boolean,System.Text.RegularExpressions.RegexOptions)">
            <summary>
            Determines whether the input string matches the regex of the pattern.
            </summary>
            <exception cref="T:KeepCoding.Internal.NullIteratorException"></exception>
            <param name="input">The test string.</param>
            <param name="pattern">The regular expression.</param>
            <param name="lenient">Whether it should add the default <c>^\s* PATTERN \s*$</c> embeded into most regex usages for Twitch Plays.</param>
            <param name="options">Any additional options for regular expressions.</param>
            <returns>True if <paramref name="input"/> passes the test of the <paramref name="pattern"/>.</returns>
        </member>
        <member name="M:KeepCoding.TPScript`1.StrikeMessage(System.String)">
            <summary>
            Yield return this to allow you to tell the user why they got a strike if it isn't clear.
            </summary>
            <param name="message">The message to send.</param>
            <returns>A formatted string for Twitch Plays.</returns>
        </member>
        <member name="M:KeepCoding.TPScript`1.TryCancel(System.String)">
            <summary>
            Yield return this to indicate that this command is allowed to be cancelled at the given time of the yield. Just know that you won't be able to clean up if you do your cancel this way, and there is a pending !cancel or !stop.
            </summary>
            <param name="message">The message to send.</param>
            <returns>A formatted string for Twitch Plays.</returns>
        </member>
        <member name="M:KeepCoding.TPScript`1.TryWaitCancel(System.Single,System.String)">
            <summary>
            Yield return this to cause Twitch Plays to wait for the given time, and any time during the entire duration, the command may cancel. Like "trycancel", you won't be able to clean up if you cancel this way. Also like "trycancel", <paramref name="message"/> is optional.
            </summary>
            <param name="time">The amount of time to wait.</param>
            <param name="message">The message to send.</param>
            <returns>A formatted string for Twitch Plays.</returns>
        </member>
        <member name="M:KeepCoding.TPScript`1.SendToChat(System.String)">
            <summary>
            Yield return this to send a chat directly to twitch chat.
            </summary>
            <param name="message">The message to send.</param>
            <returns>A formatted string for Twitch Plays.</returns>
        </member>
        <member name="M:KeepCoding.TPScript`1.SendToChatError(System.String)">
            <summary>
            Yield return this to send a message to the chat about why a users' command was invalid.
            </summary>
            <param name="message">The message to send.</param>
            <returns>A formatted string for Twitch Plays.</returns>
        </member>
        <member name="M:KeepCoding.TPScript`1.SendDelayedMessage(System.Single,System.String)">
            <summary>
            Yield return this to send a message to chat after <paramref name="time"/> seconds.
            </summary>
            <param name="time">The amount of time to wait before the message gets sent.</param>
            <param name="message">The message to send.</param>
            <returns>A formatted string for Twitch Plays.</returns>
        </member>
        <member name="M:KeepCoding.TPScript`1.Detonate(System.Nullable{System.Single},System.String)">
            <summary>
            Yield return this to explode the bomb instantly. <paramref name="time"/> is specified in number of seconds before the bomb explodes. (Note, sending another detonate command will auto-cancel the previous one on the same module if it hasn't happened already.). <paramref name="message"/> is the message to send to chat upon detonation. Both of the parameters are optional.
            </summary>
            <param name="time">The amount of time before the bomb blows up.</param>
            <param name="message">The message to send.</param>
            <returns>A formatted string for Twitch Plays.</returns>
        </member>
        <member name="M:KeepCoding.TPScript`1.SkipTime(System.String)">
            <summary>
            Yield return this to try advancing the clock to the specified time. You must put the full time you wish to skip to, and this time either needs to be less than the current time, if in normal/time mode, or greater than the current time, if in zen mode. Example, if you wanted to set the clock to 5:24, then you do "skiptime 324" or "skiptime 5:24". You can target partway through the seconds, such as "skiptime 45.28", which would then set the clock to 45.28, provided that time has NOT gone by already. You must also set <see cref="P:KeepCoding.TPScript`1.IsTimeSkippable"/> to true, for this function to work.
            </summary>
            <param name="seconds">The time to skip to in seconds.</param>
            <returns>A formatted string for Twitch Plays.</returns>
        </member>
        <member name="M:KeepCoding.TPScript`1.AwardPoints(System.Int32)">
            <summary>
            Yield return this to award the user that sent the command points directly, this is currently used for mods like Souvenir to give points to users that answered the questions equally.
            </summary>
            <param name="points">The amount of points to award. Negatives supported.</param>
            <returns>A formatted string for Twitch Plays.</returns>
        </member>
        <member name="M:KeepCoding.TPScript`1.AwardPointsOnSolve(System.Int32)">
            <summary>
            Yield return this to award the last user that sent the command points when the module is solved. The module must prevent any user from sending commands afterward in order for Twitch Plays to award points to the correct user. This is currently used by the Twin module when extra points must be given but the module is not solved immediately.
            </summary>
            <param name="points">The amount of points to award. Negatives supported.</param>
            <returns>A formatted string for Twitch Plays.</returns>
        </member>
        <member name="M:KeepCoding.TPScript`1.Evaluate``1(System.Boolean,``0,System.Object)">
            <summary>
            Works as a ternary operator. Returns <paramref name="then"/> if <paramref name="condition"/> is true, otherwise <paramref name="otherwise"/>.
            </summary>
            <remarks>
            You can <see langword="yield"/> <see langword="return"/> different types with this method, such as ambiguity between a <see cref="T:KMSelectable"/> <see cref="T:System.Array"/> and a <see cref="T:System.String"/>.
            </remarks>
            <typeparam name="T">The type of then condition.</typeparam>
            <param name="condition">The boolean to check.</param>
            <param name="then">The output to return if <paramref name="condition"/> is true.</param>
            <param name="otherwise">The output to return if <paramref name="condition"/> is false.</param>
            <returns><paramref name="then"/> or <paramref name="otherwise"/>, depending on <paramref name="condition"/>.</returns>
        </member>
        <member name="M:KeepCoding.TPScript`1.YieldWhile``1(``0,System.Func{System.Boolean})">
            <summary>
            You can yield return this to repeatedly yield return an item until a condition is no longer met.
            </summary>
            <param name="item">The item to yield repeatedly.</param>
            <param name="condition">The condition to repeatedly check until it returns <see langword="false"/>.</param>
            <returns><paramref name="item"/> continously until <paramref name="condition"/> is <see langword="false"/></returns>
        </member>
        <member name="M:KeepCoding.TPScript`1.YieldUntil``1(``0,System.Func{System.Boolean})">
            <summary>
            You can yield return this to repeatedly yield return an item until a condition is met.
            </summary>
            <param name="item">The item to yield repeatedly.</param>
            <param name="condition">The condition to repeatedly check until it returns <see langword="false"/>.</param>
            <returns><paramref name="item"/> continously until <paramref name="condition"/> is <see langword="true"/></returns>
        </member>
        <member name="M:KeepCoding.TPScript`1.OnInteractSequence(KMSelectable[],System.Single,System.Int32[])">
            <summary>
            Presses a sequence of buttons according to <paramref name="indices"/> within <paramref name="selectables"/>, waiting <paramref name="wait"/> seconds in-between each, and interrupting as soon as <see cref="P:KeepCoding.ModuleScript.HasStruck"/> is true.
            </summary>
            <param name="selectables">The array of selectables to interact with.</param>
            <param name="indices">The indices to press within the array.</param>
            <param name="wait">The delay between each button press in seconds.</param>
            <returns>A sequence of button presses for Twitch Plays to process.</returns>
        </member>
        <member name="M:KeepCoding.TPScript`1.ProcessTwitchCommand(System.String)">
            <summary>
            This method gets grabbed by Twitch Plays. It grabs <see cref="M:KeepCoding.TPScript`1.Process(System.String)"/> and flattens it using <see cref="M:KeepCoding.Helper.Flatten(System.Collections.IEnumerator,System.Predicate{System.Object})"/>.
            </summary>
            <param name="command">The command of the user.</param>
            <returns>A list of instructions for Twitch Plays.</returns>
        </member>
        <member name="M:KeepCoding.TPScript`1.TwitchHandleForcedSolve">
            <summary>
            This method gets grabbed by Twitch Plays. It grabs <see cref="M:KeepCoding.TPScript`1.ForceSolve"/> and flattens it using <see cref="M:KeepCoding.Helper.Flatten(System.Collections.IEnumerator,System.Predicate{System.Object})"/>.
            </summary>
            <returns>A list of instructions for Twitch Plays.</returns>
        </member>
        <member name="T:KeepCoding.Game">
            <summary>
            Allows access into the game's internal code. 
            </summary>
            <remarks>
            On the Editor, these properties will return default values. Check the XML documentation to see the value it returns.
            </remarks>
        </member>
        <member name="T:KeepCoding.Game.ControlType">
            <summary>
            Determines how the game is controlled.
            </summary>
        </member>
        <member name="F:KeepCoding.Game.ControlType.Gamepad">
            <summary>
            The game is being controlled with a gamepad controller.
            </summary>
        </member>
        <member name="F:KeepCoding.Game.ControlType.Gaze">
            <summary>
            The game is being controlled with a virtual reality headset.
            </summary>
        </member>
        <member name="F:KeepCoding.Game.ControlType.Mouse">
            <summary>
            The game is being controlled with a mouse.
            </summary>
        </member>
        <member name="F:KeepCoding.Game.ControlType.Motion">
            <summary>
            The game is being controlled with virtual reality headset and controller.
            </summary>
        </member>
        <member name="F:KeepCoding.Game.ControlType.Touch">
            <summary>
            The game is being controlled with touch controls.
            </summary>
        </member>
        <member name="F:KeepCoding.Game.ControlType.ThreeDOF">
            <summary>
            The game is being controlled with three degrees of freedom, part of virtual reality.
            </summary>
        </member>
        <member name="T:KeepCoding.Game.ModSourceEnum">
            <summary>
            Determines how the mod is stored.
            </summary>
        </member>
        <member name="F:KeepCoding.Game.ModSourceEnum.Invalid">
            <summary>
            The mod is invalid.
            </summary>
        </member>
        <member name="F:KeepCoding.Game.ModSourceEnum.Local">
            <summary>
            The mod is stored within the local mods folder.
            </summary>
        </member>
        <member name="F:KeepCoding.Game.ModSourceEnum.SteamWorkshop">
            <summary>
            The mod is stored within the workshop folder.
            </summary>
        </member>
        <member name="T:KeepCoding.Game.KTInputManager">
            <summary>
            Allows access relating to how the game is being interacted with.
            </summary>
        </member>
        <member name="P:KeepCoding.Game.KTInputManager.IsCurrentControlTypeVR">
            <summary>
            Determines if the current way the game is being controlled is VR-related.
            </summary>
            <remarks>
            Default: <see langword="false"/>.
            </remarks>
        </member>
        <member name="P:KeepCoding.Game.KTInputManager.CurrentControlType">
            <summary>
            The current way the game is being controlled.
            </summary>
            <remarks>
            Default: <see cref="F:KeepCoding.Game.ControlType.Mouse"/>.
            </remarks>
        </member>
        <member name="T:KeepCoding.Game.MasterAudio">
            <summary>
            Allows access relating to the game's main master channel for audio.
            </summary>
        </member>
        <member name="P:KeepCoding.Game.MasterAudio.IsGroupInfo">
            <summary>
            Determines whether a given string has a group info.
            </summary>
            <remarks>
            Default: <see langword="true"/>.
            </remarks>
        </member>
        <member name="P:KeepCoding.Game.MasterAudio.GroupInfo">
            <summary>
            Gets the group info of a given string. To prevent a reference to the game, the type is boxed in <see cref="T:System.Object"/>. You can cast it to AudioGroupInfo type to restore its functionality.
            </summary>
            <remarks>
            Default: <see langword="null"/>.
            </remarks>
        </member>
        <member name="T:KeepCoding.Game.Mission">
            <summary>
            Allows access relating to the current mission.
            </summary>
        </member>
        <member name="P:KeepCoding.Game.Mission.IsPacingEvents">
            <summary>
            Determines whether or not all pacing events are enabled. Default: <see langword="false"/>.
            </summary>
            <remarks>
            Default: <see langword="false"/>.
            </remarks>
        </member>
        <member name="P:KeepCoding.Game.Mission.Description">
            <summary>
            The description as it appears in the bomb binder.
            </summary>
            <remarks>
            Default: "Everybody has to start somewhere. Let's just hope it doesn't end here too.\n\nMake sure your experts have the manual and are ready to help.".
            </remarks>
        </member>
        <member name="P:KeepCoding.Game.Mission.DisplayName">
            <summary>
            The mission name as it appears in the bomb binder.
            </summary>
            <remarks>
            Default: "The First Bomb"
            </remarks>
        </member>
        <member name="P:KeepCoding.Game.Mission.ID">
            <summary>
            The ID of the mission.
            </summary>
            <remarks>
            Default: "firsttime"
            </remarks>
        </member>
        <member name="P:KeepCoding.Game.Mission.GeneratorSetting">
            <summary>
            Gets the generator setting of the mission.
            </summary>
            <remarks>
            New instance of <see cref="P:KeepCoding.Game.Mission.GeneratorSetting"/>, default constructor.
            </remarks>
        </member>
        <member name="T:KeepCoding.Game.ModManager">
            <summary>
            Allows access to methods relating mod paths.
            </summary>
        </member>
        <member name="P:KeepCoding.Game.ModManager.GetDisabledModPaths">
            <summary>
            Gets all of the disabled mod paths.
            </summary>
            <remarks>
            New instance of <see cref="T:System.Collections.Generic.List`1"/>, with no elements.
            </remarks>
        </member>
        <member name="P:KeepCoding.Game.ModManager.GetAllModPathsFromSource">
            <summary>
            Gets all of the mod paths within the <see cref="T:KeepCoding.Game.ModSourceEnum"/> constraint.
            </summary>
            <remarks>
            New instance of <see cref="T:System.Collections.Generic.List`1"/>, with no elements.
            </remarks>
        </member>
        <member name="P:KeepCoding.Game.ModManager.GetEnabledModPaths">
            <summary>
            Gets all of the enabled mod paths within the <see cref="T:KeepCoding.Game.ModSourceEnum"/> constraint.
            </summary>
            <remarks>
            New instance of <see cref="T:System.Collections.Generic.List`1"/>, with no elements.
            </remarks>
        </member>
        <member name="T:KeepCoding.Game.PlayerSettings">
            <summary>
            Allows access into the player settings from the game. Do not use this class in the unity editor. 
            </summary>
        </member>
        <member name="P:KeepCoding.Game.PlayerSettings.InvertTiltControls">
            <summary>
            Determines if vertical tilting is flipped or not.
            </summary>
            <remarks>
            Default: <see langword="false"/>.
            </remarks>
        </member>
        <member name="P:KeepCoding.Game.PlayerSettings.LockMouseToWindow">
            <summary>
            Determines if the option to lock the mouse to the window is enabled.
            </summary>
            <remarks>
            Default: <see langword="false"/>.
            </remarks>
        </member>
        <member name="P:KeepCoding.Game.PlayerSettings.ShowLeaderBoards">
            <summary>
            Determines if the option to show the leaderboards from the pamphlet.
            </summary>
            <remarks>
            Default: <see langword="true"/>.
            </remarks>
        </member>
        <member name="P:KeepCoding.Game.PlayerSettings.ShowRotationUI">
            <summary>
            Determines if the option to show the rotation of the User Interface is enabled.
            </summary>
            <remarks>
            Default: <see langword="true"/>.
            </remarks>
        </member>
        <member name="P:KeepCoding.Game.PlayerSettings.ShowScanline">
            <summary>
            Determines if the option to show scanlines is enabled.
            </summary>
            <remarks>
            Default: <see langword="true"/>.
            </remarks>
        </member>
        <member name="P:KeepCoding.Game.PlayerSettings.SkipTitleScreen">
            <summary>
            Determines if the option to skip the title screen is enabled.
            </summary>
            <remarks>
            Default: <see langword="false"/>.
            </remarks>
        </member>
        <member name="P:KeepCoding.Game.PlayerSettings.RumbleEnabled">
            <summary>
            Determines if the VR or regular controllers vibrate.
            </summary>
            <remarks>
            Default: <see langword="true"/>.
            </remarks>
        </member>
        <member name="P:KeepCoding.Game.PlayerSettings.TouchpadInvert">
            <summary>
            Determines if the touchpad controls are inverted.
            </summary>
            <remarks>
            Default: <see langword="false"/>.
            </remarks>
        </member>
        <member name="P:KeepCoding.Game.PlayerSettings.UseModsAlways">
            <summary>
            Determines if the option to always use mods is enabled.
            </summary>
            <remarks>
            Default: <see langword="false"/>.
            </remarks>
        </member>
        <member name="P:KeepCoding.Game.PlayerSettings.UseParallelModLoading">
            <summary>
            Determines if the option to use parallel/simultaneous mod loading is enabled.
            </summary>
            <remarks>
            Default: <see langword="false"/>.
            </remarks>
        </member>
        <member name="P:KeepCoding.Game.PlayerSettings.VRModeRequested">
            <summary>
            Determines if VR mode is requested.
            </summary>
        </member>
        <member name="P:KeepCoding.Game.PlayerSettings.AntiAliasing">
            <summary>
            The intensity of anti-aliasing currently on the game. Ranges 0 to 8.
            </summary>
            <remarks>
            Default: 8.
            </remarks>
        </member>
        <member name="P:KeepCoding.Game.PlayerSettings.MusicVolume">
            <summary>
            The current music volume from the dossier menu. Ranges 0 to 100.
            </summary>
            <remarks>
            Default: 100.
            </remarks>
        </member>
        <member name="P:KeepCoding.Game.PlayerSettings.SFXVolume">
            <summary>
            The current sound effects volume from the dosssier menu. Ranges 0 to 100.
            </summary>
            <remarks>
            Default: 100.
            </remarks>
        </member>
        <member name="P:KeepCoding.Game.PlayerSettings.VSync">
            <summary>
            Determines if VSync is on or off.
            </summary>
            <remarks>
            Default: 1.
            </remarks>
        </member>
        <member name="P:KeepCoding.Game.PlayerSettings.LanguageCode">
            <summary>
            The current language code.
            </summary>
            <remarks>
            Default: "en".
            </remarks>
        </member>
        <member name="P:KeepCoding.Game.AddStrikes">
            <summary>
            Adds an amount of strikes on the bomb.
            </summary>
            <remarks>
            Default: Internal Logger method call.
            </remarks>
        </member>
        <member name="P:KeepCoding.Game.SetStrikes">
            <summary>
            Sets an amount of strikes on the bomb.
            </summary>
            <remarks>
            Default: Internal Logger method call.
            </remarks>
        </member>
        <member name="P:KeepCoding.Game.Bomb">
            <summary>
            Gets the game's internal bomb component, not to be mistaken with <see cref="T:KMBomb"/>. To prevent a reference to the game, the type is boxed in <see cref="T:System.Object"/>. You can cast it to Bomb or <see cref="T:UnityEngine.MonoBehaviour"/> type to restore its functionality.
            </summary>
            <remarks>
            Default: <see langword="null"/>.
            </remarks>
        </member>
        <member name="P:KeepCoding.Game.Timer">
            <summary>
            Gets the game's internal timer component. To prevent a reference to the game, the type is boxed in <see cref="T:System.Object"/>. You can cast it to TimerComponent or <see cref="T:UnityEngine.MonoBehaviour"/> type to restore its functionality.
            </summary>
            <remarks>
            Default: <see langword="null"/>.
            </remarks>
        </member>
        <member name="P:KeepCoding.Game.Vanillas">
            <summary>
            Gets all of the vanilla modules from the bomb supplied, including needies. To prevent a reference to the game, the type is boxed in an <see cref="T:System.Object"/> <see cref="T:System.Array"/>. You can cast it to BombComponent type to restore its functionality.
            </summary>
            <remarks>
            Default: An empty <see cref="T:System.Object"/> <see cref="T:System.Array"/>.
            </remarks>
        </member>
        <member name="T:KeepCoding.PathManager">
            <summary>
            Allows loading external information stored on the module. 
            </summary>
        </member>
        <member name="P:KeepCoding.PathManager.AssemblyName">
            <summary>
            Gets this library's <see cref="P:KeepCoding.PathManager.AssemblyName"/>.
            </summary>
        </member>
        <member name="P:KeepCoding.PathManager.Version">
            <summary>
            Gets this library's version number. Currently used by <see cref="T:KeepCoding.ModuleScript"/> to log the version number of this library.
            </summary>
            <remarks>
            If you want the version number of your modules, refer to <see cref="P:KeepCoding.ModuleScript.Version"/> instead, or <see cref="M:KeepCoding.PathManager.GetModInfo``1(``0)"/>.
            </remarks>
        </member>
        <member name="M:KeepCoding.PathManager.PrintHierarchy(System.UInt16)">
            <summary>
            Prints a hierarchy of all game objects.
            </summary>
            <param name="indentation">The amount of spaces used for indenting children of game objects.</param>
        </member>
        <member name="M:KeepCoding.PathManager.PrintHierarchy(UnityEngine.GameObject,System.UInt16,System.UInt16)">
            <summary>
            Prints the hierarchy from the game object specified.
            </summary>
            <param name="obj">The game object to search the hierarchy.</param>
            <param name="indentation">The amount of spaces used for indenting children of game objects.</param>
            <param name="depth">The level of depth which determines level of indentation. Leave this variable as 0.</param>
        </member>
        <member name="M:KeepCoding.PathManager.CombineMultiple(System.String[])">
            <summary>
            Combines multiple paths together.
            </summary>
            <param name="paths">The paths to combine with.</param>
            <returns>A single path consisting of the combined path of the array.</returns>
        </member>
        <member name="M:KeepCoding.PathManager.NameOfAssembly(System.Type)">
            <summary>
            Gets the assembly's directory where the type <paramref name="type"/> exists.
            </summary>
            <param name="type">The type to get the assembly directory of.</param>
            <returns>The path to the directory of the assembly where the type <paramref name="type"/> comes from.</returns>
        </member>
        <member name="M:KeepCoding.PathManager.NameOfAssembly``1">
            <summary>
            Gets the assembly's directory where the type <typeparamref name="T"/> exists.
            </summary>
            <typeparam name="T">The type to get the assembly directory of.</typeparam>
            <returns>The path to the directory of the assembly where the type <typeparamref name="T"/> comes from.</returns>
        </member>
        <member name="M:KeepCoding.PathManager.GetModInfo(System.String)">
            <summary>
            Gets the path and deserializes the modInfo.json located at every mod's root folder.
            </summary>
            <exception cref="T:KeepCoding.Internal.EmptyIteratorException"></exception>
            <exception cref="T:KeepCoding.Internal.NullIteratorException"></exception>
            <exception cref="T:System.IO.FileNotFoundException"></exception>
            <param name="bundleFileName">The name of the bundle assembly.</param>
            <returns>A <see cref="T:KeepCoding.ModInfo"/> of the mod info json file located in the mod.</returns>
        </member>
        <member name="M:KeepCoding.PathManager.GetModInfo(System.Type)">
            <summary>
            Gets the path and deserializes the modInfo.json located at every mod's root folder.
            </summary>
            <exception cref="T:KeepCoding.Internal.EmptyIteratorException"></exception>
            <exception cref="T:KeepCoding.Internal.NullIteratorException"></exception>
            <exception cref="T:System.IO.FileNotFoundException"></exception>
            <param name="type">Any data from the assembly, which is used to get the name.</param>
            <returns>A <see cref="T:KeepCoding.ModInfo"/> of the mod info json file located in the mod.</returns>
        </member>
        <member name="M:KeepCoding.PathManager.GetModInfo``1(``0)">
            <summary>
            Gets the path and deserializes the modInfo.json located at every mod's root folder.
            </summary>
            <exception cref="T:KeepCoding.Internal.EmptyIteratorException"></exception>
            <exception cref="T:KeepCoding.Internal.NullIteratorException"></exception>
            <exception cref="T:System.IO.FileNotFoundException"></exception>
            <typeparam name="T">The type to get the assembly from, which is used to get the name.</typeparam>
            <param name="_">Any data from the assembly, which is used to get the name.</param>
            <returns>A <see cref="T:KeepCoding.ModInfo"/> of the mod info json file located in the mod.</returns>
        </member>
        <member name="M:KeepCoding.PathManager.GetPath(System.String)">
            <summary>
            Finds the path of a given file within each mod.
            </summary>
            <remarks>
            You need to specify the extensions of the file too, otherwise the file cannot be found.
            </remarks>
            <exception cref="T:KeepCoding.Internal.EmptyIteratorException"></exception>
            <exception cref="T:System.IO.FileNotFoundException"></exception>
            <exception cref="T:KeepCoding.Internal.NullIteratorException"></exception>
            <param name="search">The file to search for. Make sure to include extensions!</param>
            <returns>The path to <paramref name="search"/>.</returns>
        </member>
        <member name="M:KeepCoding.PathManager.GetPath(System.Type)">
            <summary>
            Finds the path of the mod.
            </summary>
            <param name="type">Any data from the assembly, which is used to get the name.</param>
            <returns>The path to the mod.</returns>
        </member>
        <member name="M:KeepCoding.PathManager.GetPath``1(``0)">
            <summary>
            Finds the path of the mod.
            </summary>
            <typeparam name="T">The type to get the assembly from, which is used to get the name.</typeparam>
            <param name="_">Any data from the assembly, which is used to get the name.</param>
            <returns>The path to the mod.</returns>
        </member>
        <member name="M:KeepCoding.PathManager.LoadLibrary(System.String,System.String)">
            <summary>
            Loads a library by searching for the bundle. Do not run this on the Editor.
            </summary>
            <remarks>
            If the library has already been loaded, then this method will prematurely halt.
            </remarks>
            <exception cref="T:KeepCoding.Internal.EmptyIteratorException"></exception>
            <exception cref="T:System.IO.FileNotFoundException"></exception>
            <exception cref="T:KeepCoding.Internal.NullIteratorException"></exception>
            <param name="bundleFileName">The name of the bundle file.</param>
            <param name="libraryFileName">The library's name, excluding the extension.</param>
        </member>
        <member name="M:KeepCoding.PathManager.LoadLibrary(System.Type,System.String)">
            <summary>
            Loads a library by searching for the bundle. Do not run this on the Editor.
            </summary>
            <remarks>
            If the library has already been loaded, then this method will prematurely halt.
            </remarks>
            <exception cref="T:KeepCoding.Internal.EmptyIteratorException"></exception>
            <exception cref="T:System.IO.FileNotFoundException"></exception>
            <exception cref="T:KeepCoding.Internal.NullIteratorException"></exception>
            <param name="type">Any data from the assembly, which is used to get the name.</param>
            <param name="libraryFileName">The library's name, excluding the extension.</param>
        </member>
        <member name="M:KeepCoding.PathManager.LoadLibrary``1(``0,System.String)">
            <summary>
            Loads a library by searching for the bundle. Do not run this on the Editor.
            </summary>
            <remarks>
            If the library has already been loaded, then this method will prematurely halt.
            </remarks>
            <exception cref="T:KeepCoding.Internal.EmptyIteratorException"></exception>
            <exception cref="T:System.IO.FileNotFoundException"></exception>
            <exception cref="T:KeepCoding.Internal.NullIteratorException"></exception>
            <typeparam name="T">The type to get the assembly from, which is used to get the name.</typeparam>
            <param name="_">Any data from the assembly, which is used to get the name.</param>
            <param name="libraryFileName">The library's name, excluding the extension.</param>
        </member>
        <member name="M:KeepCoding.PathManager.GetAssets``1(System.String,System.String)">
            <summary>
            Retrieves assets of a specific type from a different bundle file.
            </summary>
            <typeparam name="TAsset">The type of asset to retrieve.</typeparam>
            <param name="bundleFileName">The name of the bundle file.</param>
            <param name="bundleAssetFileName">The name of the bundle file to grab the assets from.</param>
            <returns>The assets retrieved from the file.</returns>
        </member>
        <member name="M:KeepCoding.PathManager.GetAssets``1(System.Type,System.String)">
            <summary>
            Retrieves assets of a specific type from a different bundle file.
            </summary>
            <exception cref="T:KeepCoding.Internal.EmptyIteratorException"></exception>
            <exception cref="T:System.IO.FileNotFoundException"></exception>
            <exception cref="T:KeepCoding.Internal.NullIteratorException"></exception>
            <param name="type">Any data from the assembly, which is used to get the name.</param>
            <param name="bundleVideoFileName">The name of the bundle that contains videos.</param>
            <returns>The <see cref="T:UnityEngine.AssetBundleCreateRequest"/> needed to load the files, followed by the <see cref="T:UnityEngine.Video.VideoClip"/> <see cref="T:System.Array"/>.</returns>
        </member>
        <member name="M:KeepCoding.PathManager.GetAssets``2(``0,System.String)">
            <summary>
            Retrieves assets of a specific type from a different bundle file.
            </summary>
            <exception cref="T:KeepCoding.Internal.EmptyIteratorException"></exception>
            <exception cref="T:System.IO.FileNotFoundException"></exception>
            <exception cref="T:KeepCoding.Internal.NullIteratorException"></exception>
            <typeparam name="T">The type to get the assembly from, which is used to get the name.</typeparam>
            <typeparam name="TAsset">The type of asset to return.</typeparam>
            <param name="_">Any data from the assembly, which is used to get the name.</param>
            <param name="bundleVideoFileName">The name of the bundle that contains videos.</param>
            <returns>The <see cref="T:UnityEngine.AssetBundleCreateRequest"/> needed to load the files, followed by the <see cref="T:UnityEngine.Video.VideoClip"/> <see cref="T:System.Array"/>.</returns>
        </member>
        <member name="T:AudioScript">
            <summary>
            Encapsulates an <see cref="P:AudioScript.AudioSource"/> and scales it with the game's volume using <see cref="P:KeepCoding.Game.PlayerSettings.SFXVolume"/> and <see cref="P:KeepCoding.Game.PlayerSettings.MusicVolume"/>.
            </summary>
        </member>
        <member name="P:AudioScript.IsMuted">
            <summary>
            Determines if the <see cref="P:AudioScript.AudioSource"/> is muted.
            </summary>
        </member>
        <member name="P:AudioScript.IsPlaying">
            <summary>
            Determines if the audio source is currently playing.
            </summary>
        </member>
        <member name="P:AudioScript.Game">
            <summary>
            The current volume of the game. Ranges 0 to 100. In the Editor this value will always return 100.
            </summary>
        </member>
        <member name="P:AudioScript.Relative">
            <summary>
            The volume the <see cref="P:AudioScript.AudioSource"/> is playing at, determined by <see cref="P:AudioScript.Volume"/> and <see cref="P:AudioScript.Game"/>.
            </summary>
        </member>
        <member name="P:AudioScript.Volume">
            <summary>
            The volume of the sound relative to the game.
            </summary>
        </member>
        <member name="P:AudioScript.AudioClips">
            <summary>
            The audio clips used by the <see cref="T:UnityEngine.AudioSource"/>s.
            </summary>
        </member>
        <member name="P:AudioScript.AudioSource">
            <summary>
            The main <see cref="T:UnityEngine.AudioSource"/> property. If the field it is referencing is <see langword="null"/> then it adds a component.
            </summary>
        </member>
        <member name="F:AudioScript._isSFX">
            <summary>
            Setting this value to true will make the volume relative to <see cref="P:KeepCoding.Game.PlayerSettings.MusicVolume"/>, and <see cref="P:KeepCoding.Game.PlayerSettings.SFXVolume"/> otherwise.
            </summary>
        </member>
        <member name="F:AudioScript._audioClips">
            <summary>
            The <see cref="T:System.Array"/> of clips it can play from.
            </summary>
        </member>
        <member name="F:AudioScript._audioSource">
            <summary>
            The audio source field.
            </summary>
        </member>
        <member name="M:AudioScript.op_Explicit(AudioScript)~UnityEngine.AudioSource">
            <summary>
            Returns the <see cref="P:AudioScript.AudioSource"/>.
            </summary>
            <param name="dynamicAudio">The instance of <see cref="T:AudioScript"/> to retrieve <see cref="P:AudioScript.AudioSource"/> from.</param>
        </member>
        <member name="M:AudioScript.Fade(System.Single,System.Single)">
            <summary>
            Fades the audio source to a specific volume from a specified duration of time linearly.
            </summary>
            <param name="volume">The volume to get to.</param>
            <param name="time">The amount of time it takes to get to <paramref name="volume"/>.</param>
        </member>
        <member name="M:AudioScript.Pause">
            <summary>
            Pauses playing the clip.
            </summary>
        </member>
        <member name="M:AudioScript.Play(UnityEngine.AudioClip,System.Boolean,System.Byte,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Plays a sound, with optional parameters.
            </summary>
            <remarks>
            The sound can be cancelled with this method, but multiple sounds cannot play simultaneously.
            </remarks>
            <exception cref="T:KeepCoding.Internal.NullIteratorException"></exception>
            <param name="clip">The sound clip to play.</param>
            <param name="volume">The volume of the sound clip relative to the game sound.</param>
            <param name="loop">If the sound should be looped.</param>
            <param name="priority">The priority of the sound.</param>
            <param name="delay">The amount of delay before the sound starts.</param>
            <param name="time">The time in the audio it should start playing at.</param>
            <param name="pitch">The pitch of the sound.</param>
        </member>
        <member name="M:AudioScript.Play(System.String,System.Boolean,System.Byte,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Plays a sound, with optional parameters.
            </summary>
            <remarks>
            The sound can be cancelled with this method, but multiple sounds cannot play simultaneously.
            </remarks>
            <exception cref="T:KeepCoding.Internal.NullIteratorException"></exception>
            <exception cref="T:UnityEngine.MissingComponentException"></exception>
            <param name="name">The name of the sound clip to play.</param>
            <param name="volume">The volume of the sound clip relative to the game sound.</param>
            <param name="loop">If the sound should be looped.</param>
            <param name="priority">The priority of the sound.</param>
            <param name="delay">The amount of delay before the sound starts.</param>
            <param name="time">The time in the audio it should start playing at.</param>
            <param name="pitch">The pitch of the sound.</param>
        </member>
        <member name="M:AudioScript.PlayStackable(UnityEngine.AudioClip,System.Boolean,System.Byte,System.Single,System.Single,System.Single)">
            <summary>
            Plays a sound, with optional parameters.
            </summary>
            <remarks>
            Multiple sounds can be played simultaneously with this method, however they cannot be cancelled.
            </remarks>
            <exception cref="T:KeepCoding.Internal.NullIteratorException"></exception>
            <param name="clip">The sound clip to play.</param>
            <param name="volume">The volume of the sound clip relative to the game sound.</param>
            <param name="loop">If the sound should be looped.</param>
            <param name="priority">The priority of the sound.</param>
            <param name="time">The time in the audio it should start playing at.</param>
            <param name="pitch">The pitch of the sound.</param>
        </member>
        <member name="M:AudioScript.PlayStackable(System.String,System.Boolean,System.Byte,System.Single,System.Single,System.Single)">
            <summary>
            Plays a sound, with optional parameters.
            </summary>
            <remarks>
            Multiple sounds can be played simultaneously with this method, however they cannot be cancelled.
            </remarks>
            <exception cref="T:KeepCoding.Internal.NullIteratorException"></exception>
            <exception cref="T:UnityEngine.MissingComponentException"></exception>
            <param name="name">The name of the sound clip to play.</param>
            <param name="volume">The volume of the sound clip relative to the game sound.</param>
            <param name="loop">If the sound should be looped.</param>
            <param name="priority">The priority of the sound.</param>
            <param name="time">The time in the audio it should start playing at.</param>
            <param name="pitch">The pitch of the sound.</param>
        </member>
        <member name="M:AudioScript.Stop">
            <summary>
            Stops playing the clip.
            </summary>
        </member>
        <member name="M:AudioScript.Unpause">
            <summary>
            Unpauses the paused playback of this <see cref="P:AudioScript.AudioSource"/>.
            </summary>
        </member>
    </members>
</doc>
